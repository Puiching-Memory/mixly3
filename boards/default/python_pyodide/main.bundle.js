/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../python/blocks/control.js":
/*!***********************************!*\
  !*** ../python/blocks/control.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base_setup: () => (/* binding */ base_setup),
/* harmony export */   controls_delay: () => (/* binding */ controls_delay),
/* harmony export */   controls_end_program: () => (/* binding */ controls_end_program),
/* harmony export */   controls_except: () => (/* binding */ controls_except),
/* harmony export */   controls_finally: () => (/* binding */ controls_finally),
/* harmony export */   controls_flow_statements: () => (/* binding */ controls_flow_statements),
/* harmony export */   controls_for: () => (/* binding */ controls_for),
/* harmony export */   controls_forEach: () => (/* binding */ controls_forEach),
/* harmony export */   controls_for_range: () => (/* binding */ controls_for_range),
/* harmony export */   controls_if: () => (/* binding */ controls_if),
/* harmony export */   controls_if_else: () => (/* binding */ controls_if_else),
/* harmony export */   controls_if_elseif: () => (/* binding */ controls_if_elseif),
/* harmony export */   controls_if_if: () => (/* binding */ controls_if_if),
/* harmony export */   controls_lambda: () => (/* binding */ controls_lambda),
/* harmony export */   controls_main: () => (/* binding */ controls_main),
/* harmony export */   controls_pass: () => (/* binding */ controls_pass),
/* harmony export */   controls_range: () => (/* binding */ controls_range),
/* harmony export */   controls_repeat_ext: () => (/* binding */ controls_repeat_ext),
/* harmony export */   controls_thread: () => (/* binding */ controls_thread),
/* harmony export */   controls_try: () => (/* binding */ controls_try),
/* harmony export */   controls_try_finally: () => (/* binding */ controls_try_finally),
/* harmony export */   controls_whileUntil: () => (/* binding */ controls_whileUntil),
/* harmony export */   datetime_fromtimestamp: () => (/* binding */ datetime_fromtimestamp),
/* harmony export */   do_while: () => (/* binding */ do_while),
/* harmony export */   garbage_collection: () => (/* binding */ garbage_collection),
/* harmony export */   get_mem_alloc: () => (/* binding */ get_mem_alloc),
/* harmony export */   get_mem_free: () => (/* binding */ get_mem_free),
/* harmony export */   get_unique_identifier: () => (/* binding */ get_unique_identifier)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const LOOPS_HUE = 120;

const controls_main = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_NAME_MAIN);
        this.appendStatementInput('DO')
            .appendField('');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_CONTROL_SETUP);
    }
};

const base_setup = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SETUP);
        this.appendStatementInput('DO')
            .appendField('');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_CONTROL_SETUP);
    }
};

const controls_delay = {
    init: function () {
        var UNIT = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_mSecond, 'delay'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_uSecond, 'delayMicroseconds']
        ];
        this.setColour(LOOPS_HUE);
        this.appendValueInput("DELAY_TIME", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DELAY)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(UNIT), 'UNIT')
            .setCheck(Number);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_CONTROL_DELAY);
        this.setHelpUrl("https://mixly.readthedocs.io/zh_CN/latest/arduino/03.Control.html#id9");
        this.wiki = {
            'zh-hans': {
                page: ['Arduino AVR', '控制', '延时']
            }
        };
    }
};

const controls_end_program = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CONTROL_END_PROGRAM);
        this.setPreviousStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_CONTROL_END_TOOLTIP);
    }
};

const controls_if = {
    /**
     * Block for if/elseif/else condition.
     * @this Blockly.Block
     */
    init: function () {
        //this.setHelpUrl(Blockly.Msg.CONTROLS_IF_HELPURL);
        this.setColour(LOOPS_HUE);
        this.appendValueInput('IF0')
            .setCheck([Boolean, Number])
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_MSG_IF);
        this.appendStatementInput('DO0')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_MSG_THEN);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setHelpUrl("https://mixly.readthedocs.io/zh_CN/latest/arduino/03.Control.html#if");
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['controls_if_elseif',
            'controls_if_else'], this));
        // Assign 'this' to a variable for use in the tooltip closure below.
        var thisBlock = this;
        this.setTooltip(function () {
            if (!thisBlock.elseifCount_ && !thisBlock.elseCount_) {
                return blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_TOOLTIP_1;
            } else if (!thisBlock.elseifCount_ && thisBlock.elseCount_) {
                return blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_TOOLTIP_2;
            } else if (thisBlock.elseifCount_ && !thisBlock.elseCount_) {
                return blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_TOOLTIP_3;
            } else if (thisBlock.elseifCount_ && thisBlock.elseCount_) {
                return blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_TOOLTIP_4;
            }
            return '';
        });
        this.elseifCount_ = 0;
        this.elseCount_ = 0;
    },
    /**
     * Create XML to represent the number of else-if and else inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        if (!this.elseifCount_ && !this.elseCount_) {
            return null;
        }
        var container = document.createElement('mutation');
        if (this.elseifCount_) {
            container.setAttribute('elseif', this.elseifCount_);
        }
        if (this.elseCount_) {
            container.setAttribute('else', 1);
        }
        return container;
    },
    /**
     * Parse XML to restore the else-if and else inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        var containerBlock = this;
        var valueConnections = [];
        var statementConnections = [];
        // var elseStatementConnection = null;
        if (this.elseCount_) {
            // if (containerBlock.getInputTargetBlock('ELSE') && containerBlock.getInputTargetBlock('ELSE').previousConnection)
            //     elseStatementConnection = containerBlock.getInputTargetBlock('ELSE').previousConnection;
            this.removeInput('ELSE');
        }
        for (var i = this.elseifCount_; i > 0; i--) {
            if (containerBlock.getInputTargetBlock('IF' + i) && containerBlock.getInputTargetBlock('IF' + i).previousConnection)
                valueConnections[i] = (containerBlock.getInputTargetBlock('IF' + i).previousConnection);
            else
                valueConnections[i] = null;
            this.removeInput('IF' + i);
            if (containerBlock.getInputTargetBlock('DO' + i) && containerBlock.getInputTargetBlock('DO' + i).previousConnection)
                statementConnections[i] = (containerBlock.getInputTargetBlock('DO' + i).previousConnection);
            else
                statementConnections[i] = null;
            this.removeInput('DO' + i);
        }
        this.elseifCount_ = parseInt(xmlElement.getAttribute('elseif'), 10);
        this.elseCount_ = parseInt(xmlElement.getAttribute('else'), 10);
        //this.compose(containerBlock);
        for (var i = 1; i <= this.elseifCount_; i++) {
            this.appendValueInput('IF' + i)
                .setCheck([Boolean, Number])
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_MSG_ELSEIF);
            this.appendStatementInput('DO' + i)
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_MSG_THEN);
        }
        if (this.elseCount_) {
            this.appendStatementInput('ELSE')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_MSG_ELSE);
        }
        for (var i = valueConnections.length - 2; i > 0; i--) {
            if (valueConnections[i])
                valueConnections[i].reconnect(this, 'IF' + i);
        }
        for (var i = statementConnections.length - 2; i > 0; i--) {
            if (statementConnections[i])
                statementConnections[i].reconnect(this, 'DO' + i);
        }
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock = workspace.newBlock('controls_if_if');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 1; i <= this.elseifCount_; i++) {
            var elseifBlock = workspace.newBlock('controls_if_elseif');
            elseifBlock.initSvg();
            connection.connect(elseifBlock.previousConnection);
            connection = elseifBlock.nextConnection;
        }
        if (this.elseCount_) {
            var elseBlock = workspace.newBlock('controls_if_else');
            elseBlock.initSvg();
            connection.connect(elseBlock.previousConnection);
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        // Disconnect the else input blocks and remove the inputs.
        if (this.elseCount_) {
            this.removeInput('ELSE');
        }
        this.elseCount_ = 0;
        // Disconnect all the elseif input blocks and remove the inputs.
        for (var i = this.elseifCount_; i > 0; i--) {
            this.removeInput('IF' + i);
            this.removeInput('DO' + i);
        }
        this.elseifCount_ = 0;
        // Rebuild the block's optional inputs.
        var clauseBlock = containerBlock.getInputTargetBlock('STACK');
        var valueConnections = [null];
        var statementConnections = [null];
        var elseStatementConnection = null;
        while (clauseBlock) {
            switch (clauseBlock.type) {
                case 'controls_if_elseif':
                    this.elseifCount_++;
                    valueConnections.push(clauseBlock.valueConnection_);
                    statementConnections.push(clauseBlock.statementConnection_);
                    break;
                case 'controls_if_else':
                    this.elseCount_++;
                    elseStatementConnection = clauseBlock.statementConnection_;
                    break;
                default:
                    throw Error('Unknown block type: ' + clauseBlock.type);
            }
            clauseBlock = clauseBlock.nextConnection &&
                clauseBlock.nextConnection.targetBlock();
        }

        this.updateShape_();
        // Reconnect any child blocks.
        this.reconnectChildBlocks_(valueConnections, statementConnections, elseStatementConnection);

    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var clauseBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 1;
        while (clauseBlock) {
            switch (clauseBlock.type) {
                case 'controls_if_elseif':
                    var inputIf = this.getInput('IF' + i);
                    var inputDo = this.getInput('DO' + i);
                    clauseBlock.valueConnection_ =
                        inputIf && inputIf.connection.targetConnection;
                    clauseBlock.statementConnection_ =
                        inputDo && inputDo.connection.targetConnection;
                    i++;
                    break;
                case 'controls_if_else':
                    var inputDo = this.getInput('ELSE');
                    clauseBlock.statementConnection_ =
                        inputDo && inputDo.connection.targetConnection;
                    break;
                default:
                    throw 'Unknown block type.';
            }
            clauseBlock = clauseBlock.nextConnection &&
                clauseBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Reconstructs the block with all child blocks attached.
     */
    rebuildShape_: function () {
        var valueConnections = [null];
        var statementConnections = [null];
        var elseStatementConnection = null;

        if (this.getInput('ELSE')) {
            elseStatementConnection = this.getInput('ELSE').connection.targetConnection;
        }
        var i = 1;
        while (this.getInput('IF' + i)) {
            var inputIf = this.getInput('IF' + i);
            var inputDo = this.getInput('DO' + i);
            console.log(inputIf.connection.targetConnection);
            valueConnections.push(inputIf.connection.targetConnection);
            statementConnections.push(inputDo.connection.targetConnection);
            i++;
        }
        this.updateShape_();
        this.reconnectChildBlocks_(valueConnections, statementConnections, elseStatementConnection);
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @this Blockly.Block
     * @private
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('ELSE')) {
            this.removeInput('ELSE');
        }
        var i = 1;
        while (this.getInput('IF' + i)) {
            this.removeInput('IF' + i);
            this.removeInput('DO' + i);
            i++;
        }
        // Rebuild block.
        for (var i = 1; i <= this.elseifCount_; i++) {
            this.appendValueInput('IF' + i)
                .setCheck([Number, Boolean])
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['CONTROLS_IF_MSG_ELSEIF']);
            this.appendStatementInput('DO' + i)
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['CONTROLS_IF_MSG_THEN']);
        }
        if (this.elseCount_) {
            this.appendStatementInput('ELSE')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['CONTROLS_IF_MSG_ELSE']);
        }
    },
    /**
     * Reconnects child blocks.
     * @param {!Array<?Blockly.RenderedConnection>} valueConnections List of value
     * connectsions for if input.
     * @param {!Array<?Blockly.RenderedConnection>} statementConnections List of
     * statement connections for do input.
     * @param {?Blockly.RenderedConnection} elseStatementConnection Statement
     * connection for else input.
     */
    reconnectChildBlocks_: function (valueConnections, statementConnections,
        elseStatementConnection) {
        for (var i = 1; i <= this.elseifCount_; i++) {
            valueConnections[i] && valueConnections[i].reconnect(this, 'IF' + i);
            statementConnections[i] && statementConnections[i].reconnect(this, 'DO' + i);
        }
        elseStatementConnection && elseStatementConnection.reconnect(this, 'ELSE');
    }
};


const controls_range = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendValueInput('FROM')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYTHON_RANGE)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FOR_INPUT_FROM);
        this.appendValueInput('TO')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FOR_INPUT_TO);
        this.appendValueInput('STEP')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYTHON_RANGE_STEP);
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_RANGE_TOOLTIP);
    }
};


const controls_forEach = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendValueInput('LIST')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_FOREACH_INPUT);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_FOREACH_INPUT_ITEM)
        //    .appendField(new Blockly.FieldTextInput('i'), 'VAR');
        this.appendStatementInput('DO')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DO);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(function () {
            return blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_FOR_TOOLTIP.replace('“%1”', '');
        });
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const controls_whileUntil = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendValueInput('BOOL')
            .setCheck([Boolean, Number])
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_CURRENT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(this.OPERATORS), 'MODE')
        // this.appendDummyInput()
        //     .appendField(Blockly.Msg.CONTROLS_WHILE_SHI);
        this.appendStatementInput('DO')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_WHILEUNTIL_TITLE_REPEAT + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DO);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var op = thisBlock.getFieldValue('MODE');
            var TOOLTIPS = {
                'WHILE': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_WHILEUNTIL_TOOLTIP_WHILE,
                'UNTIL': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL
            };
            return TOOLTIPS[op];
        });
    }
};

const controls_try_finally = {
    /**
     * Block for if/elseif/else condition.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TRY);
        this.appendStatementInput('try');
        this.appendValueInput('IF1')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_EXCEPT);
        this.appendStatementInput('DO1')
            .appendField('');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['controls_except', 'controls_finally'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_CONTROL_TRY_TOOLTIP);
        this.elseifCount_ = 1;
        this.elseCount_ = 0;
    },
    /**
     * Create XML to represent the number of else-if and else inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        if (!this.elseifCount_ && !this.elseCount_) {
            return null;
        }
        var container = document.createElement('mutation');
        if (this.elseifCount_) {
            container.setAttribute('elseif', this.elseifCount_);
        }
        if (this.elseCount_) {
            container.setAttribute('else', 1);
        }
        return container;
    },
    /**
     * Parse XML to restore the else-if and else inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        var containerBlock = this;
        var valueConnections = [];
        var statementConnections = [];
        // var elseStatementConnection = null;
        if (this.elseCount_) {
            // if (containerBlock.getInputTargetBlock('ELSE') && containerBlock.getInputTargetBlock('ELSE').previousConnection)
            //     elseStatementConnection = containerBlock.getInputTargetBlock('ELSE').previousConnection;
            this.removeInput('ELSE');
        }
        for (var i = this.elseifCount_; i > 0; i--) {
            if (containerBlock.getInputTargetBlock('IF' + i) && containerBlock.getInputTargetBlock('IF' + i).previousConnection)
                valueConnections[i] = (containerBlock.getInputTargetBlock('IF' + i).previousConnection);
            else
                valueConnections[i] = null;
            this.removeInput('IF' + i);
            if (containerBlock.getInputTargetBlock('DO' + i) && containerBlock.getInputTargetBlock('DO' + i).previousConnection)
                statementConnections[i] = (containerBlock.getInputTargetBlock('DO' + i).previousConnection);
            else
                statementConnections[i] = null;
            this.removeInput('DO' + i);
        }
        this.elseifCount_ = parseInt(xmlElement.getAttribute('elseif'), 10);
        this.elseCount_ = parseInt(xmlElement.getAttribute('else'), 10);
        //this.compose(containerBlock);
        for (var i = 1; i <= this.elseifCount_; i++) {
            this.appendValueInput('IF' + i)
                .setCheck([Boolean, Number])
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_EXCEPT);
            this.appendStatementInput('DO' + i)
                .appendField("");
        }
        if (this.elseCount_) {
            this.appendStatementInput('ELSE')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_FINALLY);
        }
        for (var i = valueConnections.length - 2; i > 0; i--) {
            if (valueConnections[i])
                valueConnections[i].reconnect(this, 'IF' + i);
        }
        for (var i = statementConnections.length - 2; i > 0; i--) {
            if (statementConnections[i])
                statementConnections[i].reconnect(this, 'DO' + i);
        }
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock = workspace.newBlock('controls_try');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 1; i <= this.elseifCount_; i++) {
            var elseifBlock = workspace.newBlock('controls_except');
            elseifBlock.initSvg();
            connection.connect(elseifBlock.previousConnection);
            connection = elseifBlock.nextConnection;
        }
        if (this.elseCount_) {
            var elseBlock = workspace.newBlock('controls_finally');
            elseBlock.initSvg();
            connection.connect(elseBlock.previousConnection);
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        // Disconnect the else input blocks and remove the inputs.
        if (this.elseCount_) {
            this.removeInput('ELSE');
        }
        this.elseCount_ = 0;
        // Disconnect all the elseif input blocks and remove the inputs.
        for (var i = this.elseifCount_; i > 0; i--) {
            this.removeInput('IF' + i);
            this.removeInput('DO' + i);
        }
        this.elseifCount_ = 0;
        // Rebuild the block's optional inputs.
        var clauseBlock = containerBlock.getInputTargetBlock('STACK');
        var valueConnections = [null];
        var statementConnections = [null];
        var elseStatementConnection = null;
        while (clauseBlock) {
            switch (clauseBlock.type) {
                case 'controls_except':
                    this.elseifCount_++;
                    valueConnections.push(clauseBlock.valueConnection_);
                    statementConnections.push(clauseBlock.statementConnection_);
                    break;
                case 'controls_finally':
                    this.elseCount_++;
                    elseStatementConnection = clauseBlock.statementConnection_;
                    break;
                default:
                    throw Error('Unknown block type: ' + clauseBlock.type);
            }
            clauseBlock = clauseBlock.nextConnection &&
                clauseBlock.nextConnection.targetBlock();
        }

        this.updateShape_();
        // Reconnect any child blocks.
        this.reconnectChildBlocks_(valueConnections, statementConnections, elseStatementConnection);

    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var clauseBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 1;
        while (clauseBlock) {
            switch (clauseBlock.type) {
                case 'controls_except':
                    var inputIf = this.getInput('IF' + i);
                    var inputDo = this.getInput('DO' + i);
                    clauseBlock.valueConnection_ =
                        inputIf && inputIf.connection.targetConnection;
                    clauseBlock.statementConnection_ =
                        inputDo && inputDo.connection.targetConnection;
                    i++;
                    break;
                case 'controls_finally':
                    var inputDo = this.getInput('ELSE');
                    clauseBlock.statementConnection_ =
                        inputDo && inputDo.connection.targetConnection;
                    break;
                default:
                    throw 'Unknown block type.';
            }
            clauseBlock = clauseBlock.nextConnection &&
                clauseBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Reconstructs the block with all child blocks attached.
     */
    rebuildShape_: function () {
        var valueConnections = [null];
        var statementConnections = [null];
        var elseStatementConnection = null;

        if (this.getInput('ELSE')) {
            elseStatementConnection = this.getInput('ELSE').connection.targetConnection;
        }
        var i = 1;
        while (this.getInput('IF' + i)) {
            var inputIf = this.getInput('IF' + i);
            var inputDo = this.getInput('DO' + i);
            console.log(inputIf.connection.targetConnection);
            valueConnections.push(inputIf.connection.targetConnection);
            statementConnections.push(inputDo.connection.targetConnection);
            i++;
        }
        this.updateShape_();
        this.reconnectChildBlocks_(valueConnections, statementConnections, elseStatementConnection);
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @this Blockly.Block
     * @private
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('ELSE')) {
            this.removeInput('ELSE');
        }
        var i = 1;
        while (this.getInput('IF' + i)) {
            this.removeInput('IF' + i);
            this.removeInput('DO' + i);
            i++;
        }
        // Rebuild block.
        for (var i = 1; i <= this.elseifCount_; i++) {
            this.appendValueInput('IF' + i)
                .setCheck([Number, Boolean])
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_EXCEPT);
            this.appendStatementInput('DO' + i)
                .appendField('');
        }
        if (this.elseCount_) {
            this.appendStatementInput('ELSE')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_FINALLY);
        }
    },
    /**
     * Reconnects child blocks.
     * @param {!Array<?Blockly.RenderedConnection>} valueConnections List of value
     * connectsions for if input.
     * @param {!Array<?Blockly.RenderedConnection>} statementConnections List of
     * statement connections for do input.
     * @param {?Blockly.RenderedConnection} elseStatementConnection Statement
     * connection for else input.
     */
    reconnectChildBlocks_: function (valueConnections, statementConnections,
        elseStatementConnection) {
        for (var i = 1; i <= this.elseifCount_; i++) {
            valueConnections[i] && valueConnections[i].reconnect(this, 'IF' + i);
            statementConnections[i] && statementConnections[i].reconnect(this, 'DO' + i);
        }
        elseStatementConnection && elseStatementConnection.reconnect(this, 'ELSE');
    }
};

const controls_flow_statements = {
    init: function () {
        this.setColour(LOOPS_HUE);
        var dropdown = new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(this.OPERATORS);
        this.appendDummyInput()
            .appendField(dropdown, 'FLOW')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FLOW_STATEMENTS_INPUT_OFLOOP);
        this.setPreviousStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_FLOW_STATEMENTS_TOOLTIP);
        var thisBlock = this;
        this.setTooltip(function () {
            var op = thisBlock.getFieldValue('FLOW');
            var TOOLTIPS = {
                'BREAK': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK,
                'CONTINUE': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE
            };
            return TOOLTIPS[op];
        });
    },
    onchange: function () {
        if (!this.workspace) {
            // Block has been deleted.
            return;
        }
        var legal = false;
        // Is the block nested in a control statement?
        var block = this;
        do {
            if (block.type == 'controls_repeat' ||
                block.type == 'controls_for' ||
                block.type == 'controls_forEach' ||
                block.type == 'controls_repeat_ext' ||
                block.type == 'controls_whileUntil' ||
                block.type == 'do_while') {
                legal = true;
                break;
            }
            block = block.getSurroundParent();
        } while (block);
        if (legal) {
            this.setWarningText(null);
        } else {
            this.setWarningText(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FLOW_STATEMENTS_WARNING);
        }
    }
};


const controls_for = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FOR_INPUT_WITH)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('i'), 'VAR');
        this.appendValueInput('FROM')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FOR_INPUT_FROM);
        this.appendValueInput('TO')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FOR_INPUT_TO);
        this.appendValueInput('STEP')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_STEP);
        this.appendStatementInput('DO')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DO);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        var thisBlock = this;
        this.setTooltip(function () {
            return blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_FOR_TOOLTIP.replace('%1',
                thisBlock.getFieldValue('VAR'));
        });
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const controls_for_range = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FOR_INPUT_WITH)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('i'), 'VAR');
        this.appendValueInput('FROM')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FOR_INPUT_FROM);
        this.appendValueInput('TO')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FOR_INPUT_TO);
        this.appendValueInput('STEP')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_STEP);
        this.appendStatementInput('DO')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DO);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        var thisBlock = this;
        this.setTooltip(function () {
            return blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_FOR_RANGE_TOOLTIP.replace('%1',
                thisBlock.getFieldValue('VAR'));
        });
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};


controls_whileUntil.OPERATORS = [
    [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_WHILEUNTIL_OPERATOR_WHILE, 'WHILE'],
    [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_WHILEUNTIL_OPERATOR_UNTIL, 'UNTIL']
];



controls_flow_statements.OPERATORS = [
    [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK, 'BREAK'],
    [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE, 'CONTINUE']
];



const controls_if_if = {
    /**
     * Mutator block for if container.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_IF_TITLE_IF);
        this.appendStatementInput('STACK');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_IF_TOOLTIP);
        this.contextMenu = false;
    }
};

const controls_if_elseif = {
    /**
     * Mutator bolck for else-if condition.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_ELSEIF_TITLE_ELSEIF);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_ELSEIF_TOOLTIP);
        this.contextMenu = false;
    }
};

const controls_if_else = {
    /**
     * Mutator block for else condition.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_ELSE_TITLE_ELSE);
        this.setPreviousStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_IF_ELSE_TOOLTIP);
        this.contextMenu = false;
    }
};



const controls_try = {
    /**
     * Mutator block for if container.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField('try');
        this.appendStatementInput('STACK');
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.contextMenu = false;
    }
};

const controls_except = {
    /**
     * Mutator bolck for else-if condition.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_EXCEPT);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.contextMenu = false;
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_CONTROL_EXCEPT_TOOLTIP);
    }
};

const controls_finally = {
    /**
     * Mutator block for else condition.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_FINALLY);
        this.setPreviousStatement(true);
        this.contextMenu = false;
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_CONTROL_FINALLY_TOOLTIP);
    }
};



const controls_repeat_ext = {
    /**
     * Block for repeat n times (external number).
     * @this Blockly.Block
     */
    init: function () {
        this.jsonInit({
            "message0": blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_REPEAT_TITLE,
            "args0": [
                {
                    "type": "input_value",
                    "name": "TIMES",
                    // "check": "Number"
                }
            ],
            "previousStatement": null,
            "nextStatement": null,
            "colour": LOOPS_HUE,
            "tooltip": blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_REPEAT_TOOLTIP,
            "helpUrl": blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_REPEAT_HELPURL
        });
        this.appendStatementInput('DO');
    }
};



const controls_lambda = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendValueInput('BOOL')
            .appendField('lambda')
        //.appendField(new Blockly.FieldDropdown(this.OPERATORS), 'MODE');
        this.appendStatementInput('DO')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_STAT);
        this.setOutput(true);
        // this.setNextStatement(true);
    }
};

const controls_pass = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_PASS);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_PASS_TOOLTIP);
    }
};

const controls_thread = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_THREAD_START)
        this.appendValueInput('callback')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_THREAD_USE)
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PARAMS);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_THREAD_TOOLTIP);
    }
};

//do-while循环
const do_while = {
    init: function () {
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_REPEAT_TITLE_REPEAT + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DO);
        this.appendStatementInput("input_data")
            .setCheck(null)
        this.appendValueInput("select_data")
            .setCheck(null)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_OPERATOR_UNTIL)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_WHILEUNTIL_OPERATOR_WHILE, "true"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_WHILEUNTIL_OPERATOR_UNTIL, "false"]]), "type");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(LOOPS_HUE);
        this.setTooltip("do-while loop");
        this.setHelpUrl("");
    }
};

const garbage_collection = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_OP_GARBAGE_COLLECT);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};


const get_mem_alloc = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET_MEM_ALLOC);
        this.setOutput(true)
    }
};

const get_mem_free = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET_MEM_FREE);
        this.setOutput(true)
    }
};

const get_unique_identifier = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DEVICE + 'ID');
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_DEFRETURN_RETURN + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET_UNIQUE_IDEN);
    }
};

// export const base_type = controls_type;
// export const controls_TypeLists = controls_typeLists;

const datetime_fromtimestamp = {
    init: function () {
        this.setColour(LOOPS_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_RTC_TIMESTAMP);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TIMESTAMP_TO_DATA);
        this.setInputsInline(true);
        this.setOutput(true, Number);
    }
};

/***/ }),

/***/ "../python/blocks/dicts.js":
/*!*********************************!*\
  !*** ../python/blocks/dicts.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dicts_add_change_del: () => (/* binding */ dicts_add_change_del),
/* harmony export */   dicts_add_or_change: () => (/* binding */ dicts_add_or_change),
/* harmony export */   dicts_clear: () => (/* binding */ dicts_clear),
/* harmony export */   dicts_create_with: () => (/* binding */ dicts_create_with),
/* harmony export */   dicts_create_with_container: () => (/* binding */ dicts_create_with_container),
/* harmony export */   dicts_create_with_item: () => (/* binding */ dicts_create_with_item),
/* harmony export */   dicts_create_with_noreturn: () => (/* binding */ dicts_create_with_noreturn),
/* harmony export */   dicts_deldict: () => (/* binding */ dicts_deldict),
/* harmony export */   dicts_delete: () => (/* binding */ dicts_delete),
/* harmony export */   dicts_get: () => (/* binding */ dicts_get),
/* harmony export */   dicts_get_default: () => (/* binding */ dicts_get_default),
/* harmony export */   dicts_items: () => (/* binding */ dicts_items),
/* harmony export */   dicts_keys: () => (/* binding */ dicts_keys),
/* harmony export */   dicts_length: () => (/* binding */ dicts_length),
/* harmony export */   dicts_pop: () => (/* binding */ dicts_pop),
/* harmony export */   dicts_setdefault: () => (/* binding */ dicts_setdefault),
/* harmony export */   dicts_to_json: () => (/* binding */ dicts_to_json),
/* harmony export */   dicts_to_to: () => (/* binding */ dicts_to_to),
/* harmony export */   dicts_todict: () => (/* binding */ dicts_todict),
/* harmony export */   dicts_update: () => (/* binding */ dicts_update),
/* harmony export */   dicts_values: () => (/* binding */ dicts_values),
/* harmony export */   json_to_dicts: () => (/* binding */ json_to_dicts)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Visual Blocks Editor
 *
 * Copyright 2012 Google Inc.
 * https://developers.google.com/blockly/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Dictionary blocks for Blockly.
 * @author acbart@vt.edu (Austin Cory Bart)
 */


const DICTS_HUE = 345;

const dicts_create_with = {

    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */

    init: function () {
        this.setColour(DICTS_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('mydict'), 'VAR')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldLabel(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_INPUT_WITH), 'TIP')
        this.itemCount_ = 3;
        this.updateShape_();
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['dicts_create_with_item'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_TOOLTIP);
    },

    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */

    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },

    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */

    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },

    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */

    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('dicts_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('dicts_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },

    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */

    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');

        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }

        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },

    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */

    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },

    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */

    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        }

        var keyNames = [];
        for (var i = 0; this.getInput('ADD' + i); i++) {
            //this.getInput('VALUE' + i).removeField("KEY"+i);
            keyNames.push(this.getFieldValue("KEY" + i))
            this.removeInput('ADD' + i);
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.getField('TIP').setValue(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_EMPTY_TITLE);
        } else {
            this.getField('TIP').setValue(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_INPUT_WITH);
            for (var i = 0; i < this.itemCount_; i++) {
                this.appendValueInput('ADD' + i)
                    .setCheck(null)
                    .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
                    .appendField(
                        new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(
                            keyNames.length > i
                                ? keyNames[i]
                                : (i == 0 ? '"key"' : '"key' + (i + 1) + '"')),
                        'KEY' + i)
                    .appendField(":")
            }
        }
    }, getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};



const dicts_create_with_container = {

    /**
     * Mutator block for list container.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_DICT);
        this.appendStatementInput('STACK');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_CONTAINER_TOOLTIP);
        this.contextMenu = false;
    }
};

const dicts_create_with_item = {
    /**
     * Mutator bolck for adding items.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_ITEM_TITLE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_ITEM_TOOLTIP);
        this.contextMenu = false;
    }
};

const dicts_keys = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICT_KEYS);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_KEYS_TOOLTIP);
        this.setOutput(true, 'List');
    }
};

const dicts_get = {
    init: function () {
        this.setColour(DICTS_HUE);
        // this.appendDummyInput("")

        //     .appendField(Blockly.Msg.DICTS_GET_FROM_DICTS)

        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendValueInput('KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_GET_IN)
        this.appendDummyInput("")
            // .appendField(new Blockly.FieldTextInput('"key"'), 'KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD_VALUE);

        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_GET_TOOLTIP);
    }
};

const dicts_get_default = {
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendValueInput('KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_GET_IN)
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD_VALUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_DEFAULT_VALUE);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_GET_DEFAULT_TOOLTIP);
    }
};

const dicts_add_or_change = {
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
        this.appendValueInput('KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD)
        // .appendField(new Blockly.FieldTextInput('"key"'), 'KEY')
        this.appendDummyInput()
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD_VALUE);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD_OR_CHANGE_TOOLTIP);
    }
};


const dicts_delete = {
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
        this.appendValueInput('KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_DELETE_IN)
        this.appendDummyInput("")
            // .appendField(new Blockly.FieldTextInput('"key"'), 'KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_DELETE_VALUE);

        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_DELETE_TOOLTIP);
    }
};


const dicts_update = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT2')
            .setCheck('Dict')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MAKE_DICT)
        this.appendValueInput('DICT')
            .setCheck('Dict')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICT_UPDATE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MID);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_UPDATE_TOOLTIP);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const dicts_clear = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICT_CLEAR);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CLEAR_TOOLTIP);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const dicts_items = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendDummyInput("")

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICT_ITEMS);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ITEMS_TOOLTIP);
        this.setOutput(true, 'List');
    }
};

const dicts_values = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendDummyInput("")

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICT_VALUES);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_VALUES_TOOLTIP);
        this.setOutput(true, 'List');
    }
};

const dicts_length = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LENGTH)

        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICT_LENGTH_TOOLTIP);
        this.setOutput(true, Number);
    }
};

const dicts_deldict = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendDummyInput("")

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICT_DELDICT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_DEL_TOOLTIP);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const dicts_add_change_del = {
    /**
     * Block for getting sublist.
     * @this Blockly.Block
     */
    init: function () {

        this['MODE'] = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD_OR_CHANGE, 'INSERT'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_DELETE_VAR, 'DELETE']
        ];
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_HELPURL);
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendDummyInput('AT2')
        this.appendValueInput('KEY')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_SOCKET_MAKE)
            // .appendField(new Blockly.FieldTextInput('"key"'), 'KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD_VALUE);
        this.updateAt_(true);
        this.setInputsInline(true);
        this.setOutput(false);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var b = this;
        this.setTooltip(function () {
            var e = b.getFieldValue("WHERE"),
                d = "";
            switch (e) {
                case "INSERT":
                    d = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD_TOOLTIP;
                    break;
                case "DELETE":
                    d = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_DELETE_TOOLTIP;
                    break;
            }
            //if ("FROM_START" == e || "FROM_END" == e) d += "  " + Blockly.Msg.LISTS_INDEX_FROM_START_TOOLTIP.replace("%1", ONE_BASED_INDEXING ? "#1": "#0");
            return d
        })

    },
    /**
     * Create XML to represent whether there are 'AT' inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        var isAt = this.getInput('AT2').type == blockly_core__WEBPACK_IMPORTED_MODULE_0__.INPUT_VALUE;
        container.setAttribute('at2', isAt);
        return container;
    },
    /**
     * Parse XML to restore the 'AT' inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        var isAt = (xmlElement.getAttribute('at2') == 'true');
        this.updateAt_(isAt);
    },
    /**
     * Create or delete an input for a numeric index.
     * This block has two such inputs, independant of each other.
     * @param {number} n Specify first or second input (1 or 2).
     * @param {boolean} isAt True if the input should exist.
     * @private
     * @this Blockly.Block
     */
    updateAt_: function (isAt) {
        // Create or delete an input for the numeric index.
        // Destroy old 'AT' and 'ORDINAL' inputs.
        this.removeInput('AT2');
        this.removeInput('ORDINAL', true);
        // Create either a value 'AT' input or a dummy input.
        if (isAt) {
            this.appendValueInput('AT2').setCheck(Number);
        } else {
            this.appendDummyInput('AT2');
        }
        var menu = new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(this['MODE'],
            function (value) {
                var newAt = (value == 'INSERT');
                // The 'isAt' variable is available due to this function being a
                // closure.
                if (newAt != isAt) {
                    var block = this.sourceBlock_;
                    block.updateAt_(newAt);
                    // This menu has been destroyed and replaced.
                    // Update the replacement.
                    block.setFieldValue(value, 'WHERE');
                    return null;
                }
                return undefined;
            });

        this.getInput('AT2')
            .appendField(menu, 'WHERE');

        // this.moveInputBefore('AT2','LIST');
    }
};

const dicts_pop = {
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_DICT_POP)
        this.appendValueInput('KEY')
        this.appendDummyInput("")
            // .appendField(new Blockly.FieldTextInput('"key"'), 'KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD_VALUE);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICT_POP_TOOLTIP);
        this.setInputsInline(true);
        this.setOutput(true);
    }
};

const dicts_setdefault = {
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict');
        this.appendValueInput('KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_SET_DEFAULT)
        this.appendDummyInput("")
            // .appendField(new Blockly.FieldTextInput('"key"'), 'KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_DEFAULT_VALUE);
        this.appendValueInput('VAR')

        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_SETDEFAULT_TOOLTIP);
    }
};

const dicts_create_with_noreturn = {
    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendDummyInput("")
            //    .appendField(new Blockly.FieldTextInput('mydict'), 'VAR')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldLabel(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_DICT), 'TIP')
            .appendField(' ')
        this.itemCount_ = 3;
        this.updateShape_();
        this.setOutput(true, "Dict")
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['dicts_create_with_item'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_TOOLTIP);
    },

    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */

    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },

    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */

    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },

    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */

    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('dicts_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('dicts_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },

    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */

    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');

        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }

        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },

    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */

    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },

    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */

    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        }

        var keyNames = [];
        for (var i = 0; this.getInput('ADD' + i); i++) {
            //this.getInput('VALUE' + i).removeField("KEY"+i);
            keyNames.push(this.getFieldValue("KEY" + i))
            this.removeInput('ADD' + i);
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.getField('TIP').setValue(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_NULL + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_DICT);
        } else {
            this.getField('TIP').setValue(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_DICT);
            for (var i = 0; i < this.itemCount_; i++) {
                this.appendValueInput('ADD' + i)
                    .setCheck(null)
                    .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
                    .appendField(
                        new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(
                            keyNames.length > i
                                ? keyNames[i]
                                : (i == 0 ? '"key"' : '"key' + (i + 1) + '"')),
                        'KEY' + i)
                    .appendField(":")
            }

        }
    }, getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const dicts_todict = {
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TODICT);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TOOLTIP_TODICT);
    }
};

const dicts_to_json = {
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_JSON);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_JSON_TOOLTIP);
        this.setOutput(true);
    }
};

const json_to_dicts = {
    init: function () {
        this.setColour(DICTS_HUE);
        this.appendValueInput('VAR');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CONVERT_TO_JSON);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CONVERT_TO_JSON_TOOLTIP);
        this.setOutput(true);
    }
};

const dicts_to_to ={
    init:function(){
        this.setColour(DICTS_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict');
        this.appendValueInput('VAR1')
            .appendField('r');
        this.appendValueInput('VAR2')
            .appendField('index');
        this.appendValueInput('VAR3')
            .appendField('l');
        this.appendValueInput('VAR4')
            .appendField('n');
        this.setInputsInline(true)
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CONVERT_TO_JSON_TOOLTIP);
        this.setOutput(true);
    }
}

/***/ }),

/***/ "../python/blocks/html.js":
/*!********************************!*\
  !*** ../python/blocks/html.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   html_content: () => (/* binding */ html_content),
/* harmony export */   html_content_more: () => (/* binding */ html_content_more),
/* harmony export */   html_document: () => (/* binding */ html_document),
/* harmony export */   html_form: () => (/* binding */ html_form),
/* harmony export */   html_head_body: () => (/* binding */ html_head_body),
/* harmony export */   html_style: () => (/* binding */ html_style),
/* harmony export */   html_style_color: () => (/* binding */ html_style_color),
/* harmony export */   html_style_content: () => (/* binding */ html_style_content),
/* harmony export */   html_text: () => (/* binding */ html_text),
/* harmony export */   html_title: () => (/* binding */ html_title)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const HTML_HUE = '#1ec1e4';

const html_document = {
    init: function () {
        this.setColour(HTML_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_DOCUMENT);
        this.appendStatementInput('HEAD')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_HEAD);
        this.appendStatementInput('BODY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_BODY);
        this.setOutput(true);
    }
};

const html_title = {
    init: function () {
        this.setColour(HTML_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_LEVEL)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"], ["5", "5"], ["6", "6"]]), 'LEVEL');
        this.appendStatementInput('DO')
            .appendField('');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const html_head_body = {
    init: function () {
        this.setColour(HTML_HUE);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_HEAD, "head"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_BODY, "body"]
            ]), 'LEVEL');
        this.appendStatementInput('DO')
            .appendField('');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const html_content = {
    init: function () {
        this.setColour(HTML_HUE);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_P, "p"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_SPAN, "span"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_FORM, "form"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_TABLE, "table"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_LINE, "tr"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_CELL, "td"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_OL, "ol"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_UL, "ul"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_LI, "li"]
            ]), 'LEVEL')
        // this.appendValueInput('style')
        //     .appendField(Blockly.Msg.MIXLY_AIP_ATTR)
        //     .setAlign(Blockly.inputs.Align.RIGHT);
        this.appendStatementInput('DO')
            .appendField('');
        this.setInputsInline(false);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const html_content_more = {
    init: function () {
        this.setColour(HTML_HUE);
        this.appendDummyInput()
            .appendField('<')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('tag'), "LEVEL")
            .appendField('>')
        this.appendValueInput('style')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendStatementInput('DO')
            .appendField('');
        this.setInputsInline(false);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const html_style = {
    init: function () {
        this.setColour(HTML_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_STYLE)
        this.appendStatementInput('STYLE');
        this.setOutput(true);
    }
};

const html_form = {
    init: function () {
        this.setColour(HTML_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_FORM_CONTENT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_TEXT, "text"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_EMAIL, "email"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_NUMBER, "number"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_PASSWORD, "password"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_CHECKBOX, "checkbox"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_RADIOBUTTON, "radiobutton"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_BUTTON, "button"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_COLOUR, "colour"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_DATE, "date"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_LOCALTIME, "local time"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_FILE, "file"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_HIDDEN, "hidden"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_IMAGE, "image"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_MONTH, "month"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_RANGE, "range"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_RESET, "reset"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_SEARCH, "search"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_SUBMIT, "submit"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_TELEPHONENUMBER, "telephone number"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_TIME, "time"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_URL, "url"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_WEEK, "week"]
            ]), 'LEVEL')
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_NAME)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('car'), "NAME")
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_VALUE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('go'), "VALUE")
        this.appendValueInput('style')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const html_style_content = {
    init: function () {
        this.setColour(HTML_HUE);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('property'), "KEY")
            .appendField(':')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('value'), "VALUE")
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const html_style_color = {
    init: function () {
        this.setColour(HTML_HUE);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('property'), "KEY")
            .appendField(':')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour("#ff0000"), "RGB_LED_COLOR");
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const html_text = {
    init: function () {
        this.setColour(HTML_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_TEXT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('text'), "TEXT");
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

/***/ }),

/***/ "../python/blocks/lists.js":
/*!*********************************!*\
  !*** ../python/blocks/lists.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ENUMERATE: () => (/* binding */ ENUMERATE),
/* harmony export */   enumerate: () => (/* binding */ enumerate),
/* harmony export */   list_many_input: () => (/* binding */ list_many_input),
/* harmony export */   list_tolist: () => (/* binding */ list_tolist),
/* harmony export */   list_tolist2: () => (/* binding */ list_tolist2),
/* harmony export */   list_trig: () => (/* binding */ list_trig),
/* harmony export */   lists_2d_get_col_row_data: () => (/* binding */ lists_2d_get_col_row_data),
/* harmony export */   lists_2d_get_data_with_col_row: () => (/* binding */ lists_2d_get_data_with_col_row),
/* harmony export */   lists_append_extend: () => (/* binding */ lists_append_extend),
/* harmony export */   lists_change_to: () => (/* binding */ lists_change_to),
/* harmony export */   lists_change_to_general: () => (/* binding */ lists_change_to_general),
/* harmony export */   lists_clear: () => (/* binding */ lists_clear),
/* harmony export */   lists_create_with: () => (/* binding */ lists_create_with),
/* harmony export */   lists_create_with2: () => (/* binding */ lists_create_with2),
/* harmony export */   lists_create_with_container: () => (/* binding */ lists_create_with_container),
/* harmony export */   lists_create_with_item: () => (/* binding */ lists_create_with_item),
/* harmony export */   lists_create_with_noreturn: () => (/* binding */ lists_create_with_noreturn),
/* harmony export */   lists_create_with_text: () => (/* binding */ lists_create_with_text),
/* harmony export */   lists_create_with_text2: () => (/* binding */ lists_create_with_text2),
/* harmony export */   lists_del_general: () => (/* binding */ lists_del_general),
/* harmony export */   lists_find: () => (/* binding */ lists_find),
/* harmony export */   lists_getIndex3: () => (/* binding */ lists_getIndex3),
/* harmony export */   lists_getSublist3: () => (/* binding */ lists_getSublist3),
/* harmony export */   lists_get_index: () => (/* binding */ lists_get_index),
/* harmony export */   lists_get_random_item: () => (/* binding */ lists_get_random_item),
/* harmony export */   lists_get_random_sublist: () => (/* binding */ lists_get_random_sublist),
/* harmony export */   lists_get_sublist: () => (/* binding */ lists_get_sublist),
/* harmony export */   lists_insert_value: () => (/* binding */ lists_insert_value),
/* harmony export */   lists_insert_value2: () => (/* binding */ lists_insert_value2),
/* harmony export */   lists_pop: () => (/* binding */ lists_pop),
/* harmony export */   lists_remove_at: () => (/* binding */ lists_remove_at),
/* harmony export */   lists_remove_at2: () => (/* binding */ lists_remove_at2),
/* harmony export */   lists_reverse: () => (/* binding */ lists_reverse),
/* harmony export */   lists_setIndex3: () => (/* binding */ lists_setIndex3),
/* harmony export */   lists_set_index: () => (/* binding */ lists_set_index),
/* harmony export */   lists_sort: () => (/* binding */ lists_sort)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const LISTS_HUE = 260; //'#70b234'//260;

const lists_get_index = {
    init: function () {
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_HELPURL);
        this.setColour(LISTS_HUE);
        this.appendValueInput("LIST")
        this.appendValueInput("AT")
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_START)
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT_TAIL);
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FROM);
    }
}


const lists_get_sublist = {
    /**
     * Block for getting sublist.
     * @this Blockly.Block
     */
    init: function () {
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_HELPURL);
        this.setColour(LISTS_HUE);
        this.appendValueInput('LIST')
        this.appendDummyInput('')
        this.appendValueInput('AT1')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_START);
        this.appendValueInput('AT2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT_TAIL + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_END_FROM_START);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT_TAIL);
        this.setInputsInline(true);
        this.setOutput(true, 'List');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYTHON_LISTS_GET_SUBLIST_TOOLTIP);
    }
}

const lists_2d_get_data_with_col_row = {
    init: function () {
        this.appendValueInput("LIST")
            .setCheck(null);
        this.appendValueInput("row")
            .setCheck(null)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATAFRAME_RAW);
        this.appendValueInput("col")
            .setCheck(null)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATAFRAME_COLUMN);
        this.setInputsInline(true);
        this.setOutput(true, null);
        this.setColour(LISTS_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

const lists_2d_get_col_row_data = {
    init: function () {
        this.appendValueInput("LIST")
            .setCheck(null);
        this.appendValueInput("row_start")
            .setCheck(null)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATAFRAME_RAW + " [");
        this.appendValueInput("row_end")
            .setCheck(null)
            .appendField(",");
        this.appendValueInput("col_start")
            .setCheck(null)
            .appendField(")  " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATAFRAME_COLUMN + " [");
        this.appendValueInput("col_end")
            .setCheck(null)
            .appendField(",");
        this.appendDummyInput()
            .appendField(") " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD_VALUE);
        this.setInputsInline(true);
        this.setOutput(true, 'List');
        this.setColour(LISTS_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

const lists_create_with = {
    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendDummyInput("")
            //don't need to specify the data type in Python
            // .appendField(new Blockly.FieldDropdown([[Blockly.Msg.MIXLY_NUMBER, 'Array<number>'], [Blockly.Msg.LANG_MATH_STRING, 'Array<string>'], [Blockly.Msg.LANG_MATH_BOOLEAN, 'Array<boolean>']]), 'TYPE')
            // .appendField(' ')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('mylist'), 'VAR')
            .appendField('[')
            //.appendField(new Blockly.FieldTextInput('3',Blockly.FieldTextInput.math_number_validator), 'SIZE')
            .appendField(']');
        this.itemCount_ = 3;
        this.updateShape_();
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['lists_create_with_item'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_WITH_PYTHON_TOOLTIP);
    },
    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('lists_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('lists_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ADD' + i)) {
                this.removeInput('ADD' + i);
                i++;
            }
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_PYTHON_EMPTY_TITLE);
        } else {
            for (var i = 0; i < this.itemCount_; i++) {
                var input = this.appendValueInput('ADD' + i);
                if (i == 0) {
                    input.appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_LISTS_CREATE_WITH_INPUT_WITH);
                }
            }
        }
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};


const lists_create_with_text = {
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendDummyInput("")
            //don't need to specify the data type in Python
            // .appendField(new Blockly.FieldDropdown([[Blockly.Msg.MIXLY_NUMBER, 'Array<number>']]), 'TYPE')
            // .appendField(' ')
            // .appendField(Blockly.Msg.blockpy_MIXLY_SPLITBYDOU)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('mylist'), 'VAR')
            //.appendField(new Blockly.FieldTextInput('3',Blockly.FieldTextInput.math_number_validator), 'SIZE')
            // .appendField(Blockly.Msg.MIXLY_MAKELISTFROM)
            // .appendField(this.newQuote_(true))
            .appendField(' = [')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('0,0,0'), 'TEXT')
            .appendField(']');
        // .appendField(this.newQuote_(false))
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_LISTS_CREATE_WITH_TEXT2);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
}


const lists_create_with_container = {
    /**
     * Mutator block for list container.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_LIST);
        this.appendStatementInput('STACK');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_WITH_CONTAINER_TOOLTIP);
        this.contextMenu = false;
    }
};

const lists_create_with_item = {
    /**
     * Mutator bolck for adding items.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_WITH_ITEM_TITLE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_WITH_ITEM_TOOLTIP);
        this.contextMenu = false;
    }
};


const lists_set_index = {
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendValueInput('LIST');
        this.appendValueInput('AT')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_LIST_ASSIGN_AT);
        this.appendValueInput('TO')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_LIST_VALUE);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_LISTS_SET_INDEX_TOOLTIP);
    }
};

const lists_append_extend = {
    init: function () {
        this.setColour(LISTS_HUE);
        this['TYPE'] = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_blockpy_set_add, 'append'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_LIST_EXTEND, 'extend']
        ];

        this.appendValueInput('LIST')
            .setCheck('List')
        this.appendValueInput('DATA')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(this['TYPE']), 'OP')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_LIST_A_ITEM)
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_LIST_TO_END);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'append': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_LIST_APPEND,
                'extend': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_EXTEND_TOOLTIP

            };
            return TOOLTIPS[mode];
        });
    }

};

const lists_get_random_item = {
    /**
     * Block for get a random item from list.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendValueInput("LIST");
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_RANDOM)
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TOOLTIP_GET_RANDOM);
        this.setOutput(true);
    }
};

const lists_get_random_sublist = {
    /**
     * Block for get a random item from list.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendValueInput("LIST");
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_RANDOM)
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_LISTS_GET_INDEX2 + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_RANDOM_SUBLIST)
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_RANDOM_SUBLIST_TOOLTIP);
        this.setOutput(true, 'List');
    }
};

const lists_insert_value = {
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendValueInput('LIST');
        this.appendValueInput('AT')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_LIST_INSERT_AT);
        this.appendValueInput('VALUE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_LIST_VALUE);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_LISTS_SET_INDEX_TOOLTIP);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT);
    }
};

const lists_reverse = {
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendValueInput('VAR')
            .setCheck('List') //this.appendDummyInput("")
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_LIST_REVERSE)
        //.appendField(new Blockly.FieldTextInput('mylist'), 'VAR');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_LISTS_CLEAR_TOOLTIP);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};
const lists_clear = {
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendValueInput('VAR')
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_CLEAR)
        //.appendField(new Blockly.FieldTextInput('mylist'), 'VAR');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_LISTS_REVERSE_TOOLTIP);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};


const lists_remove_at = {
    init: function () {
        this.setColour(LISTS_HUE);
        this['TYPE'] = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SERIES_INDEX, 'del'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_I2C_VALUE, 'remove']
        ];
        this.appendValueInput('LIST')
            .setCheck('List')
        this.appendValueInput('DATA')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_LISTS_REMOVE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(this['TYPE']), 'OP')
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'del': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SET_INDEX_TOOLTIP_DELETE,
                'remove': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_LIST_REMOVE
            };
            return TOOLTIPS[mode];
        });
    }
};
const lists_pop = {
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendValueInput('LIST');
        this.appendValueInput('VALUE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_LIST_POP);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT_TAIL);
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM);
    }
};

const lists_find = {
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LIST_INDEX, 'INDEX'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LIST_COUNT, 'COUNT']
        ];
        this.setColour(LISTS_HUE);
        this.appendValueInput('VAR')
            .setCheck('List')
        this.appendValueInput('data')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_VALUE)
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        //.appendField(new Blockly.FieldTextInput('mylist'), 'VAR')
        this.setInputsInline(true);
        this.setOutput(true, Number);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'INDEX': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_LIST_FIND_INDEX,
                'COUNT': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_LIST_FIND_COUNT

            };
            return TOOLTIPS[mode];
        });
    }
};
const list_trig = {
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LIST_LEN, 'LEN'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_SUM, 'SUM'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_MAX, 'MAX'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_MIN, 'MIN'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_AVERAGE, 'AVERAGE'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_MEDIAN, 'MEDIAN'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_MODE, 'MODE'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_STD_DEV, 'STD_DEV'],
        ];
        //this.setHelpUrl(Blockly.Msg.MATH_TRIG_HELPURL);
        this.setColour(LISTS_HUE);
        this.setOutput(true, Number);
        this.appendValueInput('data')
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        this.setInputsInline(true);
        // Assign 'this' to a variable for use in the tooltip closure below.
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'LEN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_LENGTH_TOOLTIP,
                'SUM': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_SUM,
                'MAX': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_MAX,
                'MIN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_MIN,
                'AVERAGE': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_AVERAGE,
                'MEDIAN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_MEDIAN,
                'MODE': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_MODE,
                'STD_DEV': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_STD_DEV

            };
            return TOOLTIPS[mode];
        });
    }
};

const lists_sort = {
    /**
     * Block for sorting a list.
     * @this Blockly.Block
     */
    init: function () {
        this.jsonInit({
            "args0": [
                {
                    "type": "input_value",
                    "name": "LIST",
                    "check": "List"
                },
                {
                    "type": "field_dropdown",
                    "name": "TYPE",
                    "options": [
                        [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SORT_TYPE_NUMERIC, "NUMERIC"],
                        [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SORT_TYPE_TEXT, "TEXT"],
                        [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SORT_TYPE_IGNORECASE, "IGNORE_CASE"]
                    ]
                },
                {
                    "type": "field_dropdown",
                    "name": "DIRECTION",
                    "options": [
                        [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SORT_ORDER_ASCENDING, "1"],
                        [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SORT_ORDER_DESCENDING, "-1"]
                    ]
                },
            ],
            "message0": blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SORT_TITLE,
            "inputsInline": true,
            "output": "List",
            "colour": LISTS_HUE,
            "tooltip": blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SORT_TOOLTIP,
            "helpUrl": blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SORT_HELPURL
        });
    }
};

const lists_change_to = {
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_TUPLE, 'tuple'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_CONTAINER_TITLE_ADD, 'set'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_WITH_CONTAINER_TITLE_ADD, 'array']
        ];
        this.setColour(LISTS_HUE);
        this.appendValueInput('VAR')
            .setCheck("List")
        // .appendField(Blockly.Msg.blockpy_USE_LIST);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.A_TO_B)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'tuple': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_CONVERT_LIST_TO_TUPLE,
                'set': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_CONVERT_LIST_TO_SET,
                'array': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_CONVERT_LIST_TO_ARRAY
            };
            return TOOLTIPS[mode];
        });

        this.setInputsInline(true);
        this.setOutput(true);
    }
};

const list_many_input = {
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendDummyInput("")
            .appendField('[')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('0,0,0'), "CONTENT")
            .appendField(']');
        this.setInputsInline(true);
        this.setOutput(true);
    }
};

const lists_create_with_noreturn = {
    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LISTS_HUE);
        this.itemCount_ = 3;
        this.updateShape_();
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, "List")
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['lists_create_with_item'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_WITH_PYTHON_TOOLTIP);
    },
    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('lists_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('lists_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ADD' + i)) {
                this.removeInput('ADD' + i);
                i++;
            }
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_PYTHON_EMPTY_TITLE);
        } else {
            for (var i = 0; i < this.itemCount_; i++) {
                var input = this.appendValueInput('ADD' + i);
                if (i == 0) {
                    input.appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_LISTS_CREATE_WITH_INPUT_WITH);
                }
            }
        }
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
}

const lists_change_to_general = {
    init: function () {
        var OPERATORS =
            [
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_LIST, 'list'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_TUPLE, 'tuple'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_CONTAINER_TITLE_ADD, 'set']
            ];
        this.setColour(LISTS_HUE);
        this.appendValueInput('VAR');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.A_TO_B)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');

        this.setInputsInline(true);
        this.setOutput(true);
    }
};

const lists_del_general = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendValueInput('TUP')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.OBJECT_DELETE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const list_tolist = {
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOLIST);
        this.setOutput(true, 'List');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TOOLTIP_TOLIST);
    }
};

const lists_create_with2 = lists_create_with
const lists_create_with_text2 = lists_create_with_text
const lists_getIndex3 = lists_get_index
const lists_getSublist3 = lists_get_sublist
const lists_setIndex3 = lists_set_index
const lists_insert_value2 = lists_insert_value
const lists_remove_at2 = lists_remove_at
const list_tolist2 = list_tolist;


const ENUMERATE ={
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_USE_LIST);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_INDEX_SEQUENCE);
        // this.appendValueInput('VAR_N')
        //     .appendField(Blockly.Msg.MIXLY_INDEX+Blockly.Msg.MIXLY_STARTSWITH);
        this.setInputsInline(true);
        this.setOutput(true, Number);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOTO_INDEX_SEQUENC_TOOLTIP);
    }
};

const enumerate = {
    init: function () {
        this.setColour(LISTS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_USE_LIST);
        this.appendValueInput('LIST');
        this.appendValueInput('VALUE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_INDEX_SEQUENCE)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_INDEX+blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_STARTSWITH);
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOTO_INDEX_SEQUENC_TOOLTIP);
    }
};

/***/ }),

/***/ "../python/blocks/logic.js":
/*!*********************************!*\
  !*** ../python/blocks/logic.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logic_boolean: () => (/* binding */ logic_boolean),
/* harmony export */   logic_compare: () => (/* binding */ logic_compare),
/* harmony export */   logic_compare_continous: () => (/* binding */ logic_compare_continous),
/* harmony export */   logic_is: () => (/* binding */ logic_is),
/* harmony export */   logic_is_in: () => (/* binding */ logic_is_in),
/* harmony export */   logic_negate: () => (/* binding */ logic_negate),
/* harmony export */   logic_null: () => (/* binding */ logic_null),
/* harmony export */   logic_operation: () => (/* binding */ logic_operation),
/* harmony export */   logic_tobool: () => (/* binding */ logic_tobool),
/* harmony export */   logic_true_or_false: () => (/* binding */ logic_true_or_false)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const LOGIC_HUE = 210;

const logic_compare = {
    /**
     * Block for comparison operator.
     * @this Blockly.Block
     */
    init: function () {
        var OPERATORS = blockly_core__WEBPACK_IMPORTED_MODULE_0__.RTL ? [
            ['=', 'EQ'],
            ['\u2260', 'NEQ'],
            ['>', 'LT'],
            ['\u2265', 'LTE'],
            ['<', 'GT'],
            ['\u2264', 'GTE']
        ] : [
            ['=', 'EQ'],
            ['\u2260', 'NEQ'],
            ['<', 'LT'],
            ['\u2264', 'LTE'],
            ['>', 'GT'],
            ['\u2265', 'GTE']
        ];
        //this.setHelpUrl(Blockly.Msg.LOGIC_COMPARE_HELPURL);
        this.setColour(LOGIC_HUE);
        this.setOutput(true, Boolean);
        this.appendValueInput('A');
        this.appendValueInput('B')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        this.setInputsInline(true);
        // Assign 'this' to a variable for use in the tooltip closure below.
        var thisBlock = this;
        this.setTooltip(function () {
            var op = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'EQ': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_COMPARE_TOOLTIP_EQ,
                'NEQ': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_COMPARE_TOOLTIP_NEQ,
                'LT': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_COMPARE_TOOLTIP_LT,
                'LTE': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_COMPARE_TOOLTIP_LTE,
                'GT': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_COMPARE_TOOLTIP_GT,
                'GTE': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_COMPARE_TOOLTIP_GTE
            };
            return TOOLTIPS[op];
        });
        this.prevBlocks_ = [null, null];
    },
    /**
     * Called whenever anything on the workspace changes.
     * Prevent mismatched types from being compared.
     * @this Blockly.Block
     */
    /*onchange: function(e) {
      var blockA = this.getInputTargetBlock('A');
      var blockB = this.getInputTargetBlock('B');
      // Disconnect blocks that existed prior to this change if they don't match.
      if (blockA && blockB &&
          !blockA.outputConnection.checkType_(blockB.outputConnection)) {
        // Mismatch between two inputs.  Disconnect previous and bump it away.
        // Ensure that any disconnections are grouped with the causing event.
        Blockly.Events.setGroup(e.group);
        for (var i = 0; i < this.prevBlocks_.length; i++) {
          var block = this.prevBlocks_[i];
          if (block === blockA || block === blockB) {
            block.unplug();
            block.bumpNeighbours_();
          }
        }
        Blockly.Events.setGroup(false);
      }
      this.prevBlocks_[0] = blockA;
      this.prevBlocks_[1] = blockB;
    }*/
};

const logic_compare_continous = {

    init: function () {
        var OPERATORS1 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.RTL ? [
            ['>', 'LT'],
            ['\u2265', 'LTE'],
            ['<', 'GT'],
            ['\u2264', 'GTE']
        ] : [
            ['<', 'LT'],
            ['\u2264', 'LTE'],
            ['>', 'GT'],
            ['\u2265', 'GTE']
        ];
        var OPERATORS2 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.RTL ? [
            ['>', 'LT'],
            ['\u2265', 'LTE'],
            ['<', 'GT'],
            ['\u2264', 'GTE']
        ] : [
            ['<', 'LT'],
            ['\u2264', 'LTE'],
            ['>', 'GT'],
            ['\u2265', 'GTE']
        ];
        //this.setHelpUrl(Blockly.Msg.LOGIC_COMPARE_HELPURL);
        this.setColour(LOGIC_HUE);
        this.setOutput(true, Boolean);
        this.appendValueInput('A');
        this.appendValueInput('B')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS1), 'OP1');
        this.appendValueInput('C')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS2), 'OP2');
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LOGIC_COMPARE_CONTINOUS_TOOLTIP);

    }
};

const logic_operation = {
    /**
     * Block for logical operations: 'and', 'or'.
     * @this Blockly.Block
     */
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_OPERATION_AND, 'AND'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_OPERATION_OR, 'OR'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_OPERATION_NOR, 'NOR'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_OPERATION_XOR, 'XOR']
        ];
        //this.setHelpUrl(Blockly.Msg.LOGIC_OPERATION_HELPURL);
        this.setColour(LOGIC_HUE);
        this.setOutput(true, Boolean);
        this.appendValueInput('A')
            .setCheck([Boolean, Number]);
        this.appendValueInput('B')
            .setCheck([Boolean, Number])
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        this.setInputsInline(true);
        // Assign 'this' to a variable for use in the tooltip closure below.
        var thisBlock = this;
        this.setTooltip(function () {
            var op = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'AND': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_OPERATION_TOOLTIP_AND,
                'OR': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_OPERATION_TOOLTIP_OR,
                'NOR': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_OPERATION_TOOLTIP_NOR,
                'XOR': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_OPERATION_TOOLTIP_XOR
            };
            return TOOLTIPS[op];
        });
    }
};

const logic_negate = {
    /**
     * Block for negation.
     * @this Blockly.Block
     */
    init: function () {
        //this.setHelpUrl(Blockly.Msg.LOGIC_NEGATE_HELPURL);
        this.setColour(LOGIC_HUE);
        this.setOutput(true, Boolean);
        this.appendValueInput('BOOL')
            .setCheck([Number, Boolean])
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_NEGATE_TITLE);
        //this.interpolateMsg(Blockly.Msg.LOGIC_NEGATE_TITLE,
        //                  ['BOOL', Boolean, Blockly.inputs.Align.RIGHT],
        //                Blockly.inputs.Align.RIGHT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_NEGATE_TOOLTIP);
    }
};

const logic_boolean = {
    /**
     * Block for boolean data type: true and false.
     * @this Blockly.Block
     */
    init: function () {
        var BOOLEANS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_BOOLEAN_TRUE, 'TRUE'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_BOOLEAN_FALSE, 'FALSE']
        ];
        //this.setHelpUrl(Blockly.Msg.LOGIC_BOOLEAN_HELPURL);
        this.setColour(LOGIC_HUE);
        this.setOutput(true, Boolean);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(BOOLEANS), 'BOOL');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_BOOLEAN_TOOLTIP);
    }
};

const logic_null = {
    /**
     * Block for null data type.
     * @this Blockly.Block
     */
    init: function () {
        //this.setHelpUrl(Blockly.Msg.LOGIC_NULL_HELPURL);
        this.setColour(LOGIC_HUE);
        this.setOutput(true);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_NULL);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_NULL_TOOLTIP);
    }
};

const logic_true_or_false = {
    init: function () {
        this.setColour(LOGIC_HUE);
        this.appendValueInput('A');
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_TERNARY_IF_TRUE);
        this.appendValueInput('C')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_TERNARY_IF_FALSE);
        this.setOutput(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_LOGIT_TRUEORFALSE);
    }
};

const logic_is_in = {
    init: function () {
        var BOOLEANS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_APPEND_TO, 'in'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LOGIC_IS_NOT_IN, 'not in']
        ];
        this.setColour(LOGIC_HUE);
        this.appendValueInput('A');
        this.appendValueInput('B')
            .setCheck([String, 'List'])
            //.appendField(Blockly.Msg.TEXT_APPEND_TO)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(BOOLEANS), 'BOOL');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MICROBIT_LOGIC_IS_IN);
        this.setOutput(true, Boolean);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.IN);
    }
};

const logic_is = {
    init: function () {
        var BOOLEANS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LOGIC_IS, 'is'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LOGIC_IS_NOT, 'is not']
        ];
        this.setColour(LOGIC_HUE);
        this.appendValueInput('A');
        this.appendValueInput('B')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(BOOLEANS), 'BOOL');
        //.appendField(Blockly.Msg.MIXLY_PYTHON_LOGIC_IS);
        this.setOutput(true, Boolean);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LOGIC_IS_TOOLTIP);
    }
};

const logic_tobool = {
    init: function () {
        this.setColour(LOGIC_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOBOOL);
        this.setOutput(true, Boolean);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TOOLTIP_TOBOOL);
    }
};

/***/ }),

/***/ "../python/blocks/math.js":
/*!********************************!*\
  !*** ../python/blocks/math.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base_map: () => (/* binding */ base_map),
/* harmony export */   generate_cartesian_product: () => (/* binding */ generate_cartesian_product),
/* harmony export */   math_arithmetic: () => (/* binding */ math_arithmetic),
/* harmony export */   math_bit: () => (/* binding */ math_bit),
/* harmony export */   math_constant: () => (/* binding */ math_constant),
/* harmony export */   math_constant_mp: () => (/* binding */ math_constant_mp),
/* harmony export */   math_constrain: () => (/* binding */ math_constrain),
/* harmony export */   math_dec: () => (/* binding */ math_dec),
/* harmony export */   math_indexer_number: () => (/* binding */ math_indexer_number),
/* harmony export */   math_map: () => (/* binding */ math_map),
/* harmony export */   math_max_min: () => (/* binding */ math_max_min),
/* harmony export */   math_number: () => (/* binding */ math_number),
/* harmony export */   math_number_base_conversion: () => (/* binding */ math_number_base_conversion),
/* harmony export */   math_random: () => (/* binding */ math_random),
/* harmony export */   math_random_seed: () => (/* binding */ math_random_seed),
/* harmony export */   math_round: () => (/* binding */ math_round),
/* harmony export */   math_selfcalcu: () => (/* binding */ math_selfcalcu),
/* harmony export */   math_to_int: () => (/* binding */ math_to_int),
/* harmony export */   math_trig: () => (/* binding */ math_trig),
/* harmony export */   text_to_number: () => (/* binding */ text_to_number),
/* harmony export */   text_to_number_skulpt: () => (/* binding */ text_to_number_skulpt),
/* harmony export */   turn_to_int: () => (/* binding */ turn_to_int)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const MATH_HUE = 230; //'#e49f16';

blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput.math_number_validator = function (text) {
    //return window.isNaN(text) ? null : String(text);
    // var pattern = /^-?(0X|0x|0O|0o|0B|0b)?[a-fA-F0-9]{1,}(\.[a-fA-F0-9]+)?$/;
    // return pattern.test(text) ? String(text) : null;//校验，二 八 十 十六进制匹配
    return String(text);//不再校验
};

blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput.math_number_validator_include_blank = function (text) {
    if (text === "") {
        return "";
    }
    var pattern = /^-?(0X|0x|0O|0o|0B|0b)?[a-fA-F0-9]{1,}(\.[a-fA-F0-9]+)?$/;
    return pattern.test(text) ? String(text) : null;//校验，二 八 十 十六进制匹配
};

const math_number = {
    /**
     * Block for numeric value.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(MATH_HUE);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('0',
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput.math_number_validator), 'NUM');
        this.setOutput(true, Number);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_NUMBER_TOOLTIP);
    }
};

const math_constant = {
    init: function () {
        this.setColour(MATH_HUE);
        var constant =
            [['π', 'pi'], ['e', 'e']];
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_MATH_CONSTANT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(constant), 'CONSTANT')

        this.setOutput(true, Number);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('CONSTANT');
            var TOOLTIPS = {
                'pi': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_MATH_CONSTANT_PI_TOOLTIP,
                'e': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_MATH_CONSTANT_E_TOOLTIP
            };
            return TOOLTIPS[mode];
        });

    }
};

const math_constant_mp = {
    init: function () {
        this.setColour(MATH_HUE);
        var constant =
            [['π', 'pi'], ['e', 'e']];
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_MATH_CONSTANT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(constant), 'CONSTANT')

        this.setOutput(true, Number);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('CONSTANT');
            var TOOLTIPS = {
                'pi': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_MATH_CONSTANT_PI_MP_TOOLTIP,
                'e': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_MATH_CONSTANT_E_MP_TOOLTIP
            };
            return TOOLTIPS[mode];
        });

    }
};

const math_arithmetic = {
    /**
     * Block for basic arithmetic operator.
     * @this Blockly.Block
     */
    init: function () {
        var OPERATORS = [
            ['+', 'ADD'],
            ['-', 'MINUS'],
            ['×', 'MULTIPLY'],
            ['÷', 'DIVIDE'],
            ['%', 'QUYU'],
            ['//', 'ZHENGCHU'],
            ['**', 'POWER']
        ];
        //this.setHelpUrl(Blockly.Msg.MATH_ARITHMETIC_HELPURL);
        this.setColour(MATH_HUE);
        this.setOutput(true);
        this.appendValueInput('A')
        this.appendValueInput('B')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        this.setInputsInline(true);
        // Assign 'this' to a variable for use in the tooltip closure below.
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'ADD': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_ADD,
                'MINUS': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_MINUS,
                'MULTIPLY': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_MULTIPLY,
                'DIVIDE': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_DIVIDE,
                'QUYU': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_MODULO_TOOLTIP,
                'ZHENGCHU': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_DIVIDE,
                'POWER': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_POWER
            };
            return TOOLTIPS[mode];
        });
    }
};

const math_selfcalcu = {
    /**
     * Block for basic arithmetic operator.
     * @this Blockly.Block
     */
    init: function () {
        var OPERATORS = [
            ['+=', 'ADD'],
            ['-=', 'MINUS'],
            ['×=', 'MULTIPLY'],
            ['÷=', 'DIVIDE'],
            ['%=', 'QUYU'],
            ['//=', 'ZHENGCHU'],
            ['**=', 'POWER']
        ];

        this.setColour(MATH_HUE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.appendValueInput('A')
        this.appendValueInput('B')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        this.setInputsInline(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'ADD': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_ADD,
                'MINUS': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_MINUS,
                'MULTIPLY': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_MULTIPLY,
                'DIVIDE': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_DIVIDE,
                'QUYU': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_MODULO_TOOLTIP,
                'ZHENGCHU': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_DIVIDE,
                'POWER': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ARITHMETIC_TOOLTIP_POWER
            };
            return TOOLTIPS[mode];
        });
    }
};

const math_bit = {
    init: function () {
        var OPERATORS = [
            ['&', '&'],
            ['|', '|'],
            ['>>', '>>'],
            ['<<', '<<']
        ];
        this.setColour(MATH_HUE);
        this.setOutput(true, Number);
        this.appendValueInput('A')
            .setCheck(Number);
        this.appendValueInput('B')
            .setCheck(Number)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        this.setInputsInline(true);
        this.setTooltip("位运算");
    }
};

const math_trig = {
    /**
     * Block for trigonometry operators.
     * @this Blockly.Block
     */
    init: function () {
        var OPERATORS = [
            ['sin', 'SIN'],
            ['cos', 'COS'],
            ['tan', 'TAN'],
            ['asin', 'ASIN'],
            ['acos', 'ACOS'],
            ['atan', 'ATAN'],
            ['-', '-'],
            ['ln', 'LN'],
            ['log10', 'LOG10'],
            ['e^', 'EXP'],
            ['10^', 'POW10']
        ];
        //this.setHelpUrl(Blockly.Msg.MATH_TRIG_HELPURL);
        this.setColour(MATH_HUE);
        this.setOutput(true, Number);
        this.appendValueInput('NUM')
            .setCheck(Number)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        // Assign 'this' to a variable for use in the tooltip closure below.
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'SIN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_TRIG_TOOLTIP_SIN,
                'COS': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_TRIG_TOOLTIP_COS,
                'TAN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_TRIG_TOOLTIP_TAN,
                'ASIN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_TRIG_TOOLTIP_ASIN,
                'ACOS': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_TRIG_TOOLTIP_ACOS,
                'ATAN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_TRIG_TOOLTIP_ATAN,
                'LN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_SINGLE_TOOLTIP_LN
            };
            return TOOLTIPS[mode];
        });
    }
};

const math_dec = {
    /**
     * Block for trigonometry operators.
     * @this Blockly.Block
     */
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_BIN, 'bin'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_OCT, 'oct'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_HEX, 'hex'],
        ];
        //this.setHelpUrl(Blockly.Msg.MATH_TRIG_HELPURL);
        this.setColour(MATH_HUE);
        this.setOutput(true, String);
        this.appendValueInput('NUM')
            .setCheck(Number)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        // Assign 'this' to a variable for use in the tooltip closure below.
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'bin': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_DEC_TOOLTIP_BIN,
                'oct': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_DEC_TOOLTIP_OCT,
                'hex': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_DEC_TOOLTIP_HEX,

            };
            return TOOLTIPS[mode];
        });
    }
};

//取整等
const math_to_int = {
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_TO_ROUND, 'round'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_TO_CEIL, 'ceil'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_TO_FLOOR, 'floor'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ABS, 'fabs'],
            // [Blockly.Msg.MATH_SQ, 'pow'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_SQRT, 'sqrt']
        ];
        this.setColour(MATH_HUE);
        this.appendValueInput('A')
            .setCheck(Number)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        this.setOutput(true, Number);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'sqrt': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_SINGLE_TOOLTIP_ROOT,
                'fabs': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_SINGLE_TOOLTIP_ABS,
                'sq': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_SINGLE_TOOLTIP_SQ,
                'round': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_SINGLE_TOOLTIP_ROUND,
                'ceil': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_SINGLE_TOOLTIP_CEIL,
                'floor': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_SINGLE_TOOLTIP_FLOOR
            };
            return TOOLTIPS[mode];
        });
    }
};
//最大最小值
const math_max_min = {
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MAX, 'max'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIN, 'min'],
        ];

        this.setColour(MATH_HUE);
        this.appendValueInput('A')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP')
            .appendField('(');
        this.appendValueInput('B')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(',');
        this.appendDummyInput('')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(')');
        this.setInputsInline(true);
        this.setOutput(true, Number);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'max': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_MATH_MAX,
                'min': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_MATH_MIN
            };
            return TOOLTIPS[mode];
        });
    }
};

const math_number_base_conversion = {
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_TWO, 'two'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_EIGHT, 'eight'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_TEN, 'ten'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_SIXTEEN, 'sixteen']
        ];
        this.setColour(MATH_HUE);
        this.appendDummyInput('')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_BA)
        this.appendValueInput("NUM")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_JinZhi)
            .setCheck(Number);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ZHW)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_JinZhi);
        this.setFieldValue('ten', 'OP2')
        // this.setPreviousStatement(true, null);
        // this.setNextStatement(true, null);
        this.setOutput(true)
        this.setInputsInline(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'two': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_Before_two,
                'eight': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_Before_eight,
                'ten': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_Before_ten,
                'sixteen': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_Before_sixteen,
            };
            var mode2 = thisBlock.getFieldValue('OP2');
            var TOOLTIPS2 = {
                'two': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_Behind_two,
                'eight': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_Behind_eight,
                'ten': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_Behind_ten,
                'sixteen': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_Behind_sixteen,
            };
            return TOOLTIPS[mode] + TOOLTIPS2[mode2];
        });
    }
};


const math_random = {
    init: function () {
        var INT_FLOAT = [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_INT, 'int'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_FLOAT, 'float']];
        this.setColour(MATH_HUE);
        this.setOutput(true, Number);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_RANDOM)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(INT_FLOAT), 'TYPE');
        this.appendValueInput('FROM')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_CONTROLS_FOR_INPUT_FROM);
        this.appendValueInput('TO')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_RANDOM_INT_INPUT_TO);
        this.setInputsInline(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('TYPE');
            var TOOLTIPS = {
                'int': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_INT,
                'float': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_FLOAT_RANDOM
            };
            return blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_RANDOM_INT_TOOLTIP + TOOLTIPS[mode];
        });
    }
};


const math_constrain = {
    /**
     * Block for constraining a number between two limits.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(MATH_HUE);
        this.setOutput(true, Number);
        this.appendValueInput('VALUE')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_CONSTRAIN_INPUT_CONSTRAIN);
        this.appendValueInput('LOW')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_CONSTRAIN_INPUT_LOW);
        this.appendValueInput('HIGH')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_CONSTRAIN_INPUT_HIGH);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_CONSTRAIN_TOOLTIP);
    }
};

const math_map = {
    init: function () {
        this.setColour(MATH_HUE);
        this.appendValueInput("NUM", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MAP)
            .setCheck(Number);
        this.appendValueInput("fromLow", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MAP_FROM)
            .setCheck(Number);
        this.appendValueInput("fromHigh", Number)
            .appendField(",")
            .setCheck(Number);
        this.appendValueInput("toLow", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MAP_TO)
            .setCheck(Number);
        this.appendValueInput("toHigh", Number)
            .appendField(",")
            .setCheck(Number);
        this.appendDummyInput("")
            .appendField("]");
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_MATH_MAP);
    }
};

const math_indexer_number = {
    /**
     * Block for numeric value.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(MATH_HUE);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('0', blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput.math_number_validator_include_blank), 'NUM');
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_NUMBER_TOOLTIP);
    }
};

const math_random_seed = {
    init: function () {
        this.setColour(MATH_HUE);
        this.appendValueInput('NUM')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_RANDOM_SEED);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_MATH_RANDOM_SEED);
    }
};

const math_round = {

    init: function () {
        this.setColour(MATH_HUE);
        this.setOutput(true, Number);
        this.appendValueInput('VALUE')
            .setCheck(Number)
        this.appendValueInput('VAR')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ROUND)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_KEEP);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_DECIMAL);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ROUND_NEW_TOOLTIP);
    }
};

const text_to_number = {
    init: function () {
        var TO_INT_FLOAT =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_INT, 'int'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_FLOAT, 'float'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_BITES, 'b'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_BYTE + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_INT, 'bti']];
        this.setColour(MATH_HUE);
        this.appendValueInput('VAR')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(TO_INT_FLOAT), 'TOWHAT');
        this.setOutput(true, Number);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('TOWHAT');
            var TOOLTIPS = {
                'int': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TOOLTIP_TOINT,
                'float': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TOOLTIP_TOFLOAT,
                'b': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TEXT_TOBYTE
            };
            return TOOLTIPS[mode];
        });
    }
};

const text_to_number_skulpt = {
    init: function () {
        var TO_INT_FLOAT =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_INT, 'int'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_FLOAT, 'float']];
        this.setColour(MATH_HUE);
        this.appendValueInput('VAR')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(TO_INT_FLOAT), 'TOWHAT');
        this.setOutput(true, Number);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('TOWHAT');
            var TOOLTIPS = {
                'int': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TEXT_TOINT,
                'float': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TEXT_TOFLOAT
            };
            return TOOLTIPS[mode];
        });
    }
};

const base_map = math_map

const turn_to_int = {
    init: function () {
        this.setColour(MATH_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_BYTE + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TO_HEX);
        this.setOutput(true, Number);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TOOLTIP_TOHEX)
    }
};

const generate_cartesian_product = {
    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(MATH_HUE);
        this.itemCount_ = 1;
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['lists_create_with_item'], this));
        this.appendDummyInput('DUMMY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PRODUCT + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GENERATE_CARTESIAN_PRODUCT);
        this.appendValueInput('REPEAT')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EVERY_PER_ELEPER_ELEMENT);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_REPEAT_TITLE_TIMES);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_WITH_PYTHON_TOOLTIP);
        this.updateShape_();
    },
    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('lists_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('lists_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput(`ADD${i}`).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput(`ADD${i}`);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            let i = 0;
            while (this.getInput(`ADD${i}`)) {
                this.removeInput(`ADD${i}`);
                i++;
            }
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMPTY_REMINDER);
        } else {
            for (let i = 0; i < this.itemCount_; i++) {
                this.appendValueInput(`ADD${i}`);
                this.moveInputBefore(`ADD${i}`, 'REPEAT');
            }
        }
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
}

/***/ }),

/***/ "../python/blocks/procedures.js":
/*!**************************************!*\
  !*** ../python/blocks/procedures.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   procedures_callnoreturn: () => (/* binding */ procedures_callnoreturn),
/* harmony export */   procedures_callreturn: () => (/* binding */ procedures_callreturn),
/* harmony export */   procedures_defnoreturn: () => (/* binding */ procedures_defnoreturn),
/* harmony export */   procedures_defreturn: () => (/* binding */ procedures_defreturn),
/* harmony export */   procedures_ifreturn: () => (/* binding */ procedures_ifreturn),
/* harmony export */   procedures_mutatorarg: () => (/* binding */ procedures_mutatorarg),
/* harmony export */   procedures_mutatorcontainer: () => (/* binding */ procedures_mutatorcontainer),
/* harmony export */   procedures_return: () => (/* binding */ procedures_return)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _others_procedures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../others/procedures */ "../python/others/procedures.js");
/**
 * @license
 * Copyright 2012 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Procedure blocks for Blockly.
 * @author fraser@google.com (Neil Fraser)
 */



const procedures_defnoreturn = {
    /**
     * Block for defining a procedure with no return value.
     * @this {Blockly.Block}
     */
    init: function () {
        var initName = _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].findLegalName('', this);
        var nameField = new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(initName,
            _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].rename);
        nameField.setSpellcheck(false);
        this.appendDummyInput()
            // .appendField(Blockly.Msg['PROCEDURES_DEFNORETURN_TITLE'])
            .appendField(nameField, 'NAME')
            .appendField('', 'PARAMS');
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['procedures_mutatorarg'], this));
        if ((this.workspace.options.comments ||
            (this.workspace.options.parentWorkspace &&
                this.workspace.options.parentWorkspace.options.comments)) &&
            blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFNORETURN_COMMENT']) {
            this.setCommentText(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFNORETURN_COMMENT']);
        }
        this.setStyle('procedure_blocks');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFNORETURN_TOOLTIP']);
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFNORETURN_HELPURL']);
        this.arguments_ = [];
        this.argumentVarModels_ = [];
        this.setStatements_(true);
        this.statementConnection_ = null;
    },
    /**
     * Add or remove the statement block from this function definition.
     * @param {boolean} hasStatements True if a statement block is needed.
     * @this {Blockly.Block}
     */
    setStatements_: function (hasStatements) {
        if (this.hasStatements_ === hasStatements) {
            return;
        }
        if (hasStatements) {
            this.appendStatementInput('STACK')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFNORETURN_DO']);
            if (this.getInput('RETURN')) {
                this.moveInputBefore('STACK', 'RETURN');
            }
        } else {
            this.removeInput('STACK', true);
        }
        this.hasStatements_ = hasStatements;
    },
    /**
     * Update the display of parameters for this procedure definition block.
     * @private
     * @this {Blockly.Block}
     */
    updateParams_: function () {

        // Merge the arguments into a human-readable list.
        var paramString = '';
        if (this.arguments_.length) {
            paramString = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_BEFORE_PARAMS'] +
                ' ' + this.arguments_.join(', ');
        }
        // The params field is deterministic based on the mutation,
        // no need to fire a change event.
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.disable();
        try {
            this.setFieldValue(paramString, 'PARAMS');
        } finally {
            blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.enable();
        }
    },
    /**
     * Create XML to represent the argument inputs.
     * @param {boolean=} opt_paramIds If true include the IDs of the parameter
     *     quarks.  Used by Procedures.mutateCallers for reconnection.
     * @return {!Element} XML storage element.
     * @this {Blockly.Block}
     */
    mutationToDom: function (opt_paramIds) {
        var container = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('mutation');
        if (opt_paramIds) {
            container.setAttribute('name', this.getFieldValue('NAME'));
        }
        for (var i = 0; i < this.argumentVarModels_.length; i++) {
            var parameter = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('arg');
            var argModel = this.argumentVarModels_[i];
            parameter.setAttribute('name', argModel.name);
            parameter.setAttribute('varid', argModel.getId());
            if (opt_paramIds && this.paramIds_) {
                parameter.setAttribute('paramId', this.paramIds_[i]);
            }
            container.appendChild(parameter);
        }

        // Save whether the statement input is visible.
        if (!this.hasStatements_) {
            container.setAttribute('statements', 'false');
        }
        return container;
    },
    /**
     * Parse XML to restore the argument inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this {Blockly.Block}
     */
    domToMutation: function (xmlElement) {
        this.arguments_ = [];
        this.argumentVarModels_ = [];
        for (var i = 0, childNode; (childNode = xmlElement.childNodes[i]); i++) {
            if (childNode.nodeName.toLowerCase() == 'arg') {
                var varName = childNode.getAttribute('name');
                var varId = childNode.getAttribute('varid') || childNode.getAttribute('varId');
                this.arguments_.push(varName);
                var variable = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.getOrCreateVariablePackage(
                    this.workspace, varId, varName, '');
                if (variable != null) {
                    this.argumentVarModels_.push(variable);
                } else {
                    console.log('Failed to create a variable with name ' + varName + ', ignoring.');
                }
            }
        }
        this.updateParams_();
        _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].mutateCallers(this);

        // Show or hide the statement input.
        this.setStatements_(xmlElement.getAttribute('statements') !== 'false');
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this {Blockly.Block}
     */
    decompose: function (workspace) {
        /*
         * Creates the following XML:
         * <block type="procedures_mutatorcontainer">
         *   <statement name="STACK">
         *     <block type="procedures_mutatorarg">
         *       <field name="NAME">arg1_name</field>
         *       <next>etc...</next>
         *     </block>
         *   </statement>
         * </block>
         */

        var containerBlockNode = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        containerBlockNode.setAttribute('type', 'procedures_mutatorcontainer');
        var statementNode = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('statement');
        statementNode.setAttribute('name', 'STACK');
        containerBlockNode.appendChild(statementNode);

        var node = statementNode;
        for (var i = 0; i < this.arguments_.length; i++) {
            var argBlockNode = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
            argBlockNode.setAttribute('type', 'procedures_mutatorarg');
            var fieldNode = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('field');
            fieldNode.setAttribute('name', 'NAME');
            var argumentName = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createTextNode(this.arguments_[i]);
            fieldNode.appendChild(argumentName);
            argBlockNode.appendChild(fieldNode);
            var nextNode = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('next');
            argBlockNode.appendChild(nextNode);

            node.appendChild(argBlockNode);
            node = nextNode;
        }

        var containerBlock = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Xml.domToBlock(containerBlockNode, workspace);

        if (this.type == 'procedures_defreturn') {
            containerBlock.setFieldValue(this.hasStatements_, 'STATEMENTS');
        } else {
            containerBlock.removeInput('STATEMENT_INPUT');
        }

        // Initialize procedure's callers with blank IDs.
        _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].mutateCallers(this);
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this {Blockly.Block}
     */
    compose: function (containerBlock) {
        // Parameter list.
        this.arguments_ = [];
        this.paramIds_ = [];
        this.argumentVarModels_ = [];
        var paramBlock = containerBlock.getInputTargetBlock('STACK');
        while (paramBlock && !paramBlock.isInsertionMarker()) {
            var varName = paramBlock.getFieldValue('NAME');
            this.arguments_.push(varName);
            var variable = this.workspace.getVariable(varName, '');
            this.argumentVarModels_.push(variable);

            this.paramIds_.push(paramBlock.id);
            paramBlock = paramBlock.nextConnection &&
                paramBlock.nextConnection.targetBlock();
        }
        this.updateParams_();
        _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].mutateCallers(this);

        // Show/hide the statement input.
        var hasStatements = containerBlock.getFieldValue('STATEMENTS');
        if (hasStatements !== null) {
            hasStatements = hasStatements == 'TRUE';
            if (this.hasStatements_ != hasStatements) {
                if (hasStatements) {
                    this.setStatements_(true);
                    // Restore the stack, if one was saved.
                    this.statementConnection_ && this.statementConnection_.reconnect(this, 'STACK');
                    this.statementConnection_ = null;
                } else {
                    // Save the stack, then disconnect it.
                    var stackConnection = this.getInput('STACK').connection;
                    this.statementConnection_ = stackConnection.targetConnection;
                    if (this.statementConnection_) {
                        var stackBlock = stackConnection.targetBlock();
                        stackBlock.unplug();
                        stackBlock.bumpNeighbours();
                    }
                    this.setStatements_(false);
                }
            }
        }
    },
    /**
     * Return the signature of this procedure definition.
     * @return {!Array} Tuple containing three elements:
     *     - the name of the defined procedure,
     *     - a list of all its arguments,
     *     - that it DOES NOT have a return value.
     * @this {Blockly.Block}
     */
    getProcedureDef: function () {
        return [this.getFieldValue('NAME'), this.arguments_, false];
    },
    /**
     * Return all variables referenced by this block.
     * @return {!Array<string>} List of variable names.
     * @this {Blockly.Block}
     */
    getVars: function () {
        return this.arguments_;
    },
    /**
     * Return all variables referenced by this block.
     * @return {!Array<!Blockly.VariableModel>} List of variable models.
     * @this {Blockly.Block}
     */
    getVarModels: function () {
        return this.argumentVarModels_;
    },
    /**
     * Notification that a variable is renaming.
     * If the ID matches one of this block's variables, rename it.
     * @param {string} oldId ID of variable to rename.
     * @param {string} newId ID of new variable.  May be the same as oldId, but
     *     with an updated name.  Guaranteed to be the same type as the old
     *     variable.
     * @override
     * @this {Blockly.Block}
     */
    renameVarById: function (oldId, newId) {
        var oldVariable = this.workspace.getVariableById(oldId);
        if (oldVariable.type != '') {
            // Procedure arguments always have the empty type.
            return;
        }
        var oldName = oldVariable.name;
        var newVar = this.workspace.getVariableById(newId);

        var change = false;
        for (var i = 0; i < this.argumentVarModels_.length; i++) {
            if (this.argumentVarModels_[i].getId() == oldId) {
                this.arguments_[i] = newVar.name;
                this.argumentVarModels_[i] = newVar;
                change = true;
            }
        }
        if (change) {
            this.displayRenamedVar_(oldName, newVar.name);
            _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].mutateCallers(this);
        }
    },
    /**
     * Notification that a variable is renaming but keeping the same ID.  If the
     * variable is in use on this block, rerender to show the new name.
     * @param {!Blockly.VariableModel} variable The variable being renamed.
     * @package
     * @override
     * @this {Blockly.Block}
     */
    updateVarName: function (variable) {
        var newName = variable.name;
        var change = false;
        for (var i = 0; i < this.argumentVarModels_.length; i++) {
            if (this.argumentVarModels_[i].getId() == variable.getId()) {
                var oldName = this.arguments_[i];
                this.arguments_[i] = newName;
                change = true;
            }
        }
        if (change) {
            this.displayRenamedVar_(oldName, newName);
            _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].mutateCallers(this);
        }
    },
    /**
     * Update the display to reflect a newly renamed argument.
     * @param {string} oldName The old display name of the argument.
     * @param {string} newName The new display name of the argument.
     * @private
     * @this {Blockly.Block}
     */
    displayRenamedVar_: function (oldName, newName) {
        this.updateParams_();
        const mutator = this.getIcon(blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon.TYPE);
        // Update the mutator's variables if the mutator is open.
        if (mutator && mutator.bubbleIsVisible()) {
            var blocks = mutator.getWorkspace().getAllBlocks(false);
            for (var i = 0, block; (block = blocks[i]); i++) {
                if (block.type == 'procedures_mutatorarg' &&
                    blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, block.getFieldValue('NAME'))) {
                    block.setFieldValue(newName, 'NAME');
                }
            }
        }
    },
    /**
     * Add custom menu options to this block's context menu.
     * @param {!Array} options List of menu options to add to.
     * @this {Blockly.Block}
     */
    customContextMenu: function (options) {
        if (this.isInFlyout) {
            return;
        }
        // Add option to create caller.
        var option = { enabled: true };
        var name = this.getFieldValue('NAME');
        option.text = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_CREATE_DO'].replace('%1', name);
        var xmlMutation = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('mutation');
        xmlMutation.setAttribute('name', name);
        for (var i = 0; i < this.arguments_.length; i++) {
            var xmlArg = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('arg');
            xmlArg.setAttribute('name', this.arguments_[i]);
            xmlMutation.appendChild(xmlArg);
        }
        var xmlBlock = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        xmlBlock.setAttribute('type', this.callType_);
        xmlBlock.appendChild(xmlMutation);
        option.callback = blockly_core__WEBPACK_IMPORTED_MODULE_0__.ContextMenu.callbackFactory(this, xmlBlock);
        options.push(option);

        // Add options to create getters for each parameter.
        if (!this.isCollapsed()) {
            for (var i = 0; i < this.argumentVarModels_.length; i++) {
                var argOption = { enabled: true };
                var argVar = this.argumentVarModels_[i];
                argOption.text = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['VARIABLES_SET_CREATE_GET']
                    .replace('%1', argVar.name);

                var argXmlField = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.generateVariableFieldDom(argVar);
                var argXmlBlock = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
                argXmlBlock.setAttribute('type', 'variables_get');
                argXmlBlock.appendChild(argXmlField);
                argOption.callback =
                    blockly_core__WEBPACK_IMPORTED_MODULE_0__.ContextMenu.callbackFactory(this, argXmlBlock);
                options.push(argOption);
            }
        }
    },
    callType_: 'procedures_callnoreturn'
};

const procedures_defreturn = {
    /**
     * Block for defining a procedure with a return value.
     * @this {Blockly.Block}
     */
    init: function () {
        var initName = _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].findLegalName('', this);
        var nameField = new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(initName,
            _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].rename);
        nameField.setSpellcheck(false);
        this.appendDummyInput()
            // .appendField(Blockly.Msg['PROCEDURES_DEFRETURN_TITLE'])
            .appendField(nameField, 'NAME')
            .appendField('', 'PARAMS');
        this.appendValueInput('RETURN')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFRETURN_RETURN']);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['procedures_mutatorarg'], this));
        if ((this.workspace.options.comments ||
            (this.workspace.options.parentWorkspace &&
                this.workspace.options.parentWorkspace.options.comments)) &&
            blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFRETURN_COMMENT']) {
            this.setCommentText(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFRETURN_COMMENT']);
        }
        this.setStyle('procedure_blocks');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFRETURN_TOOLTIP']);
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFRETURN_HELPURL']);
        this.arguments_ = [];
        this.argumentVarModels_ = [];
        this.setStatements_(true);
        this.statementConnection_ = null;
    },
    setStatements_: procedures_defnoreturn.setStatements_,
    updateParams_: procedures_defnoreturn.updateParams_,
    mutationToDom: procedures_defnoreturn.mutationToDom,
    domToMutation: procedures_defnoreturn.domToMutation,
    decompose: procedures_defnoreturn.decompose,
    compose: procedures_defnoreturn.compose,
    /**
     * Return the signature of this procedure definition.
     * @return {!Array} Tuple containing three elements:
     *     - the name of the defined procedure,
     *     - a list of all its arguments,
     *     - that it DOES have a return value.
     * @this {Blockly.Block}
     */
    getProcedureDef: function () {
        return [this.getFieldValue('NAME'), this.arguments_, true];
    },
    getVars: procedures_defnoreturn.getVars,
    getVarModels: procedures_defnoreturn.getVarModels,
    renameVarById: procedures_defnoreturn.renameVarById,
    updateVarName: procedures_defnoreturn.updateVarName,
    displayRenamedVar_: procedures_defnoreturn.displayRenamedVar_,
    customContextMenu: procedures_defnoreturn.customContextMenu,
    callType_: 'procedures_callreturn'
};

const procedures_mutatorcontainer = {
    /**
     * Mutator block for procedure container.
     * @this {Blockly.Block}
     */
    init: function () {
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_MUTATORCONTAINER_TITLE']);
        this.appendStatementInput('STACK');
        this.appendDummyInput('STATEMENT_INPUT')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_ALLOW_STATEMENTS'])
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldCheckbox('TRUE'), 'STATEMENTS');
        this.setStyle('procedure_blocks');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_MUTATORCONTAINER_TOOLTIP']);
        this.contextMenu = false;
    },
};

const procedures_mutatorarg = {
    /**
     * Mutator block for procedure argument.
     * @this {Blockly.Block}
     */
    init: function () {
        var field = new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(
            _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].DEFAULT_ARG, this.validator_);
        // Hack: override showEditor to do just a little bit more work.
        // We don't have a good place to hook into the start of a text edit.
        field.oldShowEditorFn_ = field.showEditor_;
        var newShowEditorFn = function () {
            this.createdVariables_ = [];
            this.oldShowEditorFn_();
        };
        field.showEditor_ = newShowEditorFn;

        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_BEFORE_PARAMS)
            .appendField(field, 'NAME');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setStyle('procedure_blocks');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_MUTATORARG_TOOLTIP']);
        this.contextMenu = false;

        // Create the default variable when we drag the block in from the flyout.
        // Have to do this after installing the field on the block.
        field.onFinishEditing_ = this.deleteIntermediateVars_;
        // Create an empty list so onFinishEditing_ has something to look at, even
        // though the editor was never opened.
        field.createdVariables_ = [];
        field.onFinishEditing_('x');
    },
    /**
     * Obtain a valid name for the procedure argument. Create a variable if
     * necessary.
     * Merge runs of whitespace.  Strip leading and trailing whitespace.
     * Beyond this, all names are legal.
     * @param {string} varName User-supplied name.
     * @return {?string} Valid name, or null if a name was not specified.
     * @private
     * @this Blockly.FieldTextInput
     */
    validator_: function (varName) {
        var sourceBlock = this.getSourceBlock();

        var outerWs = sourceBlock.workspace.getRootWorkspace();
        varName = varName.replace(/[\s\xa0]+/g, ' ').replace(/^ | $/g, '');
        if (!varName) {
            return null;
        }

        // Prevents duplicate parameter names in functions
        var workspace = sourceBlock.workspace.targetWorkspace ||
            sourceBlock.workspace;
        var blocks = workspace.getAllBlocks(false);
        var caselessName = varName.toLowerCase();
        for (var i = 0; i < blocks.length; i++) {
            if (blocks[i].id == this.getSourceBlock().id) {
                continue;
            }
            // Other blocks values may not be set yet when this is loaded.
            var otherVar = blocks[i].getFieldValue('NAME');
            if (otherVar && otherVar.toLowerCase() == caselessName) {
                return null;
            }
        }

        // Don't create variables for arg blocks that
        // only exist in the mutator's flyout.
        if (sourceBlock.isInFlyout) {
            return varName;
        }

        var model = outerWs.getVariable(varName, '');
        if (model && model.name != varName) {
            // Rename the variable (case change)
            outerWs.renameVariableById(model.getId(), varName);
        }
        if (!model) {
            model = outerWs.createVariable(varName, '');
            if (model && this.createdVariables_) {
                this.createdVariables_.push(model);
            }
        }
        return varName;
    },

    /**
     * Called when focusing away from the text field.
     * Deletes all variables that were created as the user typed their intended
     * variable name.
     * @param {string} newText The new variable name.
     * @private
     * @this Blockly.FieldTextInput
     */
    deleteIntermediateVars_: function (newText) {
        var outerWs = this.getSourceBlock().workspace.getRootWorkspace();
        if (!outerWs) {
            return;
        }
        for (var i = 0; i < this.createdVariables_.length; i++) {
            var model = this.createdVariables_[i];
            if (model.name != newText) {
                outerWs.deleteVariableById(model.getId());
            }
        }
    }
};

const procedures_callnoreturn = {
    /**
     * Block for calling a procedure with no return value.
     * @this {Blockly.Block}
     */
    init: function () {
        this.appendDummyInput('TOPROW')
            .appendField('', 'NAME');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setStyle('procedure_blocks');
        // Tooltip is set in renameProcedure.
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_CALLNORETURN_HELPURL']);
        this.arguments_ = [];
        this.argumentVarModels_ = [];
        this.quarkConnections_ = {};
        this.quarkIds_ = null;
        this.previousEnabledState_ = true;
    },

    /**
     * Returns the name of the procedure this block calls.
     * @return {string} Procedure name.
     * @this {Blockly.Block}
     */
    getProcedureCall: function () {
        // The NAME field is guaranteed to exist, null will never be returned.
        return /** @type {string} */ (this.getFieldValue('NAME'));
    },
    /**
     * Notification that a procedure is renaming.
     * If the name matches this block's procedure, rename it.
     * @param {string} oldName Previous name of procedure.
     * @param {string} newName Renamed procedure.
     * @this {Blockly.Block}
     */
    renameProcedure: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getProcedureCall())) {
            this.setFieldValue(newName, 'NAME');
            var baseMsg = this.outputConnection ?
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_CALLRETURN_TOOLTIP'] :
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_CALLNORETURN_TOOLTIP'];
            this.setTooltip(baseMsg.replace('%1', newName));
        }
    },
    /**
     * Notification that the procedure's parameters have changed.
     * @param {!Array<string>} paramNames New param names, e.g. ['x', 'y', 'z'].
     * @param {!Array<string>} paramIds IDs of params (consistent for each
     *     parameter through the life of a mutator, regardless of param renaming),
     *     e.g. ['piua', 'f8b_', 'oi.o'].
     * @private
     * @this {Blockly.Block}
     */
    setProcedureParameters_: function (paramNames, paramIds) {
        // Data structures:
        // this.arguments = ['x', 'y']
        //     Existing param names.
        // this.quarkConnections_ {piua: null, f8b_: Blockly.Connection}
        //     Look-up of paramIds to connections plugged into the call block.
        // this.quarkIds_ = ['piua', 'f8b_']
        //     Existing param IDs.
        // Note that quarkConnections_ may include IDs that no longer exist, but
        // which might reappear if a param is reattached in the mutator.
        var defBlock = _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].getDefinition(this.getProcedureCall(),
            this.workspace);
        const mutatorIcon = defBlock && defBlock.getIcon(blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon.TYPE);
        const mutatorOpen =
            mutatorIcon && mutatorIcon.bubbleIsVisible();
        if (!mutatorOpen) {
            this.quarkConnections_ = {};
            this.quarkIds_ = null;
        }
        if (!paramIds) {
            // Reset the quarks (a mutator is about to open).
            return;
        }
        // Test arguments (arrays of strings) for changes. '\n' is not a valid
        // argument name character, so it is a valid delimiter here.
        if (paramNames.join('\n') == this.arguments_.join('\n')) {
            // No change.
            this.quarkIds_ = paramIds;
            return;
        }
        if (paramIds.length != paramNames.length) {
            throw Error('paramNames and paramIds must be the same length.');
        }
        this.setCollapsed(false);
        if (!this.quarkIds_) {
            // Initialize tracking for this block.
            this.quarkConnections_ = {};
            this.quarkIds_ = [];
        }
        // Switch off rendering while the block is rebuilt.
        var savedRendered = this.rendered;
        this.rendered = false;
        // Update the quarkConnections_ with existing connections.
        for (var i = 0; i < this.arguments_.length; i++) {
            var input = this.getInput('ARG' + i);
            if (input) {
                var connection = input.connection.targetConnection;
                this.quarkConnections_[this.quarkIds_[i]] = connection;
                if (mutatorOpen && connection &&
                    paramIds.indexOf(this.quarkIds_[i]) == -1) {
                    // This connection should no longer be attached to this block.
                    connection.disconnect();
                    connection.getSourceBlock().bumpNeighbours();
                }
            }
        }
        // Rebuild the block's arguments.
        this.arguments_ = [].concat(paramNames);
        // And rebuild the argument model list.
        this.argumentVarModels_ = [];
        for (var i = 0; i < this.arguments_.length; i++) {
            var variable = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.getOrCreateVariablePackage(
                this.workspace, null, this.arguments_[i], '');
            this.argumentVarModels_.push(variable);
        }

        this.updateShape_();
        this.quarkIds_ = paramIds;
        // Reconnect any child blocks.
        if (this.quarkIds_) {
            for (var i = 0; i < this.arguments_.length; i++) {
                var quarkId = this.quarkIds_[i];
                if (quarkId in this.quarkConnections_) {
                    var connection = this.quarkConnections_[quarkId];
                    if (connection && !connection.reconnect(this, 'ARG' + i)) {
                        // Block no longer exists or has been attached elsewhere.
                        delete this.quarkConnections_[quarkId];
                    }
                }
            }
        }
        // Restore rendering and show the changes.
        this.rendered = savedRendered;
        if (this.rendered) {
            this.render();
        }
    },
    /**
     * Modify this block to have the correct number of arguments.
     * @private
     * @this {Blockly.Block}
     */
    updateShape_: function () {
        for (var i = 0; i < this.arguments_.length; i++) {
            var field = this.getField('ARGNAME' + i);
            if (field) {
                // Ensure argument name is up to date.
                // The argument name field is deterministic based on the mutation,
                // no need to fire a change event.
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.disable();
                try {
                    field.setValue(this.arguments_[i]);
                } finally {
                    blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.enable();
                }
            } else {
                // Add new input.
                field = new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldLabel(this.arguments_[i]);
                var input = this.appendValueInput('ARG' + i)
                    .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
                    .appendField(field, 'ARGNAME' + i);
                input.init();
            }
        }
        // Remove deleted inputs.
        while (this.getInput('ARG' + i)) {
            this.removeInput('ARG' + i);
            i++;
        }
        // Add 'with:' if there are parameters, remove otherwise.
        var topRow = this.getInput('TOPROW');
        if (topRow) {
            if (this.arguments_.length) {
                if (!this.getField('WITH')) {
                    topRow.appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_CALL_BEFORE_PARAMS'], 'WITH');
                    topRow.init();
                }
            } else {
                if (this.getField('WITH')) {
                    topRow.removeField('WITH');
                }
            }
        }
    },
    /**
     * Create XML to represent the (non-editable) name and arguments.
     * @return {!Element} XML storage element.
     * @this {Blockly.Block}
     */
    mutationToDom: function () {
        var container = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('mutation');
        container.setAttribute('name', this.getProcedureCall());
        for (var i = 0; i < this.arguments_.length; i++) {
            var parameter = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('arg');
            parameter.setAttribute('name', this.arguments_[i]);
            container.appendChild(parameter);
        }
        return container;
    },
    /**
     * Parse XML to restore the (non-editable) name and parameters.
     * @param {!Element} xmlElement XML storage element.
     * @this {Blockly.Block}
     */
    domToMutation: function (xmlElement) {
        var name = xmlElement.getAttribute('name');
        this.renameProcedure(this.getProcedureCall(), name);
        var args = [];
        var paramIds = [];
        for (var i = 0, childNode; (childNode = xmlElement.childNodes[i]); i++) {
            if (childNode.nodeName.toLowerCase() == 'arg') {
                args.push(childNode.getAttribute('name'));
                paramIds.push(childNode.getAttribute('paramId'));
            }
        }
        this.setProcedureParameters_(args, paramIds);
    },
    /**
     * Return all variables referenced by this block.
     * @return {!Array<string>} List of variable names.
     * @this {Blockly.Block}
     */
    getVars: function () {
        return this.arguments_;
    },
    /**
     * Return all variables referenced by this block.
     * @return {!Array<!Blockly.VariableModel>} List of variable models.
     * @this {Blockly.Block}
     */
    getVarModels: function () {
        return this.argumentVarModels_;
    },
    /**
     * Procedure calls cannot exist without the corresponding procedure
     * definition.  Enforce this link whenever an event is fired.
     * @param {!Blockly.Events.Abstract} event Change event.
     * @this {Blockly.Block}
     */
    onchange: function (event) {
        if (!this.workspace || this.workspace.isFlyout) {
            // Block is deleted or is in a flyout.
            return;
        }
        if (!event.recordUndo) {
            // Events not generated by user. Skip handling.
            return;
        }
        if (event.type == blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.BLOCK_CREATE &&
            event.ids.indexOf(this.id) != -1) {
            // Look for the case where a procedure call was created (usually through
            // paste) and there is no matching definition.  In this case, create
            // an empty definition block with the correct signature.
            var name = this.getProcedureCall();
            var def = _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].getDefinition(name, this.workspace);
            if (def && (def.type != this.defType_)) {
                // The signatures don't match.
                def = null;
            }
            if (!def) {
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.setGroup(event.group);
                /**
                 * Create matching definition block.
                 * <xml xmlns="https://developers.google.com/blockly/xml">
                 *   <block type="procedures_defreturn" x="10" y="20">
                 *     <mutation name="test">
                 *       <arg name="x"></arg>
                 *     </mutation>
                 *     <field name="NAME">test</field>
                 *   </block>
                 * </xml>
                 */
                var xml = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('xml');
                var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
                block.setAttribute('type', this.defType_);
                var xy = this.getRelativeToSurfaceXY();
                var x = xy.x + blockly_core__WEBPACK_IMPORTED_MODULE_0__.SNAP_RADIUS * (this.RTL ? -1 : 1);
                var y = xy.y + blockly_core__WEBPACK_IMPORTED_MODULE_0__.SNAP_RADIUS * 2;
                block.setAttribute('x', x);
                block.setAttribute('y', y);
                var mutation = this.mutationToDom();
                block.appendChild(mutation);
                var field = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('field');
                field.setAttribute('name', 'NAME');
                var callName = this.getProcedureCall();
                if (!callName) {
                    // Rename if name is empty string.
                    callName = _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].findLegalName('', this);
                    this.renameProcedure('', callName);
                }
                field.appendChild(blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createTextNode(callName));
                block.appendChild(field);
                xml.appendChild(block);
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.Xml.domToWorkspace(xml, this.workspace);
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.setGroup(false);
            } else {
                if (JSON.stringify(def.getVars()) != JSON.stringify(this.arguments_)) {
                    let paramNames = def.arguments_;
                    let paramIds = [];
                    for (var i = 0; i < this.arguments_.length; i++) {
                        var input = this.getInput('ARG' + i);
                        if (!input) {
                            continue;
                        }
                        var connection = input.connection.targetConnection;
                        if (!connection) {
                            paramIds.push(null);
                            continue;
                        }
                        paramIds.push(connection.sourceBlock_.id);
                    }
                    this.setProcedureParameters_(paramNames, paramIds);
                }
            }
        } else if (event.type == blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.BLOCK_DELETE) {
            // Look for the case where a procedure definition has been deleted,
            // leaving this block (a procedure call) orphaned.  In this case, delete
            // the orphan.
            var name = this.getProcedureCall();
            var def = _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].getDefinition(name, this.workspace);
            if (!def) {
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.setGroup(event.group);
                this.dispose(true);
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.setGroup(false);
            }
        } else if (event.type == blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.CHANGE && event.element == 'disabled') {
            var name = this.getProcedureCall();
            var def = _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].getDefinition(name, this.workspace);
            if (def && def.id == event.blockId) {
                // in most cases the old group should be ''
                var oldGroup = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.getGroup();
                if (oldGroup) {
                    // This should only be possible programmatically and may indicate a problem
                    // with event grouping. If you see this message please investigate. If the
                    // use ends up being valid we may need to reorder events in the undo stack.
                    console.log('Saw an existing group while responding to a definition change');
                }
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.setGroup(event.group);
                if (event.newValue) {
                    this.previousEnabledState_ = this.isEnabled();
                    this.setEnabled(false);
                } else {
                    this.setEnabled(this.previousEnabledState_);
                }
                blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.setGroup(oldGroup);
            }
        }
    },
    /**
     * Add menu option to find the definition block for this call.
     * @param {!Array} options List of menu options to add to.
     * @this {Blockly.Block}
     */
    customContextMenu: function (options) {
        if (!this.workspace.isMovable()) {
            // If we center on the block and the workspace isn't movable we could
            // loose blocks at the edges of the workspace.
            return;
        }

        var option = { enabled: true };
        option.text = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_HIGHLIGHT_DEF'];
        var name = this.getProcedureCall();
        var workspace = this.workspace;
        option.callback = function () {
            var def = _others_procedures__WEBPACK_IMPORTED_MODULE_1__["default"].getDefinition(name, workspace);
            if (def) {
                workspace.centerOnBlock(def.id);
                def.select();
            }
        };
        options.push(option);
    },
    defType_: 'procedures_defnoreturn'
};

const procedures_callreturn = {
    /**
     * Block for calling a procedure with a return value.
     * @this {Blockly.Block}
     */
    init: function () {
        this.appendDummyInput('TOPROW')
            .appendField('', 'NAME');
        this.setOutput(true);
        this.setStyle('procedure_blocks');
        // Tooltip is set in domToMutation.
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_CALLRETURN_HELPURL']);
        this.arguments_ = [];
        this.argumentVarModels_ = [];
        this.quarkConnections_ = {};
        this.quarkIds_ = null;
        this.previousEnabledState_ = true;
    },

    getProcedureCall: procedures_callnoreturn.getProcedureCall,
    renameProcedure: procedures_callnoreturn.renameProcedure,
    setProcedureParameters_:
        procedures_callnoreturn.setProcedureParameters_,
    updateShape_: procedures_callnoreturn.updateShape_,
    mutationToDom: procedures_callnoreturn.mutationToDom,
    domToMutation: procedures_callnoreturn.domToMutation,
    getVars: procedures_callnoreturn.getVars,
    getVarModels: procedures_callnoreturn.getVarModels,
    onchange: procedures_callnoreturn.onchange,
    customContextMenu:
        procedures_callnoreturn.customContextMenu,
    defType_: 'procedures_defreturn'
};

const procedures_ifreturn = {
    /**
     * Block for conditionally returning a value from a procedure.
     * @this {Blockly.Block}
     */
    init: function () {
        this.appendValueInput('CONDITION')
            .setCheck('Boolean')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['CONTROLS_IF_MSG_IF']);
        this.appendValueInput('VALUE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFRETURN_RETURN']);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setStyle('procedure_blocks');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_IFRETURN_TOOLTIP']);
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_IFRETURN_HELPURL']);
        this.hasReturnValue_ = true;
    },
    /**
     * Create XML to represent whether this block has a return value.
     * @return {!Element} XML storage element.
     * @this {Blockly.Block}
     */
    mutationToDom: function () {
        var container = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('mutation');
        container.setAttribute('value', Number(this.hasReturnValue_));
        return container;
    },
    /**
     * Parse XML to restore whether this block has a return value.
     * @param {!Element} xmlElement XML storage element.
     * @this {Blockly.Block}
     */
    domToMutation: function (xmlElement) {
        var value = xmlElement.getAttribute('value');
        this.hasReturnValue_ = (value == 1);
        if (!this.hasReturnValue_) {
            this.removeInput('VALUE');
            this.appendDummyInput('VALUE')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFRETURN_RETURN']);
        }
    },
    /**
     * Called whenever anything on the workspace changes.
     * Add warning if this flow block is not nested inside a loop.
     * @param {!Blockly.Events.Abstract} _e Change event.
     * @this {Blockly.Block}
     */
    onchange: function () {
        if (!this.workspace.isDragging || this.workspace.isDragging()) {
            return;  // Don't change state at the start of a drag.
        }
        var legal = false;
        // Is the block nested in a procedure?
        var block = this;
        do {
            if (this.FUNCTION_TYPES.indexOf(block.type) != -1) {
                legal = true;
                break;
            }
            block = block.getSurroundParent();
        } while (block);
        if (legal) {
            // If needed, toggle whether this block has a return value.
            if (block.type == 'procedures_defnoreturn' && this.hasReturnValue_) {
                this.removeInput('VALUE');
                this.appendDummyInput('VALUE')
                    .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFRETURN_RETURN']);
                this.hasReturnValue_ = false;
            } else if (block.type == 'procedures_defreturn' &&
                !this.hasReturnValue_) {
                this.removeInput('VALUE');
                this.appendValueInput('VALUE')
                    .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFRETURN_RETURN']);
                this.hasReturnValue_ = true;
            }
            this.setWarningText(null);
            if (!this.isInFlyout) {
                this.setEnabled(true);
            }
        } else {
            this.setWarningText(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_IFRETURN_WARNING']);
            if (!this.isInFlyout && !this.getInheritedDisabled()) {
                this.setEnabled(false);
            }
        }
    },
    /**
     * List of block types that are functions and thus do not need warnings.
     * To add a new function type add this to your code:
     * procedures_ifreturn.FUNCTION_TYPES.push('custom_func');
     */
    FUNCTION_TYPES: ['procedures_defnoreturn', 'procedures_defreturn']
};

const procedures_return = {
    /**
     * Block for conditionally returning a value from a procedure.
     * @this Blockly.Block
     */
    init: function () {
        this.setStyle('procedure_blocks');
        // this.appendValueInput('CONDITION')
        //     .setCheck(Boolean)
        //     .appendField(Blockly.Msg.CONTROLS_IF_MSG_IF);
        this.appendValueInput('VALUE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_DEFRETURN_RETURN);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_IFRETURN_TOOLTIP);
        this.hasReturnValue_ = true;
    },
    /**
     * Create XML to represent whether this block has a return value.
     * @return {!Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('value', Number(this.hasReturnValue_));
        return container;
    },
    /**
     * Parse XML to restore whether this block has a return value.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        var value = xmlElement.getAttribute('value');
        this.hasReturnValue_ = (value == 1);
        if (!this.hasReturnValue_) {
            this.removeInput('VALUE');
            this.appendDummyInput('VALUE')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_DEFRETURN_RETURN);
        }
    },
    /**
     * Called whenever anything on the workspace changes.
     * Add warning if this flow block is not nested inside a loop.
     * @param {!Blockly.Events.Abstract} e Change event.
     * @this Blockly.Block
     */
    onchange: function () {
        var legal = false;
        // Is the block nested in a procedure?
        var block = this;
        do {
            if (this.FUNCTION_TYPES.indexOf(block.type) != -1) {
                legal = true;
                break;
            }
            block = block.getSurroundParent();
        } while (block);
        if (legal) {
            // If needed, toggle whether this block has a return value.
            if (block.type == 'procedures_defnoreturn' && this.hasReturnValue_) {
                this.removeInput('VALUE');
                this.appendDummyInput('VALUE')
                    .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_DEFRETURN_RETURN);
                this.hasReturnValue_ = false;
            } else if (block.type == 'procedures_defreturn' &&
                !this.hasReturnValue_) {
                this.removeInput('VALUE');
                this.appendValueInput('VALUE')
                    .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_DEFRETURN_RETURN);
                this.hasReturnValue_ = true;
            }
            this.setWarningText(null);
        } else {
            this.setWarningText(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_IFRETURN_WARNING);
        }
    },
    /**
     * List of block types that are functions and thus do not need warnings.
     * To add a new function type add this to your code:
     * procedures_ifreturn.FUNCTION_TYPES.push('custom_func');
     */
    FUNCTION_TYPES: ['procedures_defnoreturn', 'procedures_defreturn', 'method_procedures_defnoreturn', 'method_procedures_defreturn']
};

/***/ }),

/***/ "../python/blocks/set.js":
/*!*******************************!*\
  !*** ../python/blocks/set.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   set_add_discard: () => (/* binding */ set_add_discard),
/* harmony export */   set_clear: () => (/* binding */ set_clear),
/* harmony export */   set_create_with: () => (/* binding */ set_create_with),
/* harmony export */   set_create_with_container: () => (/* binding */ set_create_with_container),
/* harmony export */   set_create_with_item: () => (/* binding */ set_create_with_item),
/* harmony export */   set_create_with_text_return: () => (/* binding */ set_create_with_text_return),
/* harmony export */   set_length: () => (/* binding */ set_length),
/* harmony export */   set_operate: () => (/* binding */ set_operate),
/* harmony export */   set_operate_update: () => (/* binding */ set_operate_update),
/* harmony export */   set_pop: () => (/* binding */ set_pop),
/* harmony export */   set_sub: () => (/* binding */ set_sub),
/* harmony export */   set_toset: () => (/* binding */ set_toset),
/* harmony export */   set_update: () => (/* binding */ set_update)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const SET_HUE = 100;

const set_create_with = {
    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(SET_HUE);
        this.appendDummyInput("")
            //don't need to specify the data type in Python
            // .appendField(new Blockly.FieldDropdown([[Blockly.Msg.MIXLY_NUMBER, 'Array<number>'], [Blockly.Msg.LANG_MATH_STRING, 'Array<string>'], [Blockly.Msg.LANG_MATH_BOOLEAN, 'Array<boolean>']]), 'TYPE')
            // .appendField(' ')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('s1'), 'VAR')

        this.itemCount_ = 3;
        this.updateShape_();
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['set_create_with_item'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_TOOLTIP);
    },
    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('set_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('set_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ADD' + i)) {
                this.removeInput('ADD' + i);
                i++;
            }
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_EMPTY_TITLE);
        } else {
            for (var i = 0; i < this.itemCount_; i++) {
                var input = this.appendValueInput('ADD' + i);
                if (i == 0) {
                    input.appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_INPUT_WITH);
                }
            }
        }
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const set_create_with_container = {
    /**
     * Mutator block for list container.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(SET_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_CONTAINER_TITLE_ADD);
        this.appendStatementInput('STACK');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_CONTAINER_TOOLTIP);
        this.contextMenu = false;
    }
};

const set_create_with_item = {
    /**
     * Mutator bolck for adding items.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(SET_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_VARIABLES_NAME);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_ITEM_TOOLTIP);
        this.contextMenu = false;
    }
};

const set_length = {

    init: function () {
        this.setColour(SET_HUE);
        this.appendValueInput('SET');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LENGTH);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SET_LENGTH_TOOLTIP);
        this.setOutput(true, Number);
    }
};

const set_pop = {
    init: function () {
        this.setColour(SET_HUE);
        this.appendValueInput('SET')
            .setCheck('Set')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_GET_AND_REMOVE_LAST);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SET_POP_TOOLTIP);
        this.setInputsInline(true);
        this.setOutput(true);
    }
};

const set_clear = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(SET_HUE);
        this.appendValueInput('SET')
            .setCheck('Set')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SET_CLEAR);

        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const set_operate = {
    init: function () {


        this.appendValueInput('SET1')
            .setCheck('Set')
        var operate = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_union, 'union'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_intersection, 'intersection'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_difference, 'difference']
        ];
        this.setColour(SET_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_and_set)
        this.appendValueInput('SET2')
            .setCheck('Set')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_get_operate)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(operate), 'OPERATE')

        this.setInputsInline(true);
        this.setOutput(true, "set");
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OPERATE');
            var TOOLTIPS = {
                'union': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_SET_UNION,
                'intersection': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_SET_INTERSECTION,
                'difference': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_SET_DIFFERENCE
            };
            return TOOLTIPS[mode];
        });
    }
};

const set_operate_update = {
    init: function () {

        this.appendValueInput('SET1')
            .setCheck('Set')
        var operate_update = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_union, 'update'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_intersection, 'intersection_update'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_difference, 'difference_update']
        ];
        this.setColour(SET_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_and_set)
        this.appendValueInput('SET2')
            .setCheck('Set')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_get_operate)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(operate_update), 'OPERATE')

        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_update)
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OPERATE');
            var TOOLTIPS = {
                'update': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_SET_UPDATE,
                'intersection_update': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_SET_INTERSECTION_UPDATE,
                'difference_update': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_SET_DIFFERENCE_UPDATE
            };
            return TOOLTIPS[mode];
        });
    }
};

const set_add_discard = {
    init: function () {
        this.appendValueInput('SET')
            .setCheck('Set')
        var changenum =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_blockpy_set_add, 'add'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_blockpy_set_discard, 'discard']];
        this.setColour(SET_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(changenum), 'OPERATE')
        this.appendValueInput('data')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_VARIABLES_NAME)
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OPERATE');
            var TOOLTIPS = {
                'add': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SET_ADD_TOOLTIP,
                'discard': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SET_DISCARD_TOOLTIP,

            };
            return TOOLTIPS[mode];
        });
    }
};

const set_sub = {
    init: function () {

        this.appendValueInput('SET1')
            .setCheck('Set')
        var sub_super = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_sub, 'issubset'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_super, 'issuperset']
        ];
        this.setColour(SET_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_is_set)
        this.appendValueInput('SET2')
            .setCheck('Set')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_of)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(sub_super), 'OPERATE')


        this.setInputsInline(true);
        this.setOutput(true, Boolean);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OPERATE');
            var TOOLTIPS = {
                'issubset': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_SET_SUB,
                'issuperset': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_SET_SUPER

            };
            return TOOLTIPS[mode];
        });
    }
};

const set_update = {
    init: function () {
        this.appendValueInput('SET')
            .setCheck('Set')
        this.setColour(SET_HUE);
        this.appendValueInput('VAR')
            .setCheck([String, 'List'])
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_set_add_update);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SET_UPDATE_TOOLTIP);
    }
};

// export const set_change_to = {
//   init: function() {
//     var OPERATORS =
//         [[Blockly.Msg.MIXLY_MICROBIT_TYPE_LIST, 'list'],
//          [Blockly.Msg.MIXLY_MICROBIT_TYPE_TUPLE, 'tuple']
//         ];
//     this.setColour(SET_HUE);
//     this.appendValueInput('VAR')
//         .setCheck("Set")
//         // .appendField(Blockly.Msg.blockpy_USE_LIST);
//     this.appendDummyInput("")
//         .appendField(Blockly.Msg.A_TO_B)
//         .appendField(new Blockly.FieldDropdown(OPERATORS), 'OP');
//     this.setInputsInline(true);
//     this.setOutput(true);
//     var thisBlock = this;
//     this.setTooltip(function() {
//       var mode = thisBlock.getFieldValue('OP');
//       var TOOLTIPS = {
//         'list': Blockly.Msg.SET_TO_LISTS,
//         'tuple': Blockly.Msg.SET_TO_TUPLE,
//       };
//       return TOOLTIPS[mode];
//     });
//   }
// };

const set_create_with_text_return = {
    init: function () {
        this.setColour(SET_HUE);
        this.appendDummyInput("")
            .appendField('{')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('0,0,0'), 'TEXT')
            .appendField('}');
        // .appendField(this.newQuote_(false))
        this.setOutput(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_TOOLTIP_SET_CREATE_WITH_TEXT);
    }
}

const set_toset = {
    init: function () {
        this.setColour(SET_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOSET);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TOOLTIP_TOSET);
    }
};

/***/ }),

/***/ "../python/blocks/storage.js":
/*!***********************************!*\
  !*** ../python/blocks/storage.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sdcard_mount: () => (/* binding */ sdcard_mount),
/* harmony export */   sdcard_use_spi_init: () => (/* binding */ sdcard_use_spi_init),
/* harmony export */   storage_can_write_ornot: () => (/* binding */ storage_can_write_ornot),
/* harmony export */   storage_change_dir: () => (/* binding */ storage_change_dir),
/* harmony export */   storage_close_file: () => (/* binding */ storage_close_file),
/* harmony export */   storage_delete_file: () => (/* binding */ storage_delete_file),
/* harmony export */   storage_file_seek: () => (/* binding */ storage_file_seek),
/* harmony export */   storage_file_tell: () => (/* binding */ storage_file_tell),
/* harmony export */   storage_file_write: () => (/* binding */ storage_file_write),
/* harmony export */   storage_fileopen: () => (/* binding */ storage_fileopen),
/* harmony export */   storage_fileopen_new: () => (/* binding */ storage_fileopen_new),
/* harmony export */   storage_fileopen_new_encoding: () => (/* binding */ storage_fileopen_new_encoding),
/* harmony export */   storage_get_a_line: () => (/* binding */ storage_get_a_line),
/* harmony export */   storage_get_contents: () => (/* binding */ storage_get_contents),
/* harmony export */   storage_get_contents_without_para: () => (/* binding */ storage_get_contents_without_para),
/* harmony export */   storage_get_current_dir: () => (/* binding */ storage_get_current_dir),
/* harmony export */   storage_get_file_size: () => (/* binding */ storage_get_file_size),
/* harmony export */   storage_get_filename: () => (/* binding */ storage_get_filename),
/* harmony export */   storage_is_file: () => (/* binding */ storage_is_file),
/* harmony export */   storage_list_all_files: () => (/* binding */ storage_list_all_files),
/* harmony export */   storage_make_dir: () => (/* binding */ storage_make_dir),
/* harmony export */   storage_open_file_with_os: () => (/* binding */ storage_open_file_with_os),
/* harmony export */   storage_rename: () => (/* binding */ storage_rename)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const STORAGE_HUE = 0; //'#5d69c5'//0;

const storage_open_file_with_os = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput('fn')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_STORAGE_OPEN_FILE_WITH_OS + "(For Windows)");
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
    }
}

const storage_fileopen = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILENAME")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_OPEN_FILE);
        //.appendField(new Blockly.FieldTextInput('filename.txt'), 'FILENAME');
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_MODE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_READ, 'r'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_WRITE, 'w'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_READ, 'rb'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_WRITE, 'wb']
            ]), 'MODE');
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_AS);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('MODE');
            var mode0 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_USE;
            var mode1 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_MODE;
            var mode2 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_OPEN_FILE;
            var mode3 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_BELONG;
            var TOOLTIPS = {
                'r': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_READ,
                'w': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_WRITE,
                'rb': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_READ,
                'wb': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_WRITE
            };
            return mode0 + TOOLTIPS[mode] + mode3 + mode1 + mode2;
        });
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};


const storage_fileopen_new = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILENAME")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_OPEN_FILE);
        //.appendField(new Blockly.FieldTextInput('filename.txt'), 'FILENAME');
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_MODE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_READ, 'r'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_WRITE, 'w'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_READ, 'rb'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_WRITE, 'wb']
            ]), 'MODE');
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setInputsInline(true);
        this.setOutput(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('MODE');
            var mode0 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_USE;
            var mode1 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_MODE;
            var mode2 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_OPEN_FILE;
            var mode3 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_BELONG;
            var mode4 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PY_STORAGE_FILE_OBJECT;
            var TOOLTIPS = {
                'r': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_READ,
                'w': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_WRITE,
                'rb': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_READ,
                'wb': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_WRITE
            };
            return mode0 + TOOLTIPS[mode] + mode3 + mode1 + mode2 + mode4;
        });
    }
};

const storage_fileopen_new_encoding = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILENAME")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_OPEN_FILE);
        //.appendField(new Blockly.FieldTextInput('filename.txt'), 'FILENAME');
        var code =
            [['ANSI', 'ANSI'], ['gbk', 'gbk'], ['utf-8', 'utf-8']];
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_MODE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_READ, 'r'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_WRITE, 'w'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_READ, 'rb'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_WRITE, 'wb']
            ]), 'MODE');
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_TEXT_ENCODE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(code), 'CODE')
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setInputsInline(true);
        this.setOutput(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('MODE');
            var mode0 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_USE;
            var mode1 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_MODE;
            var mode2 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_OPEN_FILE;
            var mode3 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_BELONG;
            var mode4 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PY_STORAGE_FILE_OBJECT;
            var TOOLTIPS = {
                'r': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_READ,
                'w': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_WRITE,
                'rb': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_READ,
                'wb': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_BIT_WRITE
            };
            return mode0 + TOOLTIPS[mode] + mode3 + mode1 + mode2 + mode4;
        });
    }
};

const storage_file_write = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput('data')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_SOCKET_MAKE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_WRITE);
        //    .appendField(new Blockly.FieldTextInput('f'), 'FILE');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_SOCKET_MAKE + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_STRING + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_WRITE);
    }
}

const storage_get_contents_without_para = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .setCheck('Variable')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FROM_FILE);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_ALL, 'read'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_ONE_LINE, 'readline'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_ALL_LINES, 'readlines']]), 'MODE');
        this.setInputsInline(true);
        this.setPreviousStatement(false); //in front of the block has something
        this.setNextStatement(false);  //beyond the ... has something
        this.setOutput(true, String);
    }
};

const storage_get_contents = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .setCheck('Variable')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FROM_FILE);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_NO_MORE_THAN_SIZE, 'read'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_ONE_LINE_NO_MORE_THAN_SIZE, 'readline'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_ALL_LINES_NO_MORE_THAN_SIZE, 'readlines']
            ]), 'MODE');
        this.appendValueInput("SIZE")
            .setCheck(Number);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CHARACTER);
        this.setInputsInline(true);
        this.setPreviousStatement(false); //in front of the block has something
        this.setNextStatement(false);  //beyond the ... has something
        this.setOutput(true, String);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('MODE');
            var mode0 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FROM_FILE;
            var mode2 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CHARACTER;
            var TOOLTIPS = {
                'read': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_NO_MORE_THAN_SIZE,
                'readline': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_ONE_LINE_NO_MORE_THAN_SIZE,
                'readlines': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_ALL_LINES_NO_MORE_THAN_SIZE
            };
            return mode0 + TOOLTIPS[mode] + 'x' + mode2;
        });
    }
};

const storage_get_a_line = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FROM_FILE);
        this.setNextStatement(true);
        this.appendValueInput("SIZE")
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_ONE_LINE_NO_MORE_THAN_SIZE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CHARACTER);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MICROBIT_PYTHON_TYPE);
    }
};

const storage_can_write_ornot = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_FILE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CAN_WRITE_ORNOT);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, Boolean);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CAN_WRITE_ORNOT1);
    }
};

const storage_get_filename = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILENAME);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET_FILENAME);
    }
};

const storage_close_file = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CLOSE_FILE);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setOutput(false);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CLOSE_FILE);
    }
};

const storage_list_all_files = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_LIST_ALL_FILES);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, 'List');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_LIST_ALL_FILES);
    }
};
blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_DELETE_FILE
const storage_delete_file = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_DELETE_FILE, 'remove'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_DELETE_DIRS, 'removedirs']
            ]), 'MODE');
        this.appendValueInput("FILE")
            .setCheck(String);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setOutput(false);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_DELETE_FILE);
    }
};

const storage_get_file_size = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET_FILE_SIZE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_SIZE);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, Number);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET_FILE_SIZE + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_SIZE);
    }
};

const storage_file_tell = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_RETURN_FILE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_PRESENT_LOCATION);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, Number);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_TELL);
    }
};

const storage_file_seek = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .setCheck('Variable')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_SET_FILE_POSITION);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CURRENT_POSITION);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_SEEK_START, 'start'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_SEEK_CURRENT, 'current'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_SEEK_END, 'end']
            ]), 'MODE');
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_SEEK_OFFSET);
        this.appendValueInput("SIZE")
            .setCheck(Number);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CHARACTER);
        this.setInputsInline(true);
        this.setPreviousStatement(true); //in front of the block has something
        this.setNextStatement(true);  //beyond the ... has something
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('MODE');
            var mode0 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_SET_FILE_POSITION + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CURRENT_POSITION;
            var mode2 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CHARACTER;
            var mode3 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_SEEK_OFFSET;
            var TOOLTIPS = {
                'start': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_SEEK_START,
                'current': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_SEEK_CURRENT,
                'end': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_FILE_SEEK_END
            };
            return mode0 + " " + TOOLTIPS[mode] + mode3 + 'x' + mode2;
        });
    }
};

const storage_get_current_dir = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET_CURRENT_DIR);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, 'List');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET_CURRENT_DIR);
    }
};

const storage_make_dir = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("PATH")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_PATH);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_SET);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_MKDIR, 'mkdir'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_MAKEDIRS, 'makedirs']
            ]), 'MODE');
        this.setInputsInline(true);
        this.setPreviousStatement(true); //in front of the block has something
        this.setNextStatement(true);  //beyond the ... has something
        this.setOutput(false);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('MODE');
            var mode0 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_PATH;
            var mode2 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_SET;
            var TOOLTIPS = {
                'mkdir': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_MKDIR,
                'makedirs': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_SOCKET_MAKEDIRS
            };
            return mode0 + 'x' + mode2 + TOOLTIPS[mode];
        });
    }
};

const storage_rename = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_RENAME);
        this.appendValueInput("NEWFILE")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AS);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setOutput(false);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_RENAME);
    }
};

const storage_change_dir = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CHANGE_DIR);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setOutput(false);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CHANGE_DIR);
    }
};

const storage_is_file = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput("FILE")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_THE_PATH);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_IS_OR_NOT);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_FILE, 'isfile'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_IS_DIR, 'isdir']
            ]), 'MODE');
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, Boolean);
        let thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('MODE');
            var mode0 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_THE_PATH;
            var mode2 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_IS_OR_NOT;
            var TOOLTIPS = {
                'isfile': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_MKDIR,
                'isdir': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_SOCKET_MAKEDIRS
            };
            return mode0 + 'x' + mode2 + TOOLTIPS[mode];
        });
    }
};

const sdcard_use_spi_init = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput('SPISUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_FOR_INPUT_WITH + "SPI")
            .setCheck("var");
        this.appendValueInput('PINSUB')
            .appendField("CS")
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_SOCKET_MAKE)
            .setCheck("var");
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SETUP + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SET_INDEX_INPUT_TO)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SD_CARD);
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const sdcard_mount = {
    init: function () {
        this.setColour(STORAGE_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SD_CARD);
        this.appendValueInput("DIR")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SDCARD_MOUNT);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip();
    }
}

/***/ }),

/***/ "../python/blocks/text.js":
/*!********************************!*\
  !*** ../python/blocks/text.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascii_to_char: () => (/* binding */ ascii_to_char),
/* harmony export */   char_to_ascii: () => (/* binding */ char_to_ascii),
/* harmony export */   number_to_text: () => (/* binding */ number_to_text),
/* harmony export */   os_system: () => (/* binding */ os_system),
/* harmony export */   text: () => (/* binding */ text),
/* harmony export */   text_capital: () => (/* binding */ text_capital),
/* harmony export */   text_center: () => (/* binding */ text_center),
/* harmony export */   text_char: () => (/* binding */ text_char),
/* harmony export */   text_char_at: () => (/* binding */ text_char_at),
/* harmony export */   text_char_at2: () => (/* binding */ text_char_at2),
/* harmony export */   text_char_at3: () => (/* binding */ text_char_at3),
/* harmony export */   text_compareTo: () => (/* binding */ text_compareTo),
/* harmony export */   text_compare_to: () => (/* binding */ text_compare_to),
/* harmony export */   text_create_with_container: () => (/* binding */ text_create_with_container),
/* harmony export */   text_create_with_item: () => (/* binding */ text_create_with_item),
/* harmony export */   text_encode: () => (/* binding */ text_encode),
/* harmony export */   text_equals_starts_ends: () => (/* binding */ text_equals_starts_ends),
/* harmony export */   text_eval: () => (/* binding */ text_eval),
/* harmony export */   text_find: () => (/* binding */ text_find),
/* harmony export */   text_format: () => (/* binding */ text_format),
/* harmony export */   text_format_noreturn: () => (/* binding */ text_format_noreturn),
/* harmony export */   text_join: () => (/* binding */ text_join),
/* harmony export */   text_join_seq: () => (/* binding */ text_join_seq),
/* harmony export */   text_length: () => (/* binding */ text_length),
/* harmony export */   text_random_char: () => (/* binding */ text_random_char),
/* harmony export */   text_replace: () => (/* binding */ text_replace),
/* harmony export */   text_split: () => (/* binding */ text_split),
/* harmony export */   text_strip: () => (/* binding */ text_strip),
/* harmony export */   text_substring: () => (/* binding */ text_substring),
/* harmony export */   text_substring2: () => (/* binding */ text_substring2),
/* harmony export */   text_substring3: () => (/* binding */ text_substring3),
/* harmony export */   text_textarea: () => (/* binding */ text_textarea)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const TEXTS_HUE = 160//'#9ec440'//160;

const text = {
    /**
     * Block for text value.
     * @this Blockly.Block
     */
    init: function () {
        //this.setHelpUrl(Blockly.Msg.TEXT_TEXT_HELPURL);
        this.setColour(TEXTS_HUE);
        this.appendDummyInput()
            .appendField(this.newQuote_(true))
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(''), 'TEXT')
            .appendField(this.newQuote_(false));
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TEXT_TOOLTIP);
    },
    /**
     * Create an image of an open or closed quote.
     * @param {boolean} open True if open quote, false if closed.
     * @return {!Blockly.FieldImage} The field image of the quote.
     * @private
     */
    newQuote_: function (open) {
        if (open == this.RTL) {
            var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAqUlEQVQI1z3KvUpCcRiA8ef9E4JNHhI0aFEacm1o0BsI0Slx8wa8gLauoDnoBhq7DcfWhggONDmJJgqCPA7neJ7p934EOOKOnM8Q7PDElo/4x4lFb2DmuUjcUzS3URnGib9qaPNbuXvBO3sGPHJDRG6fGVdMSeWDP2q99FQdFrz26Gu5Tq7dFMzUvbXy8KXeAj57cOklgA+u1B5AoslLtGIHQMaCVnwDnADZIFIrXsoXrgAAAABJRU5ErkJggg==';
        } else {
            var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAn0lEQVQI1z3OMa5BURSF4f/cQhAKjUQhuQmFNwGJEUi0RKN5rU7FHKhpjEH3TEMtkdBSCY1EIv8r7nFX9e29V7EBAOvu7RPjwmWGH/VuF8CyN9/OAdvqIXYLvtRaNjx9mMTDyo+NjAN1HNcl9ZQ5oQMM3dgDUqDo1l8DzvwmtZN7mnD+PkmLa+4mhrxVA9fRowBWmVBhFy5gYEjKMfz9AylsaRRgGzvZAAAAAElFTkSuQmCC';
        }
        return new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldImage(file, 12, 12, '"');
    }
};

const text_textarea = {
    /**
     * Block for text value.
     * @this Blockly.Block
     */
    init: function () {
        //this.setHelpUrl(Blockly.Msg.TEXT_TEXT_HELPURL);
        this.setColour(TEXTS_HUE);
        this.appendDummyInput()
            .appendField(this.newQuote_(true))
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldMultilineInput('Hello\nMixly'), 'VALUE')
            // .appendField(new Blockly.FieldTextInput(''), 'TEXT')
            .appendField(this.newQuote_(false));
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_LINES_TOOLTIP);
    },
    /**
     * Create an image of an open or closed quote.
     * @param {boolean} open True if open quote, false if closed.
     * @return {!Blockly.FieldImage} The field image of the quote.
     * @private
     */
    newQuote_: function (open) {
        if (open == this.RTL) {
            var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAqUlEQVQI1z3KvUpCcRiA8ef9E4JNHhI0aFEacm1o0BsI0Slx8wa8gLauoDnoBhq7DcfWhggONDmJJgqCPA7neJ7p934EOOKOnM8Q7PDElo/4x4lFb2DmuUjcUzS3URnGib9qaPNbuXvBO3sGPHJDRG6fGVdMSeWDP2q99FQdFrz26Gu5Tq7dFMzUvbXy8KXeAj57cOklgA+u1B5AoslLtGIHQMaCVnwDnADZIFIrXsoXrgAAAABJRU5ErkJggg==';
        } else {
            var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAn0lEQVQI1z3OMa5BURSF4f/cQhAKjUQhuQmFNwGJEUi0RKN5rU7FHKhpjEH3TEMtkdBSCY1EIv8r7nFX9e29V7EBAOvu7RPjwmWGH/VuF8CyN9/OAdvqIXYLvtRaNjx9mMTDyo+NjAN1HNcl9ZQ5oQMM3dgDUqDo1l8DzvwmtZN7mnD+PkmLa+4mhrxVA9fRowBWmVBhFy5gYEjKMfz9AylsaRRgGzvZAAAAAElFTkSuQmCC';
        }
        return new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldImage(file, 12, 12, '"');
    }
};

blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput.char_validator = function (text) {
    if (text.length > 1) {
        if (text.charAt(0) === "\\") {
            var charAtOne = text.charAt(1);
            if (charAtOne === "0" ||
                charAtOne === "b" ||
                charAtOne === "f" ||
                charAtOne === "n" ||
                charAtOne === "r" ||
                charAtOne === "t" ||
                charAtOne === "\\" ||
                charAtOne === "'") {
                return String(text).substring(0, 2);
            } else if (charAtOne === "x" && text.charAt(2) === "0" && text.charAt(3) === "B") {
                return String(text).substring(0, 4);
            }
        }
    }
    return String(text).substring(0, 1);
};

const text_char = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendDummyInput()
            .appendField(this.newQuote_(true))
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('', blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput.char_validator), 'TEXT')
            .appendField(this.newQuote_(false));
        this.setOutput(true, Number);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHAR_TOOLTIP);
    },
    newQuote_: function (open) {
        if (open == true) {
            var file = '../../media/quote2.png';
        } else {
            var file = '../../media/quote3.png';
        }
        return new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldImage(file, 7, 12, '"');
    }
};


const text_join = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput('A')
            .setCheck([String, Number]);
        this.appendValueInput('B')
            .setCheck([String, Number])
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TEXT_JOIN);
        this.setInputsInline(true);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TEXT_JOIN);
    }
};

const ascii_to_char = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput('VAR')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOCHAR);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TEXT_TOCHAR);
    }
};

const char_to_ascii = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOASCII);
        this.setOutput(true, Number);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TEXT_TOASCII);
    }
};

const number_to_text = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOSTRING);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TOOLTIP_TOTEXT);
    }
};

const text_length = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LENGTH);
        this.setOutput(true, Number);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TEXT_LENGTH);
    }
}



const text_char_at2 = {
    init: function () {
        this.WHERE_OPTIONS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_START, "FROM_START"],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_END, "FROM_END"],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_GET_INDEX_RANDOM + 1 + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT2, "RANDOM"]
        ];
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_HELPURL);
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .setCheck(String)
        //    .appendField(Blockly.Msg.MIXLY_MICROBIT_TYPE_LIST)
        this.appendValueInput("AT")
            .setCheck(Number)
        this.appendDummyInput()
            //.appendField(Blockly.Msg.MIXLY_MID)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_GET, "MODE");
        //            .appendField("", "SPACE");
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TAIL && this.appendDummyInput("TAIL").appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TAIL);
        // this.appendDummyInput().appendField(Blockly.Msg.MIXLY_DE);
        this.setInputsInline(!0);
        this.setOutput(!0);
        this.updateAt_(!0);
        var b = this;
        this.setTooltip(function () {
            var a = b.getFieldValue("MODE"),
                e = b.getFieldValue("WHERE"),
                d = "";
            switch (a + " " + e) {
                case "GET FROM_START":
                case "GET FROM_END":
                    d = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FROM;
                    break;
                case "GET RANDOM":
                    d = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TOOLTIP_GET_RANDOM;
                    break;
                case "GET_REMOVE FROM_START":
                case "GET_REMOVE FROM_END":
                    d = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM;
                    break;
                case "GET_REMOVE RANDOM":
                    d = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM;
                    break;
            }
            if ("FROM_START" == e || "FROM_END" == e) d += "  " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_INDEX_FROM_START_TOOLTIP.replace("%1", blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.ONE_BASED_INDEXING ? "#1" : "#0");
            return d
        })
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('WHERE');
            var TOOLTIPS = {
                'FROM_START': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_START,
                'FROM_END': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_END,
                'RANDOM': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_GET_INDEX_RANDOM
            };
            return blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_DEFRETURN_RETURN + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_STRING + TOOLTIPS[mode] + 'n' + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT2;
        });
    },
    mutationToDom: function () {
        var a = document.createElement("mutation");
        a.setAttribute("statement", !this.outputConnection);
        var b = this.getInput("AT").type == blockly_core__WEBPACK_IMPORTED_MODULE_0__.INPUT_VALUE;
        a.setAttribute("at", b);
        return a
    },
    domToMutation: function (a) {
        var b = "true" == a.getAttribute("statement");
        this.updateStatement_(b);
        a = "false" != a.getAttribute("at");
        this.updateAt_(a)
    },
    updateStatement_: function (a) {
        a != !this.outputConnection && (this.unplug(!0, !0), a ? (this.setOutput(!1), this.setPreviousStatement(!0), this.setNextStatement(!0)) : (this.setPreviousStatement(!1), this.setNextStatement(!1), this.setOutput(!0)))
    },
    updateAt_: function (a) {
        this.removeInput("AT");
        this.removeInput("ORDINAL", !0);
        a ? (this.appendValueInput("AT").setCheck(Number), blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT2 && this.appendDummyInput("ORDINAL").appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT2)) : this.appendDummyInput("AT");
        var b = new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(this.WHERE_OPTIONS,
            function (b) {
                var e = "FROM_START" == b || "FROM_END" == b;
                if (e != a) {
                    var d = this.sourceBlock_;
                    d.updateAt_(e);
                    d.setFieldValue(b, "WHERE");
                    return null
                }
            });
        this.getInput("AT").appendField(b, "WHERE");
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TAIL && this.moveInputBefore("TAIL", null)
    }
};


const text_char_at = {
    init: function () {
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_HELPURL);
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .setCheck(String);
        this.appendValueInput("AT")
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_GET + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_START);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT2);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_DEFRETURN_RETURN + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_STRING + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_START + 'n' + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT2);
    }
}


const text_random_char = {
    init: function () {
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_HELPURL);
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .setCheck(String);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_RANDOM_CHAR);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_RANDOM_CHAR_TOOLTIP);
    }
}


const text_substring2 = {
    /**
     * Block for getting sublist.
     * @this Blockly.Block
     */
    init: function () {
        this['WHERE_OPTIONS_1'] = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_START, 'FROM_START'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_END, 'FROM_END'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_START_FIRST, 'FIRST']
        ];
        this['WHERE_OPTIONS_2'] = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_END_FROM_START, 'FROM_START'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_END_FROM_END, 'FROM_END'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_END_LAST, 'LAST']
        ];
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_HELPURL);
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .setCheck(String)
        //.appendField(Blockly.Msg.LISTS_GET_SUBLIST_TAIL)
        // if (Blockly.Msg.LISTS_GET_SUBLIST_TAIL) {
        //   this.appendDummyInput('TAIL')
        //       .appendField(Blockly.Msg.LISTS_GET_SUBLIST_TAIL);
        // }
        this.appendDummyInput('')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET);
        this.appendDummyInput('AT1');
        this.appendDummyInput('AT2');
        this.setInputsInline(true);
        this.setOutput(true, 'List');
        this.updateAt_(1, true);
        this.updateAt_(2, true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg._GET_TEXT_SUBLIST_TOOLTIP);
    },
    /**
     * Create XML to represent whether there are 'AT' inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        var isAt1 = this.getInput('AT1').type == blockly_core__WEBPACK_IMPORTED_MODULE_0__.INPUT_VALUE;
        container.setAttribute('at1', isAt1);
        var isAt2 = this.getInput('AT2').type == blockly_core__WEBPACK_IMPORTED_MODULE_0__.INPUT_VALUE;
        container.setAttribute('at2', isAt2);
        return container;
    },
    /**
     * Parse XML to restore the 'AT' inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        var isAt1 = (xmlElement.getAttribute('at1') == 'true');
        var isAt2 = (xmlElement.getAttribute('at2') == 'true');
        this.updateAt_(1, isAt1);
        this.updateAt_(2, isAt2);
    },
    /**
     * Create or delete an input for a numeric index.
     * This block has two such inputs, independant of each other.
     * @param {number} n Specify first or second input (1 or 2).
     * @param {boolean} isAt True if the input should exist.
     * @private
     * @this Blockly.Block
     */
    updateAt_: function (n, isAt) {
        // Create or delete an input for the numeric index.
        // Destroy old 'AT' and 'ORDINAL' inputs.
        this.removeInput('AT' + n);
        this.removeInput('ORDINAL' + n, true);
        // Create either a value 'AT' input or a dummy input.
        if (isAt) {
            this.appendValueInput('AT' + n).setCheck(Number);
            if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT2) {
                this.appendDummyInput('ORDINAL' + n)
                    .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT2);
            }
        } else {
            this.appendDummyInput('AT' + n);
        }
        var menu = new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(this['WHERE_OPTIONS_' + n],
            function (value) {
                var newAt = (value == 'FROM_START') || (value == 'FROM_END');
                // The 'isAt' variable is available due to this function being a
                // closure.
                if (newAt != isAt) {
                    var block = this.sourceBlock_;
                    block.updateAt_(n, newAt);
                    // This menu has been destroyed and replaced.
                    // Update the replacement.
                    block.setFieldValue(value, 'WHERE' + n);
                    return null;
                }
                return undefined;
            });
        this.getInput('AT' + n)
            .appendField(menu, 'WHERE' + n);
        if (n == 1) {
            this.moveInputBefore('AT1', 'AT2');
            if (this.getInput('ORDINAL1')) {
                this.moveInputBefore('ORDINAL1', 'AT2');
            }
        }
        // if (Blockly.Msg.LISTS_GET_SUBLIST_TAIL) {
        //   this.moveInputBefore('TAIL', null);
        // }
    }
};

const text_substring = {
    /**
     * Block for getting sublist.
     * @this Blockly.Block
     */
    init: function () {
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_HELPURL);
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .setCheck(String)
        this.appendValueInput('AT1')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_GET + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_START);
        this.appendValueInput('AT2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_END_FROM_START);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT2);
        this.setInputsInline(true);
        this.setOutput(true, ['List', String]);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg._GET_TEXT_SUBLIST_TOOLTIP);
    }
}

const text_equals_starts_ends = {
    init: function () {
        var TEXT_DOWHAT = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EQUALS, '==='],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_STARTSWITH, 'startswith'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ENDSWITH, 'endswith']
        ];
        this.setColour(TEXTS_HUE);
        this.appendValueInput("STR1")
            .setCheck(String);
        this.appendValueInput("STR2")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(TEXT_DOWHAT), 'DOWHAT')
            .setCheck(String);
        this.setOutput(true, [Boolean, Number]);
        this.setInputsInline(true);
    }
}

const text_compare_to = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput("STR1")
            .setCheck(String);
        this.appendValueInput("STR2")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_COMPARETO)
            .setCheck(String);
        this.setOutput(true, Number);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_COMPARETO_HELP);
    }
}

const text_capital = {
    init: function () {
        var TEXT_CAPITAL = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_UPPER, 'upper'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TITLE, 'title'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CAPITALIZE, 'capitalize'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_SWAPCASE, 'swapcase'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_LOWER, 'lower']
        ];
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(TEXT_CAPITAL), 'CAPITAL')
            .setCheck(String);
        this.setOutput(true, String);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('CAPITAL');
            var TOOLTIPS = {
                'upper': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_UPPER_TOOLTIP,
                'title': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_TITLE_TOOLTIP,
                'swapcase': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_SWAPCASE_TOOLTIP,
                'capitalize': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_CAPITALIZE_TOOLTIP,
                'lower': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_LOWER_TOOLTIP
            };
            return TOOLTIPS[mode];
        });
    }
}

const text_center = {
    init: function () {
        var TEXT_CENTER = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_LJUST, 'ljust'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CENTER, 'center'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_RJUST, 'rjust']
        ];
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(TEXT_CENTER), 'CENTER')
            .setCheck(String);
        this.appendValueInput("WID")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_WIDTH)
            .setCheck(Number);
        this.appendValueInput("Symbol")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_RECT_Fill)
            .setCheck(String);
        this.setInputsInline(true);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_CENTER_TOOLTIP);
    }
}

const text_find = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET)
            .setCheck(String);
        this.appendValueInput("STR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MID + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_CHARACTER)
            .setCheck(String);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LIST_INDEX);
        this.setInputsInline(true);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_FIND_TOOLTIP);
    }
}

const text_join_seq = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TEXT_JOIN_SEQ_USE_STR)
            .setCheck(String);
        this.appendValueInput('LIST')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TEXT_JOIN_SEQ_SEQ)
            .setCheck('List', 'Tuple', 'Set', 'Dict');
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TEXT_JOIN_SEQ_GET_STR);
        this.setInputsInline(true);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TEXT_JOIN_SEQ_TOOLTIP);
    }
}

const text_replace = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR")
            .setCheck(String);
        this.appendValueInput("STR1")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_REPLACE)
            .setCheck(String);
        this.appendValueInput("STR2")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_SET_INDEX_INPUT_TO)
            .setCheck(String);
        this.setInputsInline(true);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_REPLACE_TOOLTIP);
    }
}

const text_split = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput("VAR");
        this.appendValueInput("VAL")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LIST_SPLIT_AS);
        this.appendDummyInput('')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LIST_SPLIT);
        this.setOutput(true, "List");
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_SPLIT_TOOLTIP);
        this.setInputsInline(true);
    }
}

const text_strip = {
    init: function () {
        var STRIP =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TRIM_BOTH, 'strip'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TRIM_LEFT, 'lstrip'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TRIM_RIGHT, 'rstrip']];
        this.setColour(TEXTS_HUE);
        this.appendValueInput('VAR')
        this.appendDummyInput('')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_STRIM);
        this.appendDummyInput('')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(STRIP), 'TOWHAT');
        this.appendDummyInput('')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_BLANK);
        this.setOutput(true, String);
        this.setInputsInline(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('TOWHAT');
            var TOOLTIPS = {
                'strip': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TRIM_BOTH_TOOLTIP,
                'lstrip': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TRIM_LEFT_TOOLTIP,
                'rstrip': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TRIM_RIGHT_TOOLTIP
            };
            return TOOLTIPS[mode];
        });
    }
};

const text_format = {
    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_FORMAT)
        //don't need to specify the data type in Python
        // .appendField(new Blockly.FieldDropdown([[Blockly.Msg.MIXLY_NUMBER, 'Array<number>'], [Blockly.Msg.LANG_MATH_STRING, 'Array<string>'], [Blockly.Msg.LANG_MATH_BOOLEAN, 'Array<boolean>']]), 'TYPE')
        // .appendField(' ')
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('str'), 'VAR');
        this.itemCount_ = 1;
        this.updateShape_();
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setInputsInline(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['text_create_with_item'], this));
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_FORMAT_TOOLTIP);
    },
    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('text_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('text_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ADD' + i)) {
                this.removeInput('ADD' + i);
                i++;
            }
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField();
        } else {
            for (var i = 0; i < this.itemCount_; i++) {
                var input = this.appendValueInput('ADD' + i);
                if (i == 0) {
                    input.appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_BEFORE_PARAMS);
                }
            }
        }
    },
    getVars: function () {
        if (this.getFieldValue('VAR') != null) {
            if ((this.getFieldValue('VAR').indexOf("'") == -1) && (this.getFieldValue('VAR').indexOf('"') == -1)) {
                return [this.getFieldValue('VAR')];
            }
            return [];
        }
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }

    }
};

const text_create_with_container = {
    /**
     * Mutator block for list container.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_MUTATORCONTAINER_TITLE);
        this.appendStatementInput('STACK');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_WITH_CONTAINER_TOOLTIP);
        this.contextMenu = false;
    }
};

const text_create_with_item = {
    /**
     * Mutator bolck for adding items.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_VARIABLES_NAME);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_WITH_ITEM_TOOLTIP);
        this.contextMenu = false;
    }
};

const text_substring3 = text_substring
const text_compareTo = text_compare_to
const text_char_at3 = text_char_at

const text_format_noreturn = {
    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_FORMAT)
        //don't need to specify the data type in Python
        // .appendField(new Blockly.FieldDropdown([[Blockly.Msg.MIXLY_NUMBER, 'Array<number>'], [Blockly.Msg.LANG_MATH_STRING, 'Array<string>'], [Blockly.Msg.LANG_MATH_BOOLEAN, 'Array<boolean>']]), 'TYPE')
        // .appendField(' ')
        this.appendValueInput("VAR")
            .setCheck(String);
        this.itemCount_ = 1;
        this.updateShape_();
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setInputsInline(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['text_create_with_item'], this));
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TEXT_FORMAT_TOOLTIP);
    },
    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('text_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('text_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ADD' + i)) {
                this.removeInput('ADD' + i);
                i++;
            }
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField();
        } else {
            for (var i = 0; i < this.itemCount_; i++) {
                var input = this.appendValueInput('ADD' + i);
                if (i == 0) {
                    input.appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_BEFORE_PARAMS);
                }
            }
        }
    }
};



const text_encode = {
    init: function () {
        this.setColour(TEXTS_HUE);
        var encode_decode =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_TEXT_ENCODE, 'encode'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_TEXT_DECODE, 'decode']];
        var code =
            [['ASCII', 'ASCII'], ['gb2312', 'gb2312'], ['gbk', 'gbk'], ['utf-8', 'utf-8'], ['utf-16', 'utf-16'], ['utf-32', 'utf-32']];
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(code), 'CODE')
            .appendField(' ')
        this.appendValueInput("VAR")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(encode_decode), 'DIR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_STRING);
        this.setOutput(true, String);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_TEXT_ENCODE_DECODE_TOOLTIP);

    }
};


const text_eval = {
    init: function () {

        this.setColour(TEXTS_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TEXT_EVAL);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TEXT_EVAL_RESULT);
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TEXT_EVAL_TOOLTIP);
    }
};

const os_system = {
    init: function () {
        this.setColour(TEXTS_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_OS_SYSTEM);
        this.setInputsInline(true);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_OS_SYSTEM_TOOLTIP);
    }
};

/***/ }),

/***/ "../python/blocks/tuple.js":
/*!*********************************!*\
  !*** ../python/blocks/tuple.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tuple_change_to: () => (/* binding */ tuple_change_to),
/* harmony export */   tuple_create_with: () => (/* binding */ tuple_create_with),
/* harmony export */   tuple_create_with_container: () => (/* binding */ tuple_create_with_container),
/* harmony export */   tuple_create_with_item: () => (/* binding */ tuple_create_with_item),
/* harmony export */   tuple_create_with_noreturn: () => (/* binding */ tuple_create_with_noreturn),
/* harmony export */   tuple_create_with_text2: () => (/* binding */ tuple_create_with_text2),
/* harmony export */   tuple_create_with_text_return: () => (/* binding */ tuple_create_with_text_return),
/* harmony export */   tuple_del: () => (/* binding */ tuple_del),
/* harmony export */   tuple_find: () => (/* binding */ tuple_find),
/* harmony export */   tuple_getIndex: () => (/* binding */ tuple_getIndex),
/* harmony export */   tuple_getSublist: () => (/* binding */ tuple_getSublist),
/* harmony export */   tuple_get_random_item: () => (/* binding */ tuple_get_random_item),
/* harmony export */   tuple_get_sublist: () => (/* binding */ tuple_get_sublist),
/* harmony export */   tuple_join: () => (/* binding */ tuple_join),
/* harmony export */   tuple_length: () => (/* binding */ tuple_length),
/* harmony export */   tuple_max: () => (/* binding */ tuple_max),
/* harmony export */   tuple_totuple: () => (/* binding */ tuple_totuple),
/* harmony export */   tuple_trig: () => (/* binding */ tuple_trig)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const TUPLE_HUE = 195; //'#5ec73d'//195;

const tuple_create_with = {
    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TUPLE_HUE);
        this.appendDummyInput("")
            //don't need to specify the data type in Python
            // .appendField(new Blockly.FieldDropdown([[Blockly.Msg.MIXLY_NUMBER, 'Array<number>'], [Blockly.Msg.LANG_MATH_STRING, 'Array<string>'], [Blockly.Msg.LANG_MATH_BOOLEAN, 'Array<boolean>']]), 'TYPE')
            // .appendField(' ')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('mytup'), 'VAR');
        this.itemCount_ = 3;
        this.updateShape_();
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['tuple_create_with_item'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_WITH_TOOLTIP);
    },
    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('tuple_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('tuple_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ADD' + i)) {
                this.removeInput('ADD' + i);
                i++;
            }
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_EMPTY_TITLE);
        } else {
            for (var i = 0; i < this.itemCount_; i++) {
                var input = this.appendValueInput('ADD' + i);
                if (i == 0) {
                    input.appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_WITH_INPUT_WITH);
                }
            }
        }
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const tuple_create_with_container = {
    /**
     * Mutator block for list container.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TUPLE_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_WITH_CONTAINER_TITLE_ADD);
        this.appendStatementInput('STACK');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_WITH_CONTAINER_TOOLTIP);
        this.contextMenu = false;
    }
};

const tuple_create_with_item = {
    /**
     * Mutator bolck for adding items.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TUPLE_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_VARIABLES_NAME);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_WITH_ITEM_TOOLTIP);
        this.contextMenu = false;
    }
};

const tuple_create_with_text2 = {
    init: function () {
        this.setColour(TUPLE_HUE);
        this.appendDummyInput("")
            //don't need to specify the data type in Python
            // .appendField(new Blockly.FieldDropdown([[Blockly.Msg.MIXLY_NUMBER, 'Array<number>']]), 'TYPE')
            // .appendField(' ')
            // .appendField(Blockly.Msg.blockpy_MIXLY_TUPLE_CREATE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('mytup'), 'VAR')
            //.appendField(new Blockly.FieldTextInput('3',Blockly.FieldTextInput.math_number_validator), 'SIZE')
            // .appendField(Blockly.Msg.MIXLY_MAKELISTFROM)
            // .appendField(this.newQuote_(true))
            .appendField(' = (')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('0,0,0'), 'TEXT')
            .appendField(')');
        // .appendField(this.newQuote_(false))
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_TOOLTIP_TUPLE_CREATE_WITH_TEXT);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
    // newQuote_: function(open) {
    //   if (open == this.RTL) {
    //     var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAqUlEQVQI1z3KvUpCcRiA8ef9E4JNHhI0aFEacm1o0BsI0Slx8wa8gLauoDnoBhq7DcfWhggONDmJJgqCPA7neJ7p934EOOKOnM8Q7PDElo/4x4lFb2DmuUjcUzS3URnGib9qaPNbuXvBO3sGPHJDRG6fGVdMSeWDP2q99FQdFrz26Gu5Tq7dFMzUvbXy8KXeAj57cOklgA+u1B5AoslLtGIHQMaCVnwDnADZIFIrXsoXrgAAAABJRU5ErkJggg==';
    //   } else {
    //     var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAn0lEQVQI1z3OMa5BURSF4f/cQhAKjUQhuQmFNwGJEUi0RKN5rU7FHKhpjEH3TEMtkdBSCY1EIv8r7nFX9e29V7EBAOvu7RPjwmWGH/VuF8CyN9/OAdvqIXYLvtRaNjx9mMTDyo+NjAN1HNcl9ZQ5oQMM3dgDUqDo1l8DzvwmtZN7mnD+PkmLa+4mhrxVA9fRowBWmVBhFy5gYEjKMfz9AylsaRRgGzvZAAAAAElFTkSuQmCC';
    //   }
    //   return new Blockly.FieldImage(file, 12, 12, '"');
    // }
}

const tuple_create_with_text_return = {
    init: function () {
        this.setColour(TUPLE_HUE);
        this.appendDummyInput("")
            .appendField('(')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('0,0,0'), 'TEXT')
            .appendField(')');
        // .appendField(this.newQuote_(false))
        this.setOutput(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_TOOLTIP_TUPLE_CREATE_WITH_TEXT);
        // },
        // getVars: function() {
        //   return [this.getFieldValue('VAR')];
        // },
        // renameVar: function(oldName, newName) {
        //   if (Blockly.Names.equals(oldName, this.getFieldValue('VAR'))) {
        //     this.setTitleValue(newName, 'VAR');
        //   }
    }
    // newQuote_: function(open) {
    //   if (open == this.RTL) {
    //     var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAqUlEQVQI1z3KvUpCcRiA8ef9E4JNHhI0aFEacm1o0BsI0Slx8wa8gLauoDnoBhq7DcfWhggONDmJJgqCPA7neJ7p934EOOKOnM8Q7PDElo/4x4lFb2DmuUjcUzS3URnGib9qaPNbuXvBO3sGPHJDRG6fGVdMSeWDP2q99FQdFrz26Gu5Tq7dFMzUvbXy8KXeAj57cOklgA+u1B5AoslLtGIHQMaCVnwDnADZIFIrXsoXrgAAAABJRU5ErkJggg==';
    //   } else {
    //     var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAn0lEQVQI1z3OMa5BURSF4f/cQhAKjUQhuQmFNwGJEUi0RKN5rU7FHKhpjEH3TEMtkdBSCY1EIv8r7nFX9e29V7EBAOvu7RPjwmWGH/VuF8CyN9/OAdvqIXYLvtRaNjx9mMTDyo+NjAN1HNcl9ZQ5oQMM3dgDUqDo1l8DzvwmtZN7mnD+PkmLa+4mhrxVA9fRowBWmVBhFy5gYEjKMfz9AylsaRRgGzvZAAAAAElFTkSuQmCC';
    //   }
    //   return new Blockly.FieldImage(file, 12, 12, '"');
    // }
}

const tuple_getIndex = {
    init: function () {
        this.setColour(TUPLE_HUE);
        this.setOutput(true);
        this.appendValueInput('TUP')
            .setCheck('Tuple')
        this.appendValueInput('AT')
            .setCheck(Number)

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_LISTS_GET_INDEX1);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_LISTS_GET_INDEX2);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_GET_INDEX_TOOLTIP);
    }
};

const tuple_length = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TUPLE_HUE);
        this.appendValueInput('TUP');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LENGTH);

        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_LENGTH_TOOLTIP);
        this.setOutput(true, Number);
    }
};

const tuple_del = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TUPLE_HUE);
        this.appendValueInput('TUP')
            .setCheck('Tuple')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_DEL);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_DEL_TOOLTIP);
    }
};

const tuple_join = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TUPLE_HUE);
        this.appendValueInput('TUP1')
            .setCheck('Tuple')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_JOIN)
        this.appendValueInput('TUP2')
            .setCheck('Tuple')
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_JOIN_TOOLTIP);
        this.setOutput(true, "Tuple");
    }
};


const tuple_max = {
    init: function () {
        this.appendValueInput('TUP')
            .setCheck('Tuple')
        var max_min =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_TUPLE_MAX, 'max'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_TUPLE_MIN, 'min'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_SUM, 'sum']];
        this.setColour(TUPLE_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(max_min), 'DIR')


        this.setInputsInline(true);
        this.setOutput(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'max': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TUPLE_MAX,
                'min': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TUPLE_MIN,
                'sum': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TUPLE_SUM
            };
            return TOOLTIPS[mode];
        });
    }
};

const tuple_change_to = {
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_LIST, 'list'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_CONTAINER_TITLE_ADD, 'set']
        ];
        this.setColour(TUPLE_HUE);
        this.appendValueInput('VAR')
            .setCheck("Tuple")
        // .appendField(Blockly.Msg.blockpy_USE_LIST);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.A_TO_B)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        this.setInputsInline(true);
        this.setOutput(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'list': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_TO_LISTS,
                'set': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_TO_SET,
            };
            return TOOLTIPS[mode];
        });
    }
};

const tuple_find = {
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LIST_INDEX, 'INDEX'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LIST_COUNT, 'COUNT']
        ];
        this.setColour(TUPLE_HUE);
        this.appendValueInput('VAR')
            .setCheck('List')
        this.appendValueInput('data')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_VALUE)
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        //.appendField(new Blockly.FieldTextInput('mylist'), 'VAR')
        this.setInputsInline(true);
        this.setOutput(true, Number);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'INDEX': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TUPLE_FIND_INDEX,
                'COUNT': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TUPLE_FIND_COUNT

            };
            return TOOLTIPS[mode];
        });
    }
};

const tuple_trig = {
    init: function () {
        var OPERATORS = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LIST_LEN, 'LEN'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_SUM, 'SUM'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_MAX, 'MAX'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_MIN, 'MIN'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_AVERAGE, 'AVERAGE'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_MEDIAN, 'MEDIAN'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_MODE, 'MODE'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_STD_DEV, 'STD_DEV'],
        ];
        //this.setHelpUrl(Blockly.Msg.MATH_TRIG_HELPURL);
        this.setColour(TUPLE_HUE);
        this.setOutput(true, Number);
        this.appendValueInput('data')
            .setCheck('List')
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        this.setInputsInline(true);
        // Assign 'this' to a variable for use in the tooltip closure below.
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('OP');
            var TOOLTIPS = {
                'LEN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_LENGTH_TOOLTIP,
                'SUM': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_TUPLE_SUM,
                'MAX': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_TUPLE_MAX,
                'MIN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_TUPLE_MIN,
                'AVERAGE': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_TUPLE_AVERAGE,
                'MEDIAN': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_TUPLE_MEDIAN,
                'MODE': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_TUPLE_MODE,
                'STD_DEV': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_TOOLTIP_TUPLE_STD_DEV

            };
            return TOOLTIPS[mode];
        });
    }
};

const tuple_getSublist = {
    /**
     * Block for getting sublist.
     * @this Blockly.Block
     */
    init: function () {
        this['WHERE_OPTIONS_1'] = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_START, 'FROM_START'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_END, 'FROM_END'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_START_FIRST, 'FIRST']
        ];
        this['WHERE_OPTIONS_2'] = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_END_FROM_START, 'FROM_START'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_END_FROM_END, 'FROM_END'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_END_LAST, 'LAST']
        ];
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_HELPURL);
        this.setColour(TUPLE_HUE);
        this.appendValueInput('LIST')
            .setCheck('List')
        //.appendField(Blockly.Msg.LISTS_GET_SUBLIST_TAIL)
        // if (Blockly.Msg.LISTS_GET_SUBLIST_TAIL) {
        //   this.appendDummyInput('TAIL')
        //       .appendField(Blockly.Msg.LISTS_GET_SUBLIST_TAIL);
        // }
        this.appendDummyInput('')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET);
        this.appendDummyInput('AT1');
        this.appendDummyInput('AT2');
        this.setInputsInline(true);
        this.setOutput(true, 'List');
        this.updateAt_(1, true);
        this.updateAt_(2, true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYTHON_TUPLE_GET_SUBLIST_TOOLTIP);
    },
    /**
     * Create XML to represent whether there are 'AT' inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        var isAt1 = this.getInput('AT1').type == blockly_core__WEBPACK_IMPORTED_MODULE_0__.INPUT_VALUE;
        container.setAttribute('at1', isAt1);
        var isAt2 = this.getInput('AT2').type == blockly_core__WEBPACK_IMPORTED_MODULE_0__.INPUT_VALUE;
        container.setAttribute('at2', isAt2);
        return container;
    },
    /**
     * Parse XML to restore the 'AT' inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        var isAt1 = (xmlElement.getAttribute('at1') == 'true');
        var isAt2 = (xmlElement.getAttribute('at2') == 'true');
        this.updateAt_(1, isAt1);
        this.updateAt_(2, isAt2);
    },
    /**
     * Create or delete an input for a numeric index.
     * This block has two such inputs, independant of each other.
     * @param {number} n Specify first or second input (1 or 2).
     * @param {boolean} isAt True if the input should exist.
     * @private
     * @this Blockly.Block
     */
    updateAt_: function (n, isAt) {
        // Create or delete an input for the numeric index.
        // Destroy old 'AT' and 'ORDINAL' inputs.
        this.removeInput('AT' + n);
        this.removeInput('ORDINAL' + n, true);
        // Create either a value 'AT' input or a dummy input.
        if (isAt) {
            this.appendValueInput('AT' + n).setCheck(Number);
            if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT_TAIL) {
                this.appendDummyInput('ORDINAL' + n)
                    .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT_TAIL);
            }
        } else {
            this.appendDummyInput('AT' + n);
        }
        var menu = new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(this['WHERE_OPTIONS_' + n],
            function (value) {
                var newAt = (value == 'FROM_START') || (value == 'FROM_END');
                // The 'isAt' variable is available due to this function being a
                // closure.
                if (newAt != isAt) {
                    var block = this.sourceBlock_;
                    block.updateAt_(n, newAt);
                    // This menu has been destroyed and replaced.
                    // Update the replacement.
                    block.setFieldValue(value, 'WHERE' + n);
                    return null;
                }
                return undefined;
            });
        this.getInput('AT' + n)
            .appendField(menu, 'WHERE' + n);
        if (n == 1) {
            this.moveInputBefore('AT1', 'AT2');
            if (this.getInput('ORDINAL1')) {
                this.moveInputBefore('ORDINAL1', 'AT2');
            }
        }
        // if (Blockly.Msg.LISTS_GET_SUBLIST_TAIL) {
        //   this.moveInputBefore('TAIL', null);
        // }
    }
};

const tuple_create_with_noreturn = {
    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(TUPLE_HUE);
        this.itemCount_ = 3;
        this.updateShape_();
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, "Tuple")
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['tuple_create_with_item'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_WITH_TOOLTIP);
    },
    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('tuple_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('tuple_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ADD' + i)) {
                this.removeInput('ADD' + i);
                i++;
            }
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_EMPTY_TITLE);
        } else {
            for (var i = 0; i < this.itemCount_; i++) {
                var input = this.appendValueInput('ADD' + i);
                if (i == 0) {
                    input.appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_CREATE_WITH_INPUT_WITH);
                }
            }
        }
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const tuple_get_sublist = {
    /**
     * Block for getting sublist.
     * @this Blockly.Block
     */
    init: function () {
        this.setHelpUrl(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_HELPURL);
        this.setColour(TUPLE_HUE);
        this.appendValueInput('LIST')
        this.appendDummyInput('')
        this.appendValueInput('AT1')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_FROM_START);
        this.appendValueInput('AT2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT_TAIL + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_SUBLIST_END_FROM_START);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_CHARAT_TAIL);
        this.setInputsInline(true);
        this.setOutput(true, 'Tuple');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYTHON_TUPLE_GET_SUBLIST_TOOLTIP);
    }
}

const tuple_get_random_item = {
    init: function () {
        this.setColour(TUPLE_HUE);
        this.appendValueInput("TUP");
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET + " " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_RANDOM)
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_GET_INDEX_TOOLTIP_GET_RANDOM);
        this.setOutput(true);
    }
};

const tuple_totuple = {
    init: function () {
        this.setColour(TUPLE_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOTUPLE);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TOOLTIP_TOTUPLE);
    }
};

/***/ }),

/***/ "../python/blocks/utility.js":
/*!***********************************!*\
  !*** ../python/blocks/utility.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attribute_access: () => (/* binding */ attribute_access),
/* harmony export */   function_call: () => (/* binding */ function_call),
/* harmony export */   function_call_container: () => (/* binding */ function_call_container),
/* harmony export */   function_call_item: () => (/* binding */ function_call_item),
/* harmony export */   raw_block: () => (/* binding */ raw_block),
/* harmony export */   raw_empty: () => (/* binding */ raw_empty),
/* harmony export */   raw_expression: () => (/* binding */ raw_expression),
/* harmony export */   raw_table: () => (/* binding */ raw_table),
/* harmony export */   text_comment: () => (/* binding */ text_comment),
/* harmony export */   text_print_multiple: () => (/* binding */ text_print_multiple),
/* harmony export */   text_print_multiple_container: () => (/* binding */ text_print_multiple_container),
/* harmony export */   text_print_multiple_item: () => (/* binding */ text_print_multiple_item),
/* harmony export */   type_check: () => (/* binding */ type_check)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Visual Blocks Editor
 *
 * Copyright 2012 Google Inc.
 * https://developers.google.com/blockly/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Utility blocks for Blockly.
 * @author acbart@vt.edu (Austin Cory Bart)
 */


const UTILITY_HUE = 160;

const raw_table = {
    // Container.
    init: function () {
        this.setColour(UTILITY_HUE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.appendDummyInput()
            .appendField('Tabular Abstraction:');
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTable(''), 'TEXT');
    }
};

const raw_block = {
    // Container.
    init: function () {
        this.setColour(UTILITY_HUE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.appendDummyInput()
            .appendField('Code Block:');
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldMultilineInput(''), 'TEXT');
    }
};

const raw_expression = {
    // Container.
    init: function () {
        this.setColour(UTILITY_HUE);
        this.appendDummyInput()
            .appendField('Code Expression:');
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldMultilineInput(''), 'TEXT');
        this.setOutput(true);
    }
};

const raw_empty = {
    // Container.
    init: function () {
        this.setColour(UTILITY_HUE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.appendValueInput('VALUE')
            .appendField('');
        this.setInputsInline(false);
    }
};

const text_comment = {
    // Text value.
    init: function () {
        this.setColour(UTILITY_HUE);
        this.appendDummyInput()
            .appendTitle('Comment:')
            .appendTitle(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(''), 'TEXT');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip('This comment will be ignored by Python');
    }
};

const type_check = {
    // Set element at index.
    init: function () {
        this.setColour(UTILITY_HUE);
        this.appendValueInput('VALUE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TYPE_CHECK);
        this.setInputsInline(false);
        this.setOutput(true, 'Type');
        //this.setPreviousStatement(true);
        //this.setNextStatement(true);
    }
};


const text_print_multiple = {
    /**
     * Block for printing multiple things (including nothing)
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(UTILITY_HUE);
        this.itemCount_ = 1;
        this.updateShape_();
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['text_print_multiple_item'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_PRINT_TOOLTIP);
    },
    /**
     * Create XML to represent print inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Block.obtain(workspace,
            'text_print_multiple_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var x = 0; x < this.itemCount_; x++) {
            var itemBlock = workspace.newBlock('text_print_multiple_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('PRINT' + i).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        // Store a pointer to any connected child blocks.
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var x = 0;
        while (itemBlock) {
            var input = this.getInput('PRINT' + x);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            x++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('PRINT' + i)) {
                this.removeInput('PRINT' + i);
                i++;
            }
        }

        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField("print");
        } else {
            for (var i = 0; i < this.itemCount_; i++) {
                var input = this.appendValueInput('PRINT' + i);
                if (i == 0) {
                    input.appendField("print");
                }
            }
        }
    }
};

const text_print_multiple_container = {
    // Container.
    init: function () {
        this.setColour(UTILITY_HUE);
        this.appendDummyInput()
            .appendField('print');
        this.appendStatementInput('STACK');
        this.setTooltip('');
        this.contextMenu = false;
    }
};
const text_print_multiple_item = {
    // Add items.
    init: function () {
        this.setColour(UTILITY_HUE);
        this.appendDummyInput()
            .appendField('item');
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip('');
        this.contextMenu = false;
    }
};

const function_call = {
    /**
     * Block for printing multiple things (including nothing)
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(UTILITY_HUE);
        this.itemCount_ = 1;
        this.hasReturn_ = false;
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput("str"), 'NAME');
        this.updateShape_();
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['function_call_item'], this));
        this.setTooltip("Can be used to call any function");
    },
    /**
     * Create XML to represent print inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        container.setAttribute('hasReturn', this.hasReturn_ ? "TRUE" : "FALSE");
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.hasReturn_ = xmlElement.getAttribute('hasReturn') === "TRUE";
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Block.obtain(workspace,
            'function_call_container');
        containerBlock.initSvg();

        containerBlock.setFieldValue(this.hasStatements_ ? 'TRUE' : 'FALSE',
            'RETURN');

        var connection = containerBlock.getInput('STACK').connection;
        for (var x = 0; x < this.itemCount_; x++) {
            var itemBlock = workspace.newBlock('function_call_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Notification that the procedure's return state has changed.
     * @param {boolean} returnState New return state
     * @this Blockly.Block
     */
    setReturn: function (returnState) {
        this.unplug(true, true);
        this.setOutput(returnState);
        this.setPreviousStatement(!returnState);
        this.setNextStatement(!returnState);
        if (this.rendered) {
            this.render();
        }
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;

        this.hasReturn_ = containerBlock.getFieldValue("RETURN") === "TRUE";

        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ARGUMENT' + i).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        // Store a pointer to any connected child blocks.
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var x = 0;
        while (itemBlock) {
            var input = this.getInput('ARGUMENT' + x);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            x++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ARGUMENT' + i)) {
                this.removeInput('ARGUMENT' + i);
                i++;
            }
        }

        // Rebuild block.
        for (var i = 0; i < this.itemCount_; i++) {
            this.appendValueInput('ARGUMENT' + i);
        }

        // Set whether returns anything
        this.setReturn(this.hasReturn_);
    }
};

const function_call_container = {
    // Container.
    init: function () {
        this.setColour(UTILITY_HUE);
        this.appendDummyInput()
            .appendField('Arguments');
        this.appendStatementInput('STACK');
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('has return')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldCheckbox('TRUE'),
                'RETURN');
        this.setTooltip('');
        this.contextMenu = false;
    }
};
const function_call_item = {
    // Add items.
    init: function () {
        this.setColour(UTILITY_HUE);
        this.appendDummyInput()
            .appendField('argument');
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip('');
        this.contextMenu = false;
    }
};

const attribute_access = {
    init: function () {
        this.appendValueInput("MODULE")
            .setCheck(null);
        this.appendValueInput("NAME")
            .setCheck(null)
            .appendField(".");
        this.setInputsInline(true);
        this.setOutput(true, null);
        this.setColour(230);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};


/***/ }),

/***/ "../python/blocks/variables.js":
/*!*************************************!*\
  !*** ../python/blocks/variables.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   controls_type: () => (/* binding */ controls_type),
/* harmony export */   controls_typeLists: () => (/* binding */ controls_typeLists),
/* harmony export */   lists_zip: () => (/* binding */ lists_zip),
/* harmony export */   lists_zip_container: () => (/* binding */ lists_zip_container),
/* harmony export */   lists_zip_item: () => (/* binding */ lists_zip_item),
/* harmony export */   unpack_iterable_object: () => (/* binding */ unpack_iterable_object),
/* harmony export */   variables_change: () => (/* binding */ variables_change),
/* harmony export */   variables_get: () => (/* binding */ variables_get),
/* harmony export */   variables_global: () => (/* binding */ variables_global),
/* harmony export */   variables_set: () => (/* binding */ variables_set)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _others_names__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../others/names */ "../python/others/names.js");



const VARIABLES_HUE = 330//'#af5180'//330;

// ************************************************************************
// THIS SECTION IS INSERTED INTO BLOCKLY BY BLOCKLYDUINO.
//  export const variables_declare = {
//  // Variable setter.
//   init: function() {
//     this.setColour(VARIABLES_HUE);
//     this.appendValueInput('VALUE', null)
//         .appendField(Blockly.Msg.MIXLY_DECLARE)
//         .appendField(new Blockly.FieldTextInput(''), 'VAR')
//         //.appendField(Blockly.Msg.MIXLY_AS)
//         //.appendField(new Blockly.FieldDropdown([[Blockly.Msg.MIXLY_NUMBER, 'number'], [Blockly.Msg.LANG_MATH_STRING, 'string'], [Blockly.Msg.LANG_MATH_BOOLEAN, 'boolean']]), 'TYPE')
// 	    .appendField(Blockly.Msg.MIXLY_VALUE);
//     this.setPreviousStatement(true);
//     this.setNextStatement(true);
//     this.setTooltip(Blockly.Msg.MIXLY_TOOLTIP_VARIABLES_DECLARE);
//   },
//   getVars: function() {
//     return [this.getFieldValue('VAR')];
//   },
//   renameVar: function(oldName, newName) {
//     if (Names.equals(oldName, this.getFieldValue('VAR'))) {
//       this.setTitleValue(newName, 'VAR');
//     }
//   }
// };
// ************************************************************************

const variables_get = {
    init: function () {
        this.setColour(VARIABLES_HUE);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(''), 'VAR')
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.VARIABLES_GET_TOOLTIP);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (_others_names__WEBPACK_IMPORTED_MODULE_1__["default"].equals(oldName, this.getFieldValue('VAR'))) {
            this.setFieldValue(newName, 'VAR');
        }
    }/*,
  onchange: function() {
	  var varName = Blockly.Arduino.variableDB_.getName(this.getFieldValue('VAR'),Blockly.Variables.NAME_TYPE);
	  if(Blockly.Arduino.definitions_['var_declare'+varName]){
		  this.setWarningText(null);
	  }else{
		  this.setWarningText(Blockly.Msg.MIXLY_WARNING_NOT_DECLARE);
	  }
  }*/
};

// export const variables_set = {
//   init: function() {
//     this.setColour(VARIABLES_HUE);
//     this.appendValueInput('VALUE')
//         .appendField(new Blockly.FieldTextInput(''), 'VAR')
// 		.appendField(Blockly.Msg.MIXLY_VALUE2);
//     this.setPreviousStatement(true);
//     this.setNextStatement(true);
//     this.setTooltip(Blockly.Msg.VARIABLES_SET_TOOLTIP);
//   },
//   getVars: function() {
//     return [this.getFieldValue('VAR')];
//   },
//   renameVar: function(oldName, newName) {
//     if (Names.equals(oldName, this.getFieldValue('VAR'))) {
//       this.setFieldValue(newName, 'VAR');
//     }
//   }/*,
//   onchange: function() {
// 	  var varName = Blockly.Arduino.variableDB_.getName(this.getFieldValue('VAR'),Blockly.Variables.NAME_TYPE);
// 	  if(Blockly.Arduino.definitions_['var_declare'+varName]){
// 		  this.setWarningText(null);
// 	  }else{
// 		  this.setWarningText(Blockly.Msg.MIXLY_WARNING_NOT_DECLARE);
// 	  }
//   }*/
// };
const variables_set = {
    init: function () {
        this.setColour(VARIABLES_HUE);
        this.appendValueInput('VALUE')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(''), 'VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_VALUE2);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.VARIABLES_SET_TOOLTIP);
    },
    getVars: function () {
        var varValue = this.getFieldValue('VAR');
        if (varValue == null) {
            return [];
        }
        return varValue.split(",");
    },
    renameVar: function (oldName, newName) {
        if (_others_names__WEBPACK_IMPORTED_MODULE_1__["default"].equals(oldName, this.getFieldValue('VAR'))) {
            this.setFieldValue(newName, 'VAR');
        }
    }
};
/**
  * Block for basic data type change.
  * @this Blockly.Block
  */
const variables_change = {
    init: function () {
        this.setColour(VARIABLES_HUE);
        var DATATYPES =
            [
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_INT, "int"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_FLOAT, "float"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_BOOLEAN, "bool"],
                // [Blockly.Msg.MIXLY_MICROPYTHON_TYPE_COMPLEX, "complex"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_STRING, "str"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_LIST, "list"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_TUPLE, "tuple"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_DICT, "dict"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_CONTAINER_TITLE_ADD, "set"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_BYTE, "bytes"]
            ];
        this.appendValueInput('MYVALUE')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(DATATYPES), 'OP');
        // Assign 'this' to a variable for use in the tooltip closure below.
        this.setOutput(true);
        // this.setInputsInline(true);

    }
};


const variables_global = {
    init: function () {
        this.setColour(VARIABLES_HUE);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_GLOBAL)
            .setCheck("var");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_PRINT_TOOLTIP);
    }
};


const controls_type = {
    init: function () {
        this.setColour(VARIABLES_HUE);
        this.appendValueInput("DATA")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MICROBIT_PYTHON_TYPE);
        // this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MICROBIT_PYTHON_TYPE);
    }
};


const controls_typeLists = {
    init: function () {
        this.setColour(VARIABLES_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_CONTORL_GET_TYPE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_INT, "int"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_FLOAT, "float"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_STRING, "str"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_LIST, "list"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_TUPLE, "tuple"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_DICT, "dict"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_CONTAINER_TITLE_ADD, "set"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_BYTE, "bytes"],
                // [Blockly.Msg.MIXLY_MICROBIT_IMAGE,"image"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_NULL, "type(None)"]]), "type");
        //整数、浮点数、字符串、列表、元组、字典、集合、图像不太对, unfinished
        this.setInputsInline(true);
        this.setOutput(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('type');
            var mode0 = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MICROBIT_controls_TypeLists;
            var TOOLTIPS = {
                'int': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_INT,
                'float': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_FLOAT,
                'str': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_STRING,
                'list': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_LIST,
                'tuple': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_TUPLE,
                'dict': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_DICT,
                'set': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_SET_CREATE_WITH_CONTAINER_TITLE_ADD,
                'image': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_IMAGE,
                'bytes': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_BYTE,
                'NoneType': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_NULL
            };
            return mode0 + TOOLTIPS[mode];
        });
    }
};

const lists_zip = {
    init: function () {
        this.setColour(VARIABLES_HUE);

        this.itemCount_ = 2;
        this.updateShape_();
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true, "List")
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['lists_zip_item'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LISTS_ZIP_TOOLTIP);
    },

    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },

    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },

    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('lists_zip_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('lists_zip_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },

    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },

    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },

    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ADD' + i)) {
                this.removeInput('ADD' + i);
                i++;
            }
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LISTS_ZIP);
        } else {
            for (var i = 0; i < this.itemCount_; i++) {
                var input = this.appendValueInput('ADD' + i);
                if (i == 0) {
                    input.appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LISTS_ZIP);
                }
            }
        }
    }
};
const lists_zip_container = {
    init: function () {
        this.setColour(VARIABLES_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LISTS_ZIP)
            .appendField('[]');
        this.appendStatementInput('STACK');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_PRINT_MANY_CONTAINER_TOOLTIP);
        this.contextMenu = false;
    }
};

const lists_zip_item = {
    init: function () {
        this.setColour(VARIABLES_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LISTS_ZIP_ITEM);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LISTS_ZIP_ITEM_TOOLTIP);
        this.contextMenu = false;
    }
};

const unpack_iterable_object = {
    init: function () {
        this.setColour(VARIABLES_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_VARIABLE_UNPACK)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_LISTS_ZIP_ITEM, '*'],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_DICT, '**']
            ]), 'TYPE');
        this.setTooltip('');
        this.setOutput(true);
    }
};

/***/ }),

/***/ "../python/export.js":
/*!***************************!*\
  !*** ../python/export.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Names: () => (/* reexport safe */ _others_names__WEBPACK_IMPORTED_MODULE_26__["default"]),
/* harmony export */   Procedures: () => (/* reexport safe */ _others_procedures__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   Python: () => (/* reexport safe */ _python_generator__WEBPACK_IMPORTED_MODULE_29__.Python),
/* harmony export */   PythonControlBlocks: () => (/* reexport module object */ _blocks_control__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   PythonControlGenerators: () => (/* reexport module object */ _generators_control__WEBPACK_IMPORTED_MODULE_14__),
/* harmony export */   PythonDictsBlocks: () => (/* reexport module object */ _blocks_dicts__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   PythonDictsGenerators: () => (/* reexport module object */ _generators_dicts__WEBPACK_IMPORTED_MODULE_18__),
/* harmony export */   PythonHtmlBlocks: () => (/* reexport module object */ _blocks_html__WEBPACK_IMPORTED_MODULE_11__),
/* harmony export */   PythonHtmlGenerators: () => (/* reexport module object */ _generators_html__WEBPACK_IMPORTED_MODULE_24__),
/* harmony export */   PythonListsBlocks: () => (/* reexport module object */ _blocks_lists__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   PythonListsGenerators: () => (/* reexport module object */ _generators_lists__WEBPACK_IMPORTED_MODULE_17__),
/* harmony export */   PythonLogicBlocks: () => (/* reexport module object */ _blocks_logic__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   PythonLogicGenerators: () => (/* reexport module object */ _generators_logic__WEBPACK_IMPORTED_MODULE_19__),
/* harmony export */   PythonMathBlocks: () => (/* reexport module object */ _blocks_math__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   PythonMathGenerators: () => (/* reexport module object */ _generators_math__WEBPACK_IMPORTED_MODULE_15__),
/* harmony export */   PythonProceduresBlocks: () => (/* reexport module object */ _blocks_procedures__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   PythonProceduresGenerators: () => (/* reexport module object */ _generators_procedures__WEBPACK_IMPORTED_MODULE_21__),
/* harmony export */   PythonSetBlocks: () => (/* reexport module object */ _blocks_set__WEBPACK_IMPORTED_MODULE_10__),
/* harmony export */   PythonSetGenerators: () => (/* reexport module object */ _generators_set__WEBPACK_IMPORTED_MODULE_23__),
/* harmony export */   PythonStorageBlocks: () => (/* reexport module object */ _blocks_storage__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   PythonStorageGenerators: () => (/* reexport module object */ _generators_storage__WEBPACK_IMPORTED_MODULE_20__),
/* harmony export */   PythonTextBlocks: () => (/* reexport module object */ _blocks_text__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   PythonTextGenerators: () => (/* reexport module object */ _generators_text__WEBPACK_IMPORTED_MODULE_16__),
/* harmony export */   PythonTupleBlocks: () => (/* reexport module object */ _blocks_tuple__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   PythonTupleGenerators: () => (/* reexport module object */ _generators_tuple__WEBPACK_IMPORTED_MODULE_22__),
/* harmony export */   PythonUtilityBlocks: () => (/* reexport module object */ _blocks_utility__WEBPACK_IMPORTED_MODULE_12__),
/* harmony export */   PythonUtilityGenerators: () => (/* reexport module object */ _generators_utility__WEBPACK_IMPORTED_MODULE_25__),
/* harmony export */   PythonVariablesBlocks: () => (/* reexport module object */ _blocks_variables__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   PythonVariablesGenerators: () => (/* reexport module object */ _generators_variables__WEBPACK_IMPORTED_MODULE_13__),
/* harmony export */   Variables: () => (/* reexport safe */ _others_variables__WEBPACK_IMPORTED_MODULE_28__["default"])
/* harmony export */ });
/* harmony import */ var _blocks_variables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blocks/variables */ "../python/blocks/variables.js");
/* harmony import */ var _blocks_control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blocks/control */ "../python/blocks/control.js");
/* harmony import */ var _blocks_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blocks/math */ "../python/blocks/math.js");
/* harmony import */ var _blocks_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./blocks/text */ "../python/blocks/text.js");
/* harmony import */ var _blocks_lists__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./blocks/lists */ "../python/blocks/lists.js");
/* harmony import */ var _blocks_dicts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./blocks/dicts */ "../python/blocks/dicts.js");
/* harmony import */ var _blocks_logic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./blocks/logic */ "../python/blocks/logic.js");
/* harmony import */ var _blocks_storage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./blocks/storage */ "../python/blocks/storage.js");
/* harmony import */ var _blocks_procedures__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./blocks/procedures */ "../python/blocks/procedures.js");
/* harmony import */ var _blocks_tuple__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./blocks/tuple */ "../python/blocks/tuple.js");
/* harmony import */ var _blocks_set__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./blocks/set */ "../python/blocks/set.js");
/* harmony import */ var _blocks_html__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./blocks/html */ "../python/blocks/html.js");
/* harmony import */ var _blocks_utility__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./blocks/utility */ "../python/blocks/utility.js");
/* harmony import */ var _generators_variables__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./generators/variables */ "../python/generators/variables.js");
/* harmony import */ var _generators_control__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./generators/control */ "../python/generators/control.js");
/* harmony import */ var _generators_math__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./generators/math */ "../python/generators/math.js");
/* harmony import */ var _generators_text__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./generators/text */ "../python/generators/text.js");
/* harmony import */ var _generators_lists__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./generators/lists */ "../python/generators/lists.js");
/* harmony import */ var _generators_dicts__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./generators/dicts */ "../python/generators/dicts.js");
/* harmony import */ var _generators_logic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./generators/logic */ "../python/generators/logic.js");
/* harmony import */ var _generators_storage__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./generators/storage */ "../python/generators/storage.js");
/* harmony import */ var _generators_procedures__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./generators/procedures */ "../python/generators/procedures.js");
/* harmony import */ var _generators_tuple__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./generators/tuple */ "../python/generators/tuple.js");
/* harmony import */ var _generators_set__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./generators/set */ "../python/generators/set.js");
/* harmony import */ var _generators_html__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./generators/html */ "../python/generators/html.js");
/* harmony import */ var _generators_utility__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./generators/utility */ "../python/generators/utility.js");
/* harmony import */ var _others_names__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./others/names */ "../python/others/names.js");
/* harmony import */ var _others_procedures__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./others/procedures */ "../python/others/procedures.js");
/* harmony import */ var _others_variables__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./others/variables */ "../python/others/variables.js");
/* harmony import */ var _python_generator__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./python_generator */ "../python/python_generator.js");



































/***/ }),

/***/ "../python/generators/control.js":
/*!***************************************!*\
  !*** ../python/generators/control.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Panic_with_status_code: () => (/* binding */ Panic_with_status_code),
/* harmony export */   base_setup: () => (/* binding */ base_setup),
/* harmony export */   controls_delay: () => (/* binding */ controls_delay),
/* harmony export */   controls_flow_statements: () => (/* binding */ controls_flow_statements),
/* harmony export */   controls_for: () => (/* binding */ controls_for),
/* harmony export */   controls_forEach: () => (/* binding */ controls_forEach),
/* harmony export */   controls_for_range: () => (/* binding */ controls_for_range),
/* harmony export */   controls_if: () => (/* binding */ controls_if),
/* harmony export */   controls_interrupts: () => (/* binding */ controls_interrupts),
/* harmony export */   controls_lambda: () => (/* binding */ controls_lambda),
/* harmony export */   controls_main: () => (/* binding */ controls_main),
/* harmony export */   controls_millis: () => (/* binding */ controls_millis),
/* harmony export */   controls_nointerrupts: () => (/* binding */ controls_nointerrupts),
/* harmony export */   controls_pass: () => (/* binding */ controls_pass),
/* harmony export */   controls_range: () => (/* binding */ controls_range),
/* harmony export */   controls_repeat: () => (/* binding */ controls_repeat),
/* harmony export */   controls_repeat_ext: () => (/* binding */ controls_repeat_ext),
/* harmony export */   controls_thread: () => (/* binding */ controls_thread),
/* harmony export */   controls_try_finally: () => (/* binding */ controls_try_finally),
/* harmony export */   controls_whileUntil: () => (/* binding */ controls_whileUntil),
/* harmony export */   datetime_fromtimestamp: () => (/* binding */ datetime_fromtimestamp),
/* harmony export */   do_while: () => (/* binding */ do_while),
/* harmony export */   garbage_collection: () => (/* binding */ garbage_collection),
/* harmony export */   get_mem_alloc: () => (/* binding */ get_mem_alloc),
/* harmony export */   get_mem_free: () => (/* binding */ get_mem_free),
/* harmony export */   get_unique_identifier: () => (/* binding */ get_unique_identifier),
/* harmony export */   reset: () => (/* binding */ reset),
/* harmony export */   time_sleep: () => (/* binding */ time_sleep)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const controls_main = function (a, generator) {
    var d = generator.statementToCode(a, "DO"),
        d = generator.addLoopTrap(d, a.id) || generator.PASS;
    return "if __name__ == '__main__':\n" + d;
}

const base_setup = function (_, generator) {
    var branch = generator.statementToCode(this, 'DO');
    branch = branch.replace(/(^\s*)|(\s*$)/g, "").replace(/\n {4}/g, '\n');//去除两端空格
    if (branch.endsWith('\n')) {
        generator.setups_['setup_setup'] = branch;
    }
    else {
        generator.setups_['setup_setup'] = branch + '\n';
    }
    return '';
}

// ok
const controls_if = function (a, generator) {
    var b = 0,
        c = "",
        d,
        e;
    do
        e = generator.valueToCode(a, "IF" + b, generator.ORDER_NONE) || "False", d = generator.statementToCode(a, "DO" + b) || generator.PASS, c += (0 == b ? "if " : "elif ") + e + ":\n" + d, ++b;
    while (a.getInput("IF" + b));
    a.getInput("ELSE") && (d = generator.statementToCode(a, "ELSE") || generator.PASS, c += "else:\n" + d);
    return c
}

const controls_try_finally = function (_, generator) {
    var n = 0;
    var argument = generator.valueToCode(this, 'IF' + n,
        generator.ORDER_NONE) || 'null';
    var branch = '';
    var t = generator.statementToCode(this, 'try') || '    pass\n';
    var code = 'try:\n' + t;
    for (n = 1; n <= this.elseifCount_; n++) {
        argument = generator.valueToCode(this, 'IF' + n,
            generator.ORDER_NONE) || '';
        if (argument !== '')
            argument = ' ' + argument
        branch = generator.statementToCode(this, 'DO' + n) || '    pass\n';
        code += 'except' + argument + ': \n' + branch;
    }
    if (this.elseCount_) {
        branch = generator.statementToCode(this, 'ELSE') || '    pass\n';
        code += 'finally:\n' + branch;
    }
    // code += '}';
    return code;
}

// ok
const controls_for = function (a, generator) {
    var b = generator.variableDB_.getName(a.getFieldValue("VAR"), blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE),
        //var b = generator.valueToCode(a, "VAR", generator.ORDER_MEMBER) || "''",
        c = generator.valueToCode(a, "FROM", generator.ORDER_NONE) || "0",
        d = generator.valueToCode(a, "TO", generator.ORDER_NONE) || "0",
        e = generator.valueToCode(a, "STEP", generator.ORDER_NONE) || "1",
        f = generator.statementToCode(a, "DO"),
        f = generator.addLoopTrap(f, a.id) || generator.PASS,
        g = "",
        h = function (_, generator) {
            return generator.provideFunction_("upRange",
                ["def " + generator.FUNCTION_NAME_PLACEHOLDER_ + "(start, stop, step):", "  while start <= stop:", "    yield start", "    start += abs(step)"])
        },
        k = function (_, generator) {
            return generator.provideFunction_("downRange", ["def " + generator.FUNCTION_NAME_PLACEHOLDER_ + "(start, stop, step):", "  while start >= stop:", "    yield start", "    start -= abs(step)"])
        }
    a = function (a, b, c) {
        return "(" + a + " <= " + b + ") and " + h() + "(" + a + ", " + b + ", " + c + ") or " + k() + "(" + a + ", " + b + ", " + c + ")"
    }
    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.isNumber(c) && blockly_core__WEBPACK_IMPORTED_MODULE_0__.isNumber(d) &&
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.isNumber(e))
        c = parseFloat(c), d = parseFloat(d), e = Math.abs(parseFloat(e)), 0 === c % 1 && 0 === d % 1 && 0 === e % 1 ? (c <= d ? (d++, a = 0 == c && 1 == e ? d : c + ", " + d, 1 != e && (a += ", " + e)) : (d--, a = c + ", " + d + ", -" + e), a = "range(" + a + ")") : (a = c < d ? h() : k(), a += "(" + c + ", " + d + ", " + e + ")");
    else {
        var l = function (a, c) {
                if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.isNumber(a))
                    a = parseFloat(a);
                else {
                    var d = generator.variableDB_.getDistinctName(b + c, blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
                    g += d + " = " + a + "\n";
                    a = d
                }
                return a
            },
            c = l(c, "_start"),
            d = l(d, "_end");
        l(e, "_inc");
        a = "number" == typeof c && "number" == typeof d ? c < d ? h(c, d, e) : k(c, d, e) : a(c, d, e)
    }
    return g += "for " + b + " in " + a + ":\n" + f
}

const controls_for_range = function (block, generator) {
    var iter = generator.variableDB_.getName(block.getFieldValue("VAR"), blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE),
        from = generator.valueToCode(block, "FROM", generator.ORDER_NONE) || "0",
        end = generator.valueToCode(block, "TO", generator.ORDER_NONE) || "0",
        step = generator.valueToCode(block, "STEP", generator.ORDER_NONE) || "1",
        dostatement = generator.statementToCode(block, "DO"),
        pass = generator.addLoopTrap(dostatement, block.id) || generator.PASS;
    generator.setups_["mixly_range"] = "def mixly_range(start, stop, step):\n" +
        "    for i in range(start, stop + 1, step):\n" +
        "        yield i\n\n";
    return "for " + iter + " in mixly_range(" + from + ", " + end + ", " + step + "):\n" + pass;
}

const controls_whileUntil = function (a, generator) {
    var b = "UNTIL" == a.getFieldValue("MODE"),
        c = generator.valueToCode(a, "BOOL", generator.ORDER_NONE) || "False",
        d = generator.statementToCode(a, "DO"),
        d = generator.addLoopTrap(d, a.id) || generator.PASS;
    b && (c = "not " + c);
    return "while " + c + ":\n" + d
}

// export const controls_flow_statements = function (_, generator) {
//     // Flow statements: continue, break.
//     switch (this.getFieldValue('FLOW')) {
//         case 'BREAK':
//             return 'break;\n';
//         case 'CONTINUE':
//             return 'continue;\n';
//     }
//     throw 'Unknown flow statement.';
// }

//ok
const controls_flow_statements = function (a) {
    switch (a.getFieldValue("FLOW")) {
        case "BREAK":
            return "break\n";
        case "CONTINUE":
            return "continue\n"
    }
    throw "Unknown flow statement.";
}

// ok
const controls_delay = function (_, generator) {
    var delay_time = generator.valueToCode(this, 'DELAY_TIME', generator.ORDER_ATOMIC) || '1000'
    var code = 'sleep(' + delay_time + ')\n';
    return code;
}

// ok
const Panic_with_status_code = function (_, generator) {
    var status_code = generator.valueToCode(this, 'STATUS_CODE', generator.ORDER_ATOMIC) || '1000'
    var code = 'panic(' + status_code + ')\n';
    return code;
}

// ok
const controls_millis = function (_, generator) {
    generator.definitions_.import_time = "import time";
    var code = 'time.time()';
    return [code, generator.ORDER_ATOMIC];
}

// ok
const reset = function (_, generator) {
    generator.definitions_['import_microbit'] = 'from microbit import *'
    return 'reset()\n';
}
const controls_interrupts = function () {
    return 'interrupts();\n';
}

const controls_nointerrupts = function () {
    return 'noInterrupts();\n';
}


const controls_forEach = function (block, generator) {
    // For each loop.
    var variable0 = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '\'\'';
    var argument0 = generator.valueToCode(block, 'LIST',
        generator.ORDER_RELATIONAL) || '[]';
    var branch = generator.statementToCode(block, 'DO');
    branch = generator.addLoopTrap(branch, block.id) ||
        generator.PASS;
    var code = 'for ' + variable0 + ' in ' + argument0 + ':\n' + branch;
    return code;
}

const controls_range = function (_, generator) {
    var from = generator.valueToCode(this, "FROM", generator.ORDER_NONE) || "0";
    var end = generator.valueToCode(this, "TO", generator.ORDER_NONE) || "0";
    var step = generator.valueToCode(this, "STEP", generator.ORDER_NONE) || "1";
    var code = "range(" + from + ", " + end + ", " + step + ")";
    return [code, generator.ORDER_ATOMIC];
}

const controls_lambda = function (a, generator) {
    var c = generator.valueToCode(a, "BOOL", generator.ORDER_NONE) || "None",
        d = generator.statementToCode(a, "DO") || "pass";
    var code = "lambda " + c + ": " + d;
    code = code.replace('\n', '').replace('    ', '')
    return [code, generator.ORDER_ATOMIC];
}

const time_sleep = function (_, generator) {
    generator.definitions_['import_time'] = 'import time';
    var delay_time = generator.valueToCode(this, 'DELAY_TIME', generator.ORDER_ATOMIC) || '1000'
    var code = 'time.sleep(' + delay_time + ')\n';
    return code;
}

const controls_pass = function () {
    return 'pass\n';
}

const controls_thread = function (_, generator) {
    generator.definitions_['import__thread'] = 'import _thread';
    var v = generator.valueToCode(this, "VAR", generator.ORDER_NONE) || "None";
    var callback = generator.variableDB_.getName(
        generator.valueToCode(this, "callback", generator.ORDER_NONE) || "None",
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Procedures.NAME_TYPE
    );
    var code = "_thread.start_new_thread(" + callback + ", " + v + ")\n";
    return code;
}

// do-while循环
const do_while = function (_, generator) {
    var value_select_data = generator.valueToCode(this, 'select_data', generator.ORDER_NONE) || "False";
    var statements_input_data = generator.statementToCode(this, 'input_data')
    var dropdown_type = this.getFieldValue('type');
    if (dropdown_type == 'true') {
        statements_input_data = statements_input_data + '    if (' + value_select_data + '):\n' + '        break\n';
    }
    else {
        statements_input_data = statements_input_data + '    if not (' + value_select_data + '):\n' + '        break\n';
    }
    statements_input_data = generator.addLoopTrap(statements_input_data, this.id) || generator.PASS;
    //var dropdown_type = this.getFieldValue('type');
    var code = 'while True:\n' + statements_input_data;
    return code;
}

// export const base_type = controls_type;
// export const controls_TypeLists = controls_typeLists;

const controls_repeat_ext = function (a, generator) {
    var times = generator.valueToCode(this, 'TIMES', generator.ORDER_ATOMIC);
    var d = generator.statementToCode(a, "DO"),
        d = generator.addLoopTrap(d, a.id) || generator.PASS;
    return 'for _my_variable in range(' + times + '):\n' + d;
}


const garbage_collection = function (_, generator) {
    generator.definitions_['import_gc'] = 'import gc';
    var code = 'gc.collect()\n'
    return code;
}

const get_mem_alloc = function (_, generator) {
    generator.definitions_['import_gc'] = 'import gc';
    var code = 'gc.mem_alloc()';
    return [code, generator.ORDER_ATOMIC];
}

const get_mem_free = function (_, generator) {
    generator.definitions_['import_gc'] = 'import gc';
    var code = 'gc.mem_free()';
    return [code, generator.ORDER_ATOMIC]
}

const get_unique_identifier = function (_, generator) {
    generator.definitions_['import_machine'] = 'import machine';
    var code = 'machine.unique_id()';
    return [code, generator.ORDER_ATOMIC];
}

// ok
const controls_repeat = controls_repeat_ext;

const datetime_fromtimestamp = function(_,generator){
    generator.definitions_['import_datatime'] = 'import datatime';
    var ts = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = 'datatime.datatime.fromtimestamp(' + ts + ')';
    return [code, generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python/generators/dicts.js":
/*!*************************************!*\
  !*** ../python/generators/dicts.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dicts_add_change_del: () => (/* binding */ dicts_add_change_del),
/* harmony export */   dicts_add_or_change: () => (/* binding */ dicts_add_or_change),
/* harmony export */   dicts_clear: () => (/* binding */ dicts_clear),
/* harmony export */   dicts_create_with: () => (/* binding */ dicts_create_with),
/* harmony export */   dicts_create_with_noreturn: () => (/* binding */ dicts_create_with_noreturn),
/* harmony export */   dicts_deldict: () => (/* binding */ dicts_deldict),
/* harmony export */   dicts_delete: () => (/* binding */ dicts_delete),
/* harmony export */   dicts_get: () => (/* binding */ dicts_get),
/* harmony export */   dicts_get_default: () => (/* binding */ dicts_get_default),
/* harmony export */   dicts_items: () => (/* binding */ dicts_items),
/* harmony export */   dicts_keys: () => (/* binding */ dicts_keys),
/* harmony export */   dicts_length: () => (/* binding */ dicts_length),
/* harmony export */   dicts_pop: () => (/* binding */ dicts_pop),
/* harmony export */   dicts_setdefault: () => (/* binding */ dicts_setdefault),
/* harmony export */   dicts_to_json: () => (/* binding */ dicts_to_json),
/* harmony export */   dicts_to_to: () => (/* binding */ dicts_to_to),
/* harmony export */   dicts_todict: () => (/* binding */ dicts_todict),
/* harmony export */   dicts_update: () => (/* binding */ dicts_update),
/* harmony export */   dicts_values: () => (/* binding */ dicts_values),
/* harmony export */   json_to_dicts: () => (/* binding */ json_to_dicts)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Visual Blocks Language
 *
 * Copyright 2012 Google Inc.
 * https://developers.google.com/blockly/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Generating Python for dictionary blocks.
 * @author acbart@vt.edu (Austin Cory Bart)
 */


const dicts_create_with = function (_, generator) {
    // Create a list with any number of elements of any type.
    //var dropdown_type = this.getFieldValue('TYPE');
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    //var size=window.parseFloat(this.getFieldValue('SIZE'));
    var code = new Array(this.itemCount_);
    var default_value = '0';
    for (var n = 0; n < this.itemCount_; n++) {
        var keyName = this.getFieldValue('KEY' + n);
        code[n] = keyName + ":" + (generator.valueToCode(this, 'ADD' + n, generator.ORDER_NONE) || default_value);
    }
    var code = varName + '= ' + '{' + code.join(', ') + '}\n';
    //var code =''+varName+'['+size+"]"+'='+ '{' + code.join(', ') + '}\n';
    //generator.setups_['setup_lists'+varName] = code;
    return code;
}

const dicts_keys = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.keys()';
    return [code, generator.ORDER_ATOMIC];
}

const dicts_get = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    //var size=window.parseFloat(this.getFieldValue('SIZE'));
    var text = generator.valueToCode(this, 'KEY', generator.ORDER_ASSIGNMENT);
    // var text=this.getFieldValue('KEY');
    var code = varName + "[" + text + "]";
    return [code, generator.ORDER_ATOMIC];
}

const dicts_get_default = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    //var size=window.parseFloat(this.getFieldValue('SIZE'));
    var text = generator.valueToCode(this, 'KEY', generator.ORDER_ASSIGNMENT);
    var argument = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    // var text=this.getFieldValue('KEY');
    var code = varName + ".get(" + text + ',' + argument + ")";
    return [code, generator.ORDER_ATOMIC];
}

const dicts_add_or_change = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || 'mydict';
    var text = generator.valueToCode(this, 'KEY', generator.ORDER_ASSIGNMENT);
    // var text=this.getFieldValue('KEY');
    var argument = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + "[" + text + "] = " + argument + '\n';
    return code;
}

const dicts_delete = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || 'mydict';
    var text = generator.valueToCode(this, 'KEY', generator.ORDER_ASSIGNMENT);
    // var text=this.getFieldValue('KEY');
    var code = "del " + varName + "[" + text + "]\n";
    return code;
}

const dicts_update = function (_, generator) {
    var varName2 = generator.valueToCode(this, 'DICT2', generator.ORDER_ASSIGNMENT) || '0';
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.update(' + varName2 + ')\n';
    return code;
}

const dicts_clear = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.clear()\n';
    return code;
}

const dicts_items = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.items()';
    return [code, generator.ORDER_ATOMIC];
}

const dicts_values = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.values()';
    return [code, generator.ORDER_ATOMIC];
}

const dicts_length = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'len(' + varName + ')';
    return [code, generator.ORDER_ATOMIC];
}

const dicts_deldict = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'del ' + varName + '\n';
    return code;
}

const dicts_add_change_del = function (block, generator) {
    var dict = generator.valueToCode(block, 'DICT',
        generator.ORDER_MEMBER) || '[]';
    var mode = block.getFieldValue('WHERE');
    var KEY = generator.valueToCode(this, 'KEY', generator.ORDER_ASSIGNMENT);
    // var text=this.getFieldValue('KEY');

    switch (mode) {
        case 'INSERT':
            //var at2 = block.getFieldValue('AT2');
            var at2 = generator.valueToCode(this, 'AT2', generator.ORDER_ASSIGNMENT) || '0';
            var code = dict + "[" + KEY + "] = " + at2 + '\n'
            break;
        case 'DELETE':
            var code = 'del ' + dict + "[" + KEY + "]\n"
            break;
        default:
            throw 'Unhandled option (lists_setIndex2)';
    }
    return code;
}

const dicts_pop = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var text = generator.valueToCode(this, 'KEY', generator.ORDER_ASSIGNMENT);
    // var text=this.getFieldValue('KEY');
    var code = varName + ".pop(" + text + ")";
    return [code, generator.ORDER_ATOMIC];
}

const dicts_setdefault = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || 'mydict';
    var text = generator.valueToCode(this, 'KEY', generator.ORDER_ASSIGNMENT);
    // var text=this.getFieldValue('KEY');
    var argument = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + ".setdefault" + "(" + text + "," + argument + ")\n";
    return code;
}

const dicts_create_with_noreturn = function (_, generator) {
    // Create a list with any number of elements of any type.
    // var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
    //  Blockly.Variables.NAME_TYPE);
    //var size=window.parseFloat(this.getFieldValue('SIZE'));
    var code = new Array(this.itemCount_);
    var default_value = '0';

    for (var n = 0; n < this.itemCount_; n++) {
        var keyName = this.getFieldValue('KEY' + n);
        code[n] = keyName + ":" + (generator.valueToCode(this, 'ADD' + n, generator.ORDER_NONE) || default_value);
    }
    // if (this.itemCount_!=1){
    //  generator.definitions_['var_declare'+varName] = varName+'= '+ '(' + code.join(', ') + ')\n';}
    // else {
    // generator.definitions_['var_declare'+varName] = varName+'= '+ '(' + code.join(', ') + ',)\n';}
    if (this.itemCount_ != 1) {
        var code = '{' + code.join(', ') + '}';
    }
    else {
        var code = '{' + code.join(', ') + ',}';
    }

    return [code, generator.ORDER_ATOMIC];
}

const dicts_todict = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0'
    return ['dict(' + str + ')', generator.ORDER_ATOMIC];
}

const dicts_to_json = function (_, generator) {
    generator.definitions_['import_json'] = 'import json';
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'json.dumps(' + varName + ')';
    return [code, generator.ORDER_ATOMIC];
}

const json_to_dicts = function (_, generator) {
    generator.definitions_['import_json'] = 'import json';
    var varName = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || 'null';
    var code = 'json.loads(' + varName + ')';
    return [code, generator.ORDER_ATOMIC];
}

const dicts_to_to = function (_, generator) {
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var R = generator.valueToCode(this, 'VAR1', generator.ORDER_ASSIGNMENT) || 'null';
    var I = generator.valueToCode(this, 'VAR2', generator.ORDER_ASSIGNMENT) || 'null';
    var L = generator.valueToCode(this, 'VAR3', generator.ORDER_ASSIGNMENT) || 'null';
    var N = generator.valueToCode(this, 'VAR4', generator.ORDER_ASSIGNMENT) || 'null';
    var code = varName + '['+R+']'+'['+I+']'+'['+L+']'+'['+N+']';
    return [code, generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python/generators/html.js":
/*!************************************!*\
  !*** ../python/generators/html.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   html_content: () => (/* binding */ html_content),
/* harmony export */   html_content_more: () => (/* binding */ html_content_more),
/* harmony export */   html_document: () => (/* binding */ html_document),
/* harmony export */   html_form: () => (/* binding */ html_form),
/* harmony export */   html_head_body: () => (/* binding */ html_head_body),
/* harmony export */   html_style: () => (/* binding */ html_style),
/* harmony export */   html_style_content: () => (/* binding */ html_style_content),
/* harmony export */   html_text: () => (/* binding */ html_text),
/* harmony export */   html_title: () => (/* binding */ html_title)
/* harmony export */ });
const html_document = function (_, generator) {
    var head = generator.statementToCode(this, 'HEAD');
    var body = generator.statementToCode(this, 'BODY');
    var code = "'''<!DOCTYPE HTML>\n<html>\n<head>\n" + '\t<meta charset="utf-8">\n' + head + "</head>\n<body>\n" + body + "</body>\n</html>\n'''";
    return [code, generator.ORDER_ATOMIC];
}

const html_title = function (_, generator) {
    var t = generator.statementToCode(this, 'DO');
    var l = this.getFieldValue('LEVEL');
    var code = "<h" + l + ">\n" + t + "</h" + l + ">\n";
    return code;
}

const html_head_body = function (_, generator) {
    var t = generator.statementToCode(this, 'DO');
    var l = this.getFieldValue('LEVEL');
    if (l == 'head') {
        var code = "<" + l + '>\n\t<meta charset="utf-8">\n' + t + "</" + l + ">\n";
    }
    else {
        var code = "<" + l + ">\n" + t + "</" + l + ">\n";
    }
    return code;
}

const html_content = function (_, generator) {
    var t = generator.statementToCode(this, 'DO');
    // var s = generator.valueToCode(this, 'style');
    var l = this.getFieldValue('LEVEL');
    // var code = "<" + l + " " + s + " >\n" + t + "</" + l + ">\n";
    var code = "<" + l + ">\n" + t + "</" + l + ">\n";
    return code;
}

const html_content_more = function (_, generator) {
    var t = generator.statementToCode(this, 'DO');
    var s = generator.valueToCode(this, 'style');
    var l = this.getFieldValue('LEVEL');
    var code = "<" + l + " " + s + " >\n" + t + "</" + l + ">\n";
    return code;
}

const html_style = function (_, generator) {
    var style = generator.statementToCode(this, 'STYLE');
    var code = 'style="' + style + '"';
    return [code, generator.ORDER_ATOMIC];
}

const html_form = function (_, generator) {
    var tag = this.getFieldValue('LEVEL');
    var name = this.getFieldValue('NAME');
    var value = this.getFieldValue('VALUE');
    var s = generator.valueToCode(this, 'style') || "";
    var code = '<input type="' + tag + '" name="' + name + '" value="' + value + '" ' + s + ' />';
    return code;
}

const html_style_content = function () {
    var key = this.getFieldValue('KEY');
    var value = this.getFieldValue('VALUE');
    var code = key + ':' + value + ";";
    return code;
}

const html_text = function () {
    var text = this.getFieldValue('TEXT');
    var code = text + "\n";
    return code;
}

/***/ }),

/***/ "../python/generators/lists.js":
/*!*************************************!*\
  !*** ../python/generators/lists.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   enumerate: () => (/* binding */ enumerate),
/* harmony export */   list_many_input: () => (/* binding */ list_many_input),
/* harmony export */   list_tolist: () => (/* binding */ list_tolist),
/* harmony export */   list_tolist2: () => (/* binding */ list_tolist2),
/* harmony export */   list_trig: () => (/* binding */ list_trig),
/* harmony export */   lists_2d_get_col_row_data: () => (/* binding */ lists_2d_get_col_row_data),
/* harmony export */   lists_2d_get_data_with_col_row: () => (/* binding */ lists_2d_get_data_with_col_row),
/* harmony export */   lists_append_extend: () => (/* binding */ lists_append_extend),
/* harmony export */   lists_change_to: () => (/* binding */ lists_change_to),
/* harmony export */   lists_change_to_general: () => (/* binding */ lists_change_to_general),
/* harmony export */   lists_clear: () => (/* binding */ lists_clear),
/* harmony export */   lists_create_with: () => (/* binding */ lists_create_with),
/* harmony export */   lists_create_with2: () => (/* binding */ lists_create_with2),
/* harmony export */   lists_create_with_noreturn: () => (/* binding */ lists_create_with_noreturn),
/* harmony export */   lists_create_with_text: () => (/* binding */ lists_create_with_text),
/* harmony export */   lists_create_with_text2: () => (/* binding */ lists_create_with_text2),
/* harmony export */   lists_del_general: () => (/* binding */ lists_del_general),
/* harmony export */   lists_find: () => (/* binding */ lists_find),
/* harmony export */   lists_getIndex3: () => (/* binding */ lists_getIndex3),
/* harmony export */   lists_getSublist3: () => (/* binding */ lists_getSublist3),
/* harmony export */   lists_get_index: () => (/* binding */ lists_get_index),
/* harmony export */   lists_get_random_item: () => (/* binding */ lists_get_random_item),
/* harmony export */   lists_get_random_sublist: () => (/* binding */ lists_get_random_sublist),
/* harmony export */   lists_get_sublist: () => (/* binding */ lists_get_sublist),
/* harmony export */   lists_insert_value: () => (/* binding */ lists_insert_value),
/* harmony export */   lists_insert_value2: () => (/* binding */ lists_insert_value2),
/* harmony export */   lists_pop: () => (/* binding */ lists_pop),
/* harmony export */   lists_remove_at: () => (/* binding */ lists_remove_at),
/* harmony export */   lists_remove_at2: () => (/* binding */ lists_remove_at2),
/* harmony export */   lists_reverse: () => (/* binding */ lists_reverse),
/* harmony export */   lists_setIndex3: () => (/* binding */ lists_setIndex3),
/* harmony export */   lists_set_index: () => (/* binding */ lists_set_index),
/* harmony export */   lists_sort: () => (/* binding */ lists_sort)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const lists_get_sublist = function (_, generator) {
    // Get sublist.
    var list = generator.valueToCode(this, 'LIST', generator.ORDER_ADDITIVE) || 'mylist';
    var at1 = generator.valueToCode(this, 'AT1', generator.ORDER_ADDITIVE);
    var at2 = generator.valueToCode(this, 'AT2', generator.ORDER_ADDITIVE);
    var code = list + '[' + at1 + ' : ' + at2 + ']';
    return [code, generator.ORDER_ATOMIC];
}

const lists_2d_get_data_with_col_row = function (_, generator) {
    var value_LIST = generator.valueToCode(this, 'LIST', generator.ORDER_ATOMIC) || 'mylist';
    var value_row = generator.valueToCode(this, 'row', generator.ORDER_ATOMIC) || 0;
    var value_col = generator.valueToCode(this, 'col', generator.ORDER_ATOMIC) || 0;
    var code = value_LIST + '[' + value_row + ',' + value_col + ']';
    return [code, generator.ORDER_ATOMIC];
}

const lists_2d_get_col_row_data = function (_, generator) {
    var value_LIST = generator.valueToCode(this, 'LIST', generator.ORDER_ATOMIC) || 'mylist';
    var value_row_start = generator.valueToCode(this, 'row_start', generator.ORDER_ATOMIC) || 0;
    var value_row_end = generator.valueToCode(this, 'row_end', generator.ORDER_ATOMIC) || 1;
    var value_col_start = generator.valueToCode(this, 'col_start', generator.ORDER_ATOMIC) || 0;
    var value_col_end = generator.valueToCode(this, 'col_end', generator.ORDER_ATOMIC) || 1;
    var code = value_LIST + '[' + value_row_start + ' : ' + value_row_end + ',' + value_col_start + ' : ' + value_col_end + ']';
    return [code, generator.ORDER_ATOMIC];
}

const lists_create_with = function (_, generator) {
    // Create a list with any number of elements of any type.
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    //var size=window.parseFloat(this.getFieldValue('SIZE'));
    var code = new Array(this.itemCount_);
    var default_value = '0';
    for (var n = 0; n < this.itemCount_; n++) {
        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || default_value;
    }
    //generator.setups_['var_declare'+varName] = varName+' = '+ '[' + code.join(', ') + ']\n';
    var code = varName + ' = ' + '[' + code.join(', ') + ']\n';
    return code;
}

const lists_create_with_text = function (_, generator) {
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    //var size=window.parseFloat(this.getFieldValue('SIZE'));
    var text = this.getFieldValue('TEXT');
    // generator.setups_['var_declare'+varName] = varName+' = '+ '[' + text + ']\n';
    var code = varName + ' = ' + '[' + text + ']\n';
    return code;
}

const lists_get_index = function (_, generator) {
    // Indexing into a list is the same as indexing into a string.
    var list = generator.valueToCode(this, 'LIST', generator.ORDER_ADDITIVE) || 'mylist';
    var argument0 = generator.valueToCode(this, 'AT', generator.ORDER_ADDITIVE) || 0;
    var code = list + '[' + argument0 + ']';
    return [code, generator.ORDER_ATOMIC];
}

const lists_set_index = function (_, generator) {
    // Set element at index.
    var varName = generator.valueToCode(this, 'LIST', generator.ORDER_ADDITIVE) || 'mylist';
    var argument0 = generator.valueToCode(this, 'AT',
        generator.ORDER_ADDITIVE) || '0';
    var argument2 = generator.valueToCode(this, 'TO',
        generator.ORDER_ASSIGNMENT) || '0';
    // Blockly uses one-based indicies.
    return varName + '[' + argument0 + '] = ' + argument2 + '\n';
}

const lists_append_extend = function (_, generator) {
    var varName = generator.valueToCode(this, 'LIST', generator.ORDER_ASSIGNMENT) || '0';
    var argument = generator.valueToCode(this, 'DATA', generator.ORDER_ASSIGNMENT) || '0';
    var op = this.getFieldValue('OP');
    var code = varName + '.' + op + '(' + argument + ')\n';
    return code;
}

const lists_get_random_item = function (_, generator) {
    generator.definitions_['import_random'] = 'import random';
    var varName = generator.valueToCode(this, 'LIST', generator.ORDER_ADDITIVE) || 'mylist';
    var code = 'random.choice(' + varName + ')';
    return [code, generator.ORDER_ATOMIC];
}

const lists_get_random_sublist = function (_, generator) {
    generator.definitions_['import_random'] = 'import random';
    var varName = generator.valueToCode(this, 'LIST', generator.ORDER_ADDITIVE) || 'mylist';
    var VALUE = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'random.sample(' + varName + ',' + VALUE + ')';
    return [code, generator.ORDER_ATOMIC];
}

const lists_insert_value = function (_, generator) {
    var varName = generator.valueToCode(this, 'LIST', generator.ORDER_ASSIGNMENT) || '0';
    var at = generator.valueToCode(this, 'AT', generator.ORDER_ADDITIVE) || '0';
    var VALUE = generator.valueToCode(this, 'VALUE', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.insert(' + at + ', ' + VALUE + ')\n';
    return code;
}

const lists_reverse = function (_, generator) {
    var varName = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.reverse()\n';
    return code;
}
const lists_clear = function (_, generator) {
    var varName = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.clear()\n';
    return code;
}

const lists_find = function (_, generator) {
    var op = this.getFieldValue('OP');
    var varName = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var argument = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    if (op == 'INDEX')
        var code = varName + '.index(' + argument + ')';
    else if (op == 'COUNT')
        var code = varName + '.count(' + argument + ')';
    return [code, generator.ORDER_ATOMIC];
}

const lists_remove_at = function (_, generator) {
    var varName = generator.valueToCode(this, 'LIST', generator.ORDER_ASSIGNMENT) || '0';
    var argument = generator.valueToCode(this, 'DATA', generator.ORDER_ASSIGNMENT) || '0';
    var op = this.getFieldValue('OP');
    var code = "";
    if (op == "del") {
        code = 'del ' + varName + '[' + argument + ']\n';
    } else {
        code = varName + '.remove' + '(' + argument + ')\n';
    }
    return code;
}

const lists_pop = function (_, generator) {
    var varName = generator.valueToCode(this, 'LIST', generator.ORDER_ADDITIVE) || 'mylist';
    var argument = generator.valueToCode(this, 'VALUE', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.pop(' + argument + ')';
    return [code, generator.ORDER_ATOMIC];
}

const list_trig = function (a, generator) {
    var b = a.getFieldValue("OP"), c;
    generator.definitions_['import_math'] = "import math";
    a = generator.valueToCode(a, 'data', generator.ORDER_NONE)
    switch (b) {
        case "LEN":
            c = "len(" + a + ")";
            break;
        case "SUM":
            c = "sum(" + a + ")";
            break;
        case "MIN":
            c = "min(" + a + ")";
            break;
        case "MAX":
            c = "max(" + a + ")";
            break;
        case 'AVERAGE':
            generator.definitions_['import_mixpy_math_mean'] = "from mixpy import math_mean";
            c = 'math_mean(' + a + ')';
            break;
        case 'MEDIAN':
            generator.definitions_['import_mixpy_math_median'] = "from mixpy import math_median";
            c = 'math_median(' + a + ')';
            break;
        case 'MODE':
            generator.definitions_['import_mixpy_math_modes'] = "from mixpy import math_modes";
            c = 'math_modes(' + a + ')';
            break;
        case 'STD_DEV':
            generator.definitions_['import_mixpy_math_standard_deviation'] = "from mixpy import math_standard_deviation";
            c = 'math_standard_deviation(' + a + ')';
            break;
        default:
            throw 'Unknown operator: ' + b;
    }
    if (c)
        return [c, generator.ORDER_ATOMIC];

}

const lists_sort = function (block, generator) {
    // Block for sorting a list.
    generator.definitions_['import_mixpy_lists_sort'] = "from mixpy import lists_sort";
    var list = (generator.valueToCode(block, 'LIST',
        generator.ORDER_NONE) || '[]');
    var type = block.getFieldValue('TYPE');
    var reverse = block.getFieldValue('DIRECTION') === '1' ? 'False' : 'True';
    var code = 'lists_sort(' + list + ', "' + type + '", ' + reverse + ')';
    return [code, generator.ORDER_ATOMIC];
}

const lists_change_to = function (_, generator) {
    var op = this.getFieldValue('OP');
    var varName = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var code = '';
    if (op == 'array') {
        generator.definitions_['import_numpy'] = 'import numpy';
        code = 'numpy.array(' + varName + ')';
    }
    else {
        code = op + '(' + varName + ')';
    }
    return [code, generator.ORDER_ATOMIC];
}

const list_many_input = function (_, generator) {
    var text = this.getFieldValue('CONTENT');
    var code = '[' + text + ']'
    return [code, generator.ORDER_ATOMIC];
}

const lists_create_with_noreturn = function (_, generator) {
    // Create a list with any number of elements of any type.
    var code = new Array(this.itemCount_);
    var default_value = '0';
    for (var n = 0; n < this.itemCount_; n++) {
        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || default_value;
    }
    var code = '[' + code.join(', ') + ']';
    return [code, generator.ORDER_ATOMIC];
}

const lists_change_to_general = lists_change_to;

const lists_del_general = function (_, generator) {
    var varName = generator.valueToCode(this, 'TUP', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'del ' + varName + '\n';
    return code;
}

const lists_create_with2 = lists_create_with
const lists_create_with_text2 = lists_create_with_text
const lists_getIndex3 = lists_get_index
const lists_getSublist3 = lists_get_sublist
const lists_setIndex3 = lists_set_index
const lists_insert_value2 = lists_insert_value
const lists_remove_at2 = lists_remove_at

const list_tolist = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0'
    return ['list(' + str + ')', generator.ORDER_ATOMIC];
}

const list_tolist2 = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0'
    return [str + '.tolist()', generator.ORDER_ATOMIC];
}

const enumerate = function (_, generator) {
    var varName = generator.valueToCode(this, 'LIST', generator.ORDER_ADDITIVE) || 'mylist';
    var argument = generator.valueToCode(this, 'VALUE', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'enumerate(' +varName+',start='+ argument + ')';
    return [code, generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python/generators/logic.js":
/*!*************************************!*\
  !*** ../python/generators/logic.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logic_boolean: () => (/* binding */ logic_boolean),
/* harmony export */   logic_compare: () => (/* binding */ logic_compare),
/* harmony export */   logic_compare_continous: () => (/* binding */ logic_compare_continous),
/* harmony export */   logic_is: () => (/* binding */ logic_is),
/* harmony export */   logic_is_in: () => (/* binding */ logic_is_in),
/* harmony export */   logic_negate: () => (/* binding */ logic_negate),
/* harmony export */   logic_null: () => (/* binding */ logic_null),
/* harmony export */   logic_operation: () => (/* binding */ logic_operation),
/* harmony export */   logic_tobool: () => (/* binding */ logic_tobool),
/* harmony export */   logic_true_or_false: () => (/* binding */ logic_true_or_false)
/* harmony export */ });
const logic_compare = function (_, generator) {
    // Comparison operator.
    var mode = this.getFieldValue('OP');
    var operator = logic_compare.OPERATORS[mode];
    var order = (operator == '==' || operator == '!=') ?
        generator.ORDER_EQUALITY : generator.ORDER_RELATIONAL;
    var argument0 = generator.valueToCode(this, 'A', order) || '0';
    var argument1 = generator.valueToCode(this, 'B', order) || '0';
    var code = argument0 + ' ' + operator + ' ' + argument1;
    return [code, order];
}

const logic_compare_continous = function (_, generator) {
    // Comparison operator.
    var mode1 = this.getFieldValue('OP1');
    var operator1 = logic_compare.OPERATORS[mode1];
    var mode2 = this.getFieldValue('OP2');
    var operator2 = logic_compare.OPERATORS[mode2];
    var argument0 = generator.valueToCode(this, 'A', generator.ORDER_RELATIONAL) || '0';
    var argument1 = generator.valueToCode(this, 'B', generator.ORDER_RELATIONAL) || '0';
    var argument2 = generator.valueToCode(this, 'C', generator.ORDER_RELATIONAL) || '0';
    var code = argument0 + ' ' + operator1 + ' ' + argument1 + ' ' + operator2 + ' ' + argument2;
    return [code, generator.ORDER_RELATIONAL];
}

logic_compare.OPERATORS = {
    EQ: '==',
    NEQ: '!=',
    LT: '<',
    LTE: '<=',
    GT: '>',
    GTE: '>='
};

const logic_operation = function (_, generator) {
    // Operations 'and', 'or'.
    var operator = this.getFieldValue('OP');
    var order = (operator == '&&') ? generator.ORDER_LOGICAL_AND :
        generator.ORDER_LOGICAL_OR;
    var argument0 = generator.valueToCode(this, 'A', order) || 'False';
    var argument1 = generator.valueToCode(this, 'B', order) || 'False';
    if (operator == 'AND') {
        var code = argument0 + ' and ' + argument1;
    } else if (operator == 'OR') {
        var code = argument0 + ' or ' + argument1;
    } else if (operator == 'NOR') {
        // var code = '('+argument0+' and '+argument1+' ) or ((not '+argument0+') and (not '+argument1+'))';
        var code = 'not(' + argument0 + '^' + argument1 + ')';
    } else {
        // var code = '((not '+argument0+') and '+argument1+' ) or ( '+argument0+' and (not '+argument1+'))';
        var code = argument0 + '^' + argument1;
    }
    return [code, order];
}

const logic_negate = function (_, generator) {
    // Negation.
    var order = generator.ORDER_UNARY_PREFIX;
    var argument0 = generator.valueToCode(this, 'BOOL', order) || 'False';
    var code = 'not ' + argument0;
    return [code, order];
}

const logic_boolean = function (_, generator) {
    // Boolean values true and false.
    var code = (this.getFieldValue('BOOL') == 'TRUE') ? 'True' : 'False';
    return [code, generator.ORDER_ATOMIC];
}

const logic_null = function (_, generator) {
    var code = 'None';
    return [code, generator.ORDER_ATOMIC];
}

const logic_true_or_false = function (_, generator) {
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || 'False';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || 'False';
    var c = generator.valueToCode(this, 'C', generator.ORDER_ATOMIC) || 'False';
    var code = '(' + b + ' if ' + a + ' else ' + c + ')';
    return [code, generator.ORDER_ATOMIC];
}

const logic_is_in = function (_, generator) {
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var bool = this.getFieldValue('BOOL');
    var code = a + ' ' + bool + ' ' + b;
    return [code, generator.ORDER_ATOMIC];
}

const logic_is = function (_, generator) {
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var bool = this.getFieldValue('BOOL');
    var code = a + ' ' + bool + ' ' + b;
    return [code, generator.ORDER_ATOMIC];
}

const logic_tobool = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0'
    return ['bool(' + str + ')', generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python/generators/math.js":
/*!************************************!*\
  !*** ../python/generators/math.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base_map: () => (/* binding */ base_map),
/* harmony export */   generate_cartesian_product: () => (/* binding */ generate_cartesian_product),
/* harmony export */   math_arithmetic: () => (/* binding */ math_arithmetic),
/* harmony export */   math_bit: () => (/* binding */ math_bit),
/* harmony export */   math_constant: () => (/* binding */ math_constant),
/* harmony export */   math_constant_mp: () => (/* binding */ math_constant_mp),
/* harmony export */   math_constrain: () => (/* binding */ math_constrain),
/* harmony export */   math_dec: () => (/* binding */ math_dec),
/* harmony export */   math_indexer_number: () => (/* binding */ math_indexer_number),
/* harmony export */   math_map: () => (/* binding */ math_map),
/* harmony export */   math_max_min: () => (/* binding */ math_max_min),
/* harmony export */   math_number: () => (/* binding */ math_number),
/* harmony export */   math_number_base_conversion: () => (/* binding */ math_number_base_conversion),
/* harmony export */   math_random: () => (/* binding */ math_random),
/* harmony export */   math_random_seed: () => (/* binding */ math_random_seed),
/* harmony export */   math_round: () => (/* binding */ math_round),
/* harmony export */   math_selfcalcu: () => (/* binding */ math_selfcalcu),
/* harmony export */   math_single: () => (/* binding */ math_single),
/* harmony export */   math_to_int: () => (/* binding */ math_to_int),
/* harmony export */   math_trig: () => (/* binding */ math_trig),
/* harmony export */   text_to_number: () => (/* binding */ text_to_number),
/* harmony export */   text_to_number_skulpt: () => (/* binding */ text_to_number_skulpt),
/* harmony export */   turn_to_int: () => (/* binding */ turn_to_int)
/* harmony export */ });
// export const math_number = function() {
//   // Numeric value.
//   var code = (this.getFieldValue('NUM'));
//   // -4.abs() returns -4 in Dart due to strange order of operation choices.
//   // -4 is actually an operator and a number.  Reflect this in the order.
//   var order = code < 0 ?
//       generator.ORDER_UNARY_PREFIX : generator.ORDER_ATOMIC;
//   return [code, order];
// }

// generator.math = {}
// generator.addReservedWords("math,random,Number");

const math_number = function (_, generator) {
    // a = parseFloat(a.getFieldValue("NUM"));
    // var b;
    // Infinity == a ? (a = 'float("inf")', b = generator.ORDER_FUNCTION_CALL) : -Infinity == a ? (a = '-float("inf")', b = generator.ORDER_UNARY_SIGN) : b = 0 > a ? generator.ORDER_UNARY_SIGN : generator.ORDER_ATOMIC;
    // return [a, b]

    var code = this.getFieldValue('NUM');
    // -4.abs() returns -4 in Dart due to strange order of operation choices.
    // -4 is actually an operator and a number.  Reflect this in the order.
    var order = code < 0 ?
        generator.ORDER_UNARY_PREFIX : generator.ORDER_ATOMIC;
    return [code, order];
}

const math_constant = function (_, generator) {
    generator.definitions_.import_math = "import math";
    var name = this.getFieldValue('CONSTANT');
    var code = 'math.' + name;
    return [code, generator.ORDER_ATOMIC];
}

const math_constant_mp = function (_, generator) {
    generator.definitions_.import_math = "import math";
    var name = this.getFieldValue('CONSTANT');
    var code = 'math.' + name;
    return [code, generator.ORDER_ATOMIC];
}

const math_bit = function (_, generator) {
    var operator = this.getFieldValue('OP');
    var order = generator.ORDER_ATOMIC;
    var argument0 = generator.valueToCode(this, 'A', order) || '0';
    var argument1 = generator.valueToCode(this, 'B', order) || '0';
    var code = '(' + argument0 + operator + argument1 + ')';
    return [code, order];
}

const math_arithmetic = function (a, generator) {
    var b = {
        ADD: [" + ", generator.ORDER_ADDITIVE],
        MINUS: [" - ", generator.ORDER_ADDITIVE],
        MULTIPLY: [" * ", generator.ORDER_MULTIPLICATIVE],
        DIVIDE: [" / ", generator.ORDER_MULTIPLICATIVE],
        QUYU: [' % ', generator.ORDER_MULTIPLICATIVE],//增加取余操作
        ZHENGCHU: [' // ', generator.ORDER_MULTIPLICATIVE],//增加整除操作
        POWER: [" ** ", generator.ORDER_EXPONENTIATION]
    }[a.getFieldValue("OP")];
    var c = b[0],
        b = b[1],
        d = generator.valueToCode(a, "A", b) || "0";
    a = generator.valueToCode(a, "B", b) || "0";
    return [d + c + a, b]
}

const math_selfcalcu = function (_, generator) {
    var argument0 = generator.valueToCode(this, 'A', generator.ORDER_RELATIONAL) || '0';
    var argument1 = generator.valueToCode(this, 'B', generator.ORDER_RELATIONAL) || '0';
    var operator = this.getFieldValue('OP');
    switch (operator) {
        case 'ADD': var op = '+='; break;
        case 'MINUS': var op = '-='; break;
        case 'MULTIPLY': var op = '*='; break;
        case 'DIVIDE': var op = '/='; break;
        case 'QUYU': var op = '%='; break;
        case 'ZHENGCHU': var op = '//='; break;
        case 'POWER': var op = '**='; break;
    }
    var code = argument0 + ' ' + op + ' ' + argument1 + '\n';
    return code;
}

const math_single = function (a, generator) {
    var b = a.getFieldValue("OP"),
        c;
    if ("NEG" == b)
        return c = generator.valueToCode(a, "NUM", generator.ORDER_UNARY_SIGN) || "0", ["-" + c, generator.ORDER_UNARY_SIGN];
    generator.definitions_['import_math'] = "import math";
    a = "SIN" == b || "COS" == b || "TAN" == b ? generator.valueToCode(a, "NUM", generator.ORDER_MULTIPLICATIVE) || "0" : generator.valueToCode(a, "NUM", generator.ORDER_NONE) || "0";
    switch (b) {
        case "ABS":
            c = "math.fabs(" + a + ")";
            break;
        case "ROOT":
            c = "math.sqrt(" +
                a + ")";
            break;
        case "LN":
            c = "math.log(" + a + ")";
            break;
        case "LOG10":
            c = "math.log10(" + a + ")";
            break;
        case "EXP":
            c = "math.exp(" + a + ")";
            break;
        case "POW10":
            c = "math.pow(10," + a + ")";
            break;
        case "ROUND":
            c = "round(" + a + ")";
            break;
        case "ROUNDUP":
            c = "math.ceil(" + a + ")";
            break;
        case "ROUNDDOWN":
            c = "math.floor(" + a + ")";
            break;
        case "SIN":
            c = "math.sin(" + a + ")";
            break;
        case "COS":
            c = "math.cos(" + a + ")";
            break;
        case "TAN":
            c = "math.tan(" + a + ")";
            break;
        case "++":
            c = "++(" + a + ")";
            break;
        case "--":
            c = "--(" + a + ")";
            break;
        case "-":
            c = "-(" + a + ")";
            break;
        default:
    }
    if (c)
        return [c, generator.ORDER_EXPONENTIATION];
    switch (b) {
        case "ASIN":
            c = "math.degrees(math.asin(" + a + "))";
            break;
        case "ACOS":
            c = "math.degrees(math.acos(" + a + "))";
            break;
        case "ATAN":
            c = "math.degrees(math.atan(" + a + "))";
            break;
    }
    return [c, generator.ORDER_MULTIPLICATIVE]
}

const math_trig = math_single;

const math_dec = function (_, generator) {
    var argument0 = generator.valueToCode(this, 'NUM', generator.ORDER_NONE) || '0';
    var operator = this.getFieldValue('OP');
    var code = operator + '(' + argument0 + ')';
    return [code, generator.ORDER_ATOMIC];

}

const math_to_int = function (_, generator) {
    var argument0 = generator.valueToCode(this, 'A', generator.ORDER_NONE) || '0';
    var operator = this.getFieldValue('OP');
    var code = "";
    if (operator === "round") {
        code = operator + '(' + argument0 + ')';
    } else {
        code = "math." + operator + '(' + argument0 + ')';
        generator.definitions_.import_math = "import math";
    }
    return [code, generator.ORDER_ATOMIC];
}

const math_max_min = function (_, generator) {
    var a = generator.valueToCode(this, 'A', generator.ORDER_NONE) || '0';
    var b = generator.valueToCode(this, 'B', generator.ORDER_NONE) || '0';
    var operator = this.getFieldValue('OP');
    var code = operator + '(' + a + ', ' + b + ')';
    return [code, generator.ORDER_ATOMIC];
}

const math_random = function (_, generator) {
    generator.definitions_.import_random = "import random";
    // Random integer between [X] and [Y].
    var type = this.getFieldValue('TYPE');
    var argument0 = generator.valueToCode(this, 'FROM',
        generator.ORDER_NONE) || '0';
    var argument1 = generator.valueToCode(this, 'TO',
        generator.ORDER_NONE) || '0';
    if (type == 'int') {
        var code = 'random.randint(' + argument0 + ', ' + argument1 + ')';
    } else if (type == 'float') {
        var code = 'random.uniform(' + argument0 + ', ' + argument1 + ')';
    }
    return [code, generator.ORDER_UNARY_POSTFIX];
}

const math_map = function (_, generator) {
    var value_num = generator.valueToCode(this, 'NUM', generator.ORDER_NONE);
    var value_fl = generator.valueToCode(this, 'fromLow', generator.ORDER_ATOMIC);
    var value_fh = generator.valueToCode(this, 'fromHigh', generator.ORDER_ATOMIC);
    var value_tl = generator.valueToCode(this, 'toLow', generator.ORDER_ATOMIC);
    var value_th = generator.valueToCode(this, 'toHigh', generator.ORDER_ATOMIC);
    generator.definitions_['import_mixpy_math_map'] = "from mixpy import math_map";
    var code = 'math_map(' + value_num + ', ' + value_fl + ', ' + value_fh + ', ' + value_tl + ', ' + value_th + ')';
    return [code, generator.ORDER_NONE];
}

const math_constrain = function (_, generator) {
    // Constrain a number between two limits.
    var argument0 = generator.valueToCode(this, 'VALUE',
        generator.ORDER_NONE) || '0';
    var argument1 = generator.valueToCode(this, 'LOW',
        generator.ORDER_NONE) || '0';
    var argument2 = generator.valueToCode(this, 'HIGH',
        generator.ORDER_NONE) || '0';
    var code = 'min(max(' + argument0 + ', ' + argument1 + '), ' + argument2 + ')';
    return [code, generator.ORDER_UNARY_POSTFIX];
}

const math_number_base_conversion = function (a, generator) {
    var c1 = a.getFieldValue("OP");
    var d = generator.valueToCode(this, 'NUM', generator.ORDER_NONE) || '0';
    var c2 = a.getFieldValue("OP2");
    generator.definitions_['import_math'] = "import math";
    var param1 = "";
    var param2 = "10";
    if (c1 == "two") {
        param2 = '2';
    } else if (c1 == "eight") {
        param2 = '8'
    } else if (c1 == "ten") {
        param2 = '10'
    } else if (c1 == "sixteen") {
        param2 = '16'
    }

    if (c2 == "two") {
        param1 = 'bin';
    } else if (c2 == "eight") {
        param1 = 'oct'
    } else if (c2 == "ten") {
        param1 = ''
    } else if (c2 == "sixteen") {
        param1 = 'hex'
    }
    if (param1 == "") {
        var code = "int(str(" + d + "), " + param2 + ")";
    } else {
        var code = param1 + "(int(str(" + d + "), " + param2 + "))";

    }
    return [code, generator.ORDER_ATOMIC];
}

const math_random_seed = function (_, generator) {
    // Random integer between [X] and [Y].
    generator.definitions_.import_random = "import random";
    var a = generator.valueToCode(this, 'NUM', generator.ORDER_NONE) || '0';
    var code = 'random.seed(' + a + ');' + '\n';
    return code;
}

const math_indexer_number = function (_, generator) {
    var code = this.getFieldValue('NUM');
    // -4.abs() returns -4 in Dart due to strange order of operation choices.
    // -4 is actually an operator and a number.  Reflect this in the order.
    var order = code < 0 ?
        generator.ORDER_UNARY_PREFIX : generator.ORDER_ATOMIC;
    return [code, order];
}

const math_round = function (_, generator) {
    var argument0 = generator.valueToCode(this, 'VALUE',
        generator.ORDER_NONE) || '0';
    var argument1 = generator.valueToCode(this, 'VAR',
        generator.ORDER_NONE) || '0';

    var code = 'round(' + argument0 + ', ' + argument1 + ')';
    return [code, generator.ORDER_ATOMIC];
}

const text_to_number = function (_, generator) {
    var towhat = this.getFieldValue('TOWHAT');
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    if (towhat == 'b') return ['' + str + '.encode("utf-8")', generator.ORDER_ATOMIC];
    else if (towhat == 'bti') return ['int.from_bytes(' + str + ',"big")', generator.ORDER_ATOMIC];
    return [towhat + "(" + str + ')', generator.ORDER_ATOMIC];
}

const text_to_number_skulpt = function (_, generator) {
    var towhat = this.getFieldValue('TOWHAT');
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    if (towhat == 'b') return ['' + str + '.encode("utf-8")', generator.ORDER_ATOMIC];
    return [towhat + "(" + str + ')', generator.ORDER_ATOMIC];
}

const base_map = math_map;

const turn_to_int = function (_, generator) {
    generator.definitions_.import_hexlify = "from ubinascii import hexlify";
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    return ["hexlify(" + str + ').decode()', generator.ORDER_ATOMIC];
}

const generate_cartesian_product = function (_, generator) {
    generator.definitions_.import_itertools = 'import itertools';
    let re = generator.valueToCode(this, 'REPEAT', generator.ORDER_ATOMIC);
    let items = new Array(this.itemCount_);
    for (let n = 0; n < this.itemCount_; n++) {
        items[n] = generator.valueToCode(this, `ADD${n}`, generator.ORDER_NONE) || '0';
    }
    let code = '';
    if (this.itemCount_) {
        code = `itertools.product(${items.join(', ')}, repeat=${re})`;
    }
    return [code, generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python/generators/procedures.js":
/*!******************************************!*\
  !*** ../python/generators/procedures.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   procedures_callnoreturn: () => (/* binding */ procedures_callnoreturn),
/* harmony export */   procedures_callreturn: () => (/* binding */ procedures_callreturn),
/* harmony export */   procedures_defnoreturn: () => (/* binding */ procedures_defnoreturn),
/* harmony export */   procedures_defreturn: () => (/* binding */ procedures_defreturn),
/* harmony export */   procedures_ifreturn: () => (/* binding */ procedures_ifreturn),
/* harmony export */   procedures_return: () => (/* binding */ procedures_return)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const procedures_defreturn = function (_, generator) {
    // Define a procedure with a return value.
    var funcName = generator.variableDB_.getName(this.getFieldValue('NAME'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Procedures.NAME_TYPE);
    var branch = (this.getInput('STACK') && generator.statementToCode(this, 'STACK')) ?? '    pass\n';
    if (generator.INFINITE_LOOP_TRAP) {
        branch = generator.INFINITE_LOOP_TRAP.replace(/%1/g,
            '\'' + this.id + '\'') + branch;
    }
    var returnValue = generator.valueToCode(this, 'RETURN',
        generator.ORDER_NONE) || '';
    //var type=this.getFieldValue('TYPE');
    if (returnValue) {
        returnValue = '    return ' + returnValue + '\n';
    }
    //var returnType = returnValue ? type : 'void';
    var args = [];
    for (var x = 0; x < this.arguments_.length; x++) {
        var varName = generator.variableDB_.getName(this.arguments_[x], blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
        args[x] = varName;
    }
    var code = 'def ' + funcName + '(' + args.join(', ') + '):\n' +
        branch + returnValue + '\n';
    code = generator.scrub_(this, code);
    generator.setups_[funcName] = code;
    return null;
}

const procedures_defnoreturn = function (_, generator) {
    // Define a procedure with a return value.
    var funcName = generator.variableDB_.getName(this.getFieldValue('NAME'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Procedures.NAME_TYPE);
    var branch = (this.getInput('STACK') && generator.statementToCode(this, 'STACK')) ?? '    pass\n';
    if (generator.INFINITE_LOOP_TRAP) {
        branch = generator.INFINITE_LOOP_TRAP.replace(/%1/g,
            '\'' + this.id + '\'') + branch;
    }
    //var returnType = returnValue ? type : 'void';
    var args = [];
    for (var x = 0; x < this.arguments_.length; x++) {
        var varName = generator.variableDB_.getName(this.arguments_[x], blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
        args[x] = varName;
    }
    var code = 'def ' + funcName + '(' + args.join(', ') + '):\n' +
        branch + '\n';
    code = generator.scrub_(this, code);
    generator.setups_[funcName] = code;
    return null;
}

const procedures_callreturn = function (_, generator) {
    // Call a procedure with a return value.
    var funcName = generator.variableDB_.getName(this.getFieldValue('NAME'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Procedures.NAME_TYPE);
    var args = [];
    for (var x = 0; x < this.arguments_.length; x++) {
        args[x] = generator.valueToCode(this, 'ARG' + x,
            generator.ORDER_NONE) || 'null';
    }
    var code = funcName + '(' + args.join(', ') + ')';
    return [code, generator.ORDER_UNARY_POSTFIX];
}

const procedures_callnoreturn = function (_, generator) {
    // Call a procedure with no return value.
    var funcName = generator.variableDB_.getName(this.getFieldValue('NAME'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Procedures.NAME_TYPE);
    var args = [];
    for (var x = 0; x < this.arguments_.length; x++) {
        args[x] = generator.valueToCode(this, 'ARG' + x,
            generator.ORDER_NONE) || 'null';
    }
    var code = funcName + '(' + args.join(', ') + ')\n';
    return code;
}

const procedures_ifreturn = function (_, generator) {
    // Conditionally return value from a procedure.
    var condition = generator.valueToCode(this, 'CONDITION',
        generator.ORDER_NONE) || 'False';
    var code = 'if (' + condition + ') :\n';
    if (this.hasReturnValue_) {
        var value = generator.valueToCode(this, 'VALUE',
            generator.ORDER_NONE) || 'None';
        code += '    return ' + value;
    } else {
        code += '    return None';
    }
    code += '\n';
    return code;
}

const procedures_return = function (_, generator) {
    // Conditionally return value from a procedure.
    var code = ""
    if (this.hasReturnValue_) {
        var value = generator.valueToCode(this, 'VALUE',
            generator.ORDER_NONE) || 'None';
        code += 'return ' + value;
    } else {
        code += 'return None';
    }
    code += '\n';
    return code;
}

/***/ }),

/***/ "../python/generators/set.js":
/*!***********************************!*\
  !*** ../python/generators/set.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   set_add_discard: () => (/* binding */ set_add_discard),
/* harmony export */   set_clear: () => (/* binding */ set_clear),
/* harmony export */   set_create_with: () => (/* binding */ set_create_with),
/* harmony export */   set_create_with_text_return: () => (/* binding */ set_create_with_text_return),
/* harmony export */   set_length: () => (/* binding */ set_length),
/* harmony export */   set_operate: () => (/* binding */ set_operate),
/* harmony export */   set_operate_update: () => (/* binding */ set_operate_update),
/* harmony export */   set_pop: () => (/* binding */ set_pop),
/* harmony export */   set_sub: () => (/* binding */ set_sub),
/* harmony export */   set_toset: () => (/* binding */ set_toset),
/* harmony export */   set_update: () => (/* binding */ set_update)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const set_create_with = function (_, generator) {
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var code = new Array(this.itemCount_);
    var default_value = '0';
    for (var n = 0; n < this.itemCount_; n++) {
        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || default_value;
    }
    //generator.definitions_['var_declare'+varName] = varName+'= '+ '{' + code.join(', ') + '}\n';
    code = varName + '= ' + '{' + code.join(', ') + '}\n';
    if (this.itemCount_ == 0) { code = varName + ' = ' + 'set()\n' }
    return code;
}

const set_length = function (_, generator) {
    var varName = generator.valueToCode(this, 'SET', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'len(' + varName + ')';
    return [code, generator.ORDER_ATOMIC];
}

const set_pop = function (_, generator) {
    var varName = generator.valueToCode(this, 'SET', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.pop()';
    return [code, generator.ORDER_ATOMIC];
}

const set_clear = function (_, generator) {
    var varName = generator.valueToCode(this, 'SET', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.clear()\n';
    return code;
}

const set_operate = function (_, generator) {
    var vars1 = generator.valueToCode(this, 'SET1', generator.ORDER_ASSIGNMENT) || '0';
    var vars2 = generator.valueToCode(this, 'SET2', generator.ORDER_ASSIGNMENT) || '0';
    var operate = this.getFieldValue('OPERATE');
    //var num = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = vars1 + "." + operate + "(" + vars2 + ')';
    return [code, generator.ORDER_ATOMIC];
}

const set_operate_update = function (_, generator) {
    var vars1 = generator.valueToCode(this, 'SET1', generator.ORDER_ASSIGNMENT) || '0';
    var vars2 = generator.valueToCode(this, 'SET2', generator.ORDER_ASSIGNMENT) || '0';
    var operate = this.getFieldValue('OPERATE');
    //var num = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = vars1 + "." + operate + "(" + vars2 + ')\n';
    return code;
}

const set_add_discard = function (_, generator) {
    var vars1 = generator.valueToCode(this, 'SET', generator.ORDER_ASSIGNMENT) || '0';
    var operate = this.getFieldValue('OPERATE');
    var argument = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var code = vars1 + "." + operate + "(" + argument + ')\n';
    return code;
}

const set_sub = function (_, generator) {
    var vars1 = generator.valueToCode(this, 'SET1', generator.ORDER_ASSIGNMENT) || '0';
    var vars2 = generator.valueToCode(this, 'SET2', generator.ORDER_ASSIGNMENT) || '0';
    var operate = this.getFieldValue('OPERATE');
    //var num = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = vars1 + "." + operate + "(" + vars2 + ')';
    return [code, generator.ORDER_ATOMIC];
}

const set_update = function (_, generator) {
    var varName = generator.valueToCode(this, 'SET', generator.ORDER_ASSIGNMENT) || '0';
    var color = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    //var color = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + "." + 'update' + '(' + color + ')\n';
    return code;
}

// export const set_change_to = function(){
//   var op = this.getFieldValue('OP');
//   var varName = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
//   var code = op + '(' + varName + ')\n';
//   return [code, generator.ORDER_ATOMIC];
// }

const set_create_with_text_return = function (_, generator) {
    var text = this.getFieldValue('TEXT');
    var code = '{' + text + '}';
    return [code, generator.ORDER_ATOMIC];
}

const set_toset = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0'
    return ['set(' + str + ')', generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python/generators/storage.js":
/*!***************************************!*\
  !*** ../python/generators/storage.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sdcard_mount: () => (/* binding */ sdcard_mount),
/* harmony export */   sdcard_use_spi_init: () => (/* binding */ sdcard_use_spi_init),
/* harmony export */   storage_can_write_ornot: () => (/* binding */ storage_can_write_ornot),
/* harmony export */   storage_change_dir: () => (/* binding */ storage_change_dir),
/* harmony export */   storage_close_file: () => (/* binding */ storage_close_file),
/* harmony export */   storage_delete_file: () => (/* binding */ storage_delete_file),
/* harmony export */   storage_file_seek: () => (/* binding */ storage_file_seek),
/* harmony export */   storage_file_tell: () => (/* binding */ storage_file_tell),
/* harmony export */   storage_file_write: () => (/* binding */ storage_file_write),
/* harmony export */   storage_fileopen: () => (/* binding */ storage_fileopen),
/* harmony export */   storage_fileopen_new: () => (/* binding */ storage_fileopen_new),
/* harmony export */   storage_fileopen_new_encoding: () => (/* binding */ storage_fileopen_new_encoding),
/* harmony export */   storage_get_a_line: () => (/* binding */ storage_get_a_line),
/* harmony export */   storage_get_contents: () => (/* binding */ storage_get_contents),
/* harmony export */   storage_get_contents_without_para: () => (/* binding */ storage_get_contents_without_para),
/* harmony export */   storage_get_current_dir: () => (/* binding */ storage_get_current_dir),
/* harmony export */   storage_get_file_size: () => (/* binding */ storage_get_file_size),
/* harmony export */   storage_get_filename: () => (/* binding */ storage_get_filename),
/* harmony export */   storage_is_file: () => (/* binding */ storage_is_file),
/* harmony export */   storage_list_all_files: () => (/* binding */ storage_list_all_files),
/* harmony export */   storage_make_dir: () => (/* binding */ storage_make_dir),
/* harmony export */   storage_open_file_with_os: () => (/* binding */ storage_open_file_with_os),
/* harmony export */   storage_rename: () => (/* binding */ storage_rename)
/* harmony export */ });
const storage_open_file_with_os = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    var fn = generator.valueToCode(this, 'fn', generator.ORDER_ATOMIC);
    return "os.startfile(" + fn + ")\n";
}

const storage_fileopen = function (_, generator) {
    // For each loop.
    var variable0 = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var fn = generator.valueToCode(this, 'FILENAME', generator.ORDER_ATOMIC);
    var mode = this.getFieldValue('MODE');
    var code = variable0 + ' = open(' + fn + ', \'' + mode + '\')\n';
    return code;
}

const storage_fileopen_new = function (_, generator) {  // For each loop.
    var fn = generator.valueToCode(this, 'FILENAME', generator.ORDER_ATOMIC);
    var mode = this.getFieldValue('MODE');
    var code = 'open(' + fn + ', \'' + mode + '\')';
    return [code, generator.ORDER_ATOMIC];
}

const storage_fileopen_new_encoding = function (_, generator) {  // For each loop.
    var fn = generator.valueToCode(this, 'FILENAME', generator.ORDER_ATOMIC);
    var mode = this.getFieldValue('MODE');
    var encode = this.getFieldValue('CODE');
    var code = 'open(' + fn + ', \'' + mode + '\', encoding="' + encode + '")';
    return [code, generator.ORDER_ATOMIC];
}

const storage_file_write = function (_, generator) {
    var data = generator.valueToCode(this, 'data', generator.ORDER_ATOMIC);
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    return file + ".write(" + data + ")\n";
}

const storage_get_contents_without_para = function (_, generator) {
    var mode = this.getFieldValue('MODE');
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = file + '.' + mode + '()';
    return [code, generator.ORDER_ATOMIC];
}

const storage_get_contents = function (_, generator) {
    var mode = this.getFieldValue('MODE');
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var size = generator.valueToCode(this, 'SIZE', generator.ORDER_ATOMIC);
    var code = file + '.' + mode + '(' + size + ')';
    return [code, generator.ORDER_ATOMIC];
}

const storage_get_a_line = function (_, generator) {
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var size = generator.valueToCode(this, 'SIZE', generator.ORDER_ATOMIC);
    var code = file + ".readline(" + size + ')';
    return [code, generator.ORDER_ATOMIC];
}

const storage_can_write_ornot = function (_, generator) {
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = file + ".writable()";
    return [code, generator.ORDER_ATOMIC];
}

const storage_get_filename = function (_, generator) {
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = file + ".name()";
    return [code, generator.ORDER_ATOMIC];
}

const storage_close_file = function (_, generator) {
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = file + ".close()\n";
    return code;
}

const storage_list_all_files = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    var code = 'os.listdir()';
    return [code, generator.ORDER_ATOMIC];
}

const storage_delete_file = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    var mode = this.getFieldValue('MODE');
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = "os." + mode + "(" + file + ")\n";
    return code;
}

const storage_get_file_size = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = "os.path.getsize(" + file + ")";
    return [code, generator.ORDER_ATOMIC];
}

const storage_file_tell = function (_, generator) {
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = file + ".tell()";
    return [code, generator.ORDER_ATOMIC];
}

const storage_file_seek = function (_, generator) {
    var mode = this.getFieldValue('MODE');
    var mode_num = 0;
    if (mode == 'start') {
        mode_num = 0;
    }
    else if (mode == 'current') {
        mode_num = 1;
    }
    else {
        mode_num = 2;
    }
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var size = generator.valueToCode(this, 'SIZE', generator.ORDER_ATOMIC);
    var code = file + '.seek(' + size + ',' + mode_num + ')\n';
    return code;
}

const storage_change_dir = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = "os.chdir(" + file + ")\n";
    return code;
}

const storage_get_current_dir = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    var code = 'os.getcwd()';
    return [code, generator.ORDER_ATOMIC];
}

const storage_make_dir = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    var mode = this.getFieldValue('MODE');
    var path = generator.valueToCode(this, 'PATH', generator.ORDER_ATOMIC);
    var code = 'os.' + mode + '(' + path + ')\n';
    return code;
}

const storage_rename = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var file1 = generator.valueToCode(this, 'NEWFILE', generator.ORDER_ATOMIC);
    var code = "os.rename(" + file + "," + file1 + ")\n";
    return code;
}

const storage_is_file = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var mode = this.getFieldValue('MODE');
    var code = "os." + mode + "(" + file + ")";
    return [code, generator.ORDER_ATOMIC];
}

const sdcard_use_spi_init = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    generator.definitions_['import_sdcard'] = 'import sdcard';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var sv = generator.valueToCode(this, 'SPISUB', generator.ORDER_ATOMIC);
    var pv = generator.valueToCode(this, 'PINSUB', generator.ORDER_ATOMIC);
    var code = v + ' = sdcard.SDCard(' + sv + ',' + pv + ')\n';
    return code;
}

const sdcard_mount = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    generator.definitions_['import_sdcard'] = 'import sdcard';
    var sd = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var dir = generator.valueToCode(this, 'DIR', generator.ORDER_ATOMIC);
    return "os.mount(" + sd + ',' + dir + ")\n";
}

/***/ }),

/***/ "../python/generators/text.js":
/*!************************************!*\
  !*** ../python/generators/text.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascii_to_char: () => (/* binding */ ascii_to_char),
/* harmony export */   char_to_ascii: () => (/* binding */ char_to_ascii),
/* harmony export */   number_to_text: () => (/* binding */ number_to_text),
/* harmony export */   os_system: () => (/* binding */ os_system),
/* harmony export */   text: () => (/* binding */ text),
/* harmony export */   text_capital: () => (/* binding */ text_capital),
/* harmony export */   text_center: () => (/* binding */ text_center),
/* harmony export */   text_char: () => (/* binding */ text_char),
/* harmony export */   text_char_at: () => (/* binding */ text_char_at),
/* harmony export */   text_char_at2: () => (/* binding */ text_char_at2),
/* harmony export */   text_char_at3: () => (/* binding */ text_char_at3),
/* harmony export */   text_compareTo: () => (/* binding */ text_compareTo),
/* harmony export */   text_compare_to: () => (/* binding */ text_compare_to),
/* harmony export */   text_encode: () => (/* binding */ text_encode),
/* harmony export */   text_equals_starts_ends: () => (/* binding */ text_equals_starts_ends),
/* harmony export */   text_eval: () => (/* binding */ text_eval),
/* harmony export */   text_find: () => (/* binding */ text_find),
/* harmony export */   text_format: () => (/* binding */ text_format),
/* harmony export */   text_format_noreturn: () => (/* binding */ text_format_noreturn),
/* harmony export */   text_join: () => (/* binding */ text_join),
/* harmony export */   text_join_seq: () => (/* binding */ text_join_seq),
/* harmony export */   text_length: () => (/* binding */ text_length),
/* harmony export */   text_random_char: () => (/* binding */ text_random_char),
/* harmony export */   text_replace: () => (/* binding */ text_replace),
/* harmony export */   text_split: () => (/* binding */ text_split),
/* harmony export */   text_strip: () => (/* binding */ text_strip),
/* harmony export */   text_substring: () => (/* binding */ text_substring),
/* harmony export */   text_substring2: () => (/* binding */ text_substring2),
/* harmony export */   text_substring3: () => (/* binding */ text_substring3),
/* harmony export */   text_textarea: () => (/* binding */ text_textarea)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const text = function (_, generator) {
    // Text value.
    //var code = 'String('+generator.quote_(this.getFieldValue('TEXT'))+')';
    var code = generator.quote_(this.getFieldValue('TEXT'));
    return [code, generator.ORDER_ATOMIC];
}

const text_textarea = function (_, generator) {
    // Text value.
    //var code = 'String('+generator.quote_(this.getFieldValue('TEXT'))+')';
    var code = '"""' + (this.getFieldValue('VALUE')) + '"""';
    return [code, generator.ORDER_ATOMIC];
}

const text_char = function (_, generator) {
    var code = '\'' + this.getFieldValue('TEXT') + '\'';
    return [code, generator.ORDER_ATOMIC];
}

const text_join = function (_, generator) {
    // Text value.
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC);
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC);
    return [a + ' + ' + b, generator.ORDER_ADDITIVE];
}

const ascii_to_char = function (_, generator) {
    var asciivalue = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0'
    return ['chr(' + asciivalue + ')', generator.ORDER_ATOMIC];
}

const char_to_ascii = function (_, generator) {
    var charvalue = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || 'a';
    return ['ord(' + charvalue + ')', generator.ORDER_ATOMIC];
}

const number_to_text = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0';
    return ['str(' + str + ')', generator.ORDER_ATOMIC];
}

const text_length = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    return ['len(' + str + ')', generator.ORDER_ATOMIC];
}

const text_char_at2 = function (a, generator) {
    var c = a.getFieldValue("WHERE") || "FROM_START",
        str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    switch (c) {
        case "FROM_START":
            a = generator.getAdjustedInt(a, "AT");
            return [str + "[" + a + "]", generator.ORDER_ATOMIC];
        case "FROM_END":
            a = generator.getAdjustedInt(a, "AT", 1, !0);
            return [str + "[" + a + "]", generator.ORDER_ATOMIC];
        case "RANDOM":
            generator.definitions_.import_random = "import random";
            return ["random.choice(" + str + ")", generator.ORDER_FUNCTION_CALL];
    }
    throw "Unhandled combination (lists_getIndex).";
}

const text_char_at = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var at = generator.valueToCode(this, 'AT', generator.ORDER_ATOMIC) || 0;
    return [str + "[" + at + "]", generator.ORDER_ATOMIC];
}

const text_random_char = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    generator.definitions_.import_random = "import random";
    return ["random.choice(" + str + ")", generator.ORDER_FUNCTION_CALL];
}

const text_equals_starts_ends = function (_, generator) {
    var str1 = (generator.valueToCode(this, 'STR1', generator.ORDER_ATOMIC) || '""');
    var str2 = (generator.valueToCode(this, 'STR2', generator.ORDER_ATOMIC) || '""');
    var dowhat = this.getFieldValue('DOWHAT');
    if (dowhat === '===')
        return [str1 + ' == ' + str2, generator.ORDER_ATOMIC];
    return [str1 + '.' + dowhat + '(' + str2 + ')', generator.ORDER_ATOMIC];
}

const text_compare_to = function (_, generator) {
    var str1 = (generator.valueToCode(this, 'STR1', generator.ORDER_ATOMIC) || '""');
    var str2 = (generator.valueToCode(this, 'STR2', generator.ORDER_ATOMIC) || '""');
    return ['cmp(' + str1 + ',' + str2 + ')', generator.ORDER_ATOMIC];
}

const text_substring2 = function (block, generator) {
    // Get sublist.
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var where1 = block.getFieldValue('WHERE1');
    var where2 = block.getFieldValue('WHERE2');
    switch (where1) {
        case 'FROM_START':
            var at1 = generator.getAdjustedInt(block, 'AT1');
            if (at1 == '0') {
                at1 = '';
            }
            break;
        case 'FROM_END':
            var at1 = generator.getAdjustedInt(block, 'AT1', 0, true);
            break;
        case 'FIRST':
            var at1 = '0';
            break;
        default:
            throw 'Unhandled option (lists_getSublist)';
    }
    switch (where2) {
        case 'FROM_START':
            var at2 = generator.getAdjustedInt(block, 'AT2');
            break;
        case 'FROM_END':
            var at2 = generator.getAdjustedInt(block, 'AT2', 0, true);
            // Ensure that if the result calculated is 0 that sub-sequence will
            // include all elements as expected.
            if (!blockly_core__WEBPACK_IMPORTED_MODULE_0__.isNumber(String(at2))) {
                generator.definitions_['import_sys'] = 'import sys';
                at2 += ' or sys.maxsize';
            } else if (at2 == '0') {
                at2 = '';
            }
            break;
        case 'LAST':
            var at2 = '-1';
            break;
        default:
            throw 'Unhandled option (lists_getSublist)';
    }
    var code = str + '[' + at1 + ' : ' + at2 + ']';
    return [code, generator.ORDER_ATOMIC];
}

const text_substring = function (_, generator) {
    // Get sublist.
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var at1 = generator.valueToCode(this, 'AT1', generator.ORDER_ATOMIC);
    var at2 = generator.valueToCode(this, 'AT2', generator.ORDER_ATOMIC);
    var code = str + '[' + at1 + ' : ' + at2 + ']';
    return [code, generator.ORDER_ATOMIC];
}

const text_capital = function (_, generator) {
    var capital = this.getFieldValue('CAPITAL');
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    return ['' + str + '.' + capital + '()', generator.ORDER_ATOMIC];
}

const text_center = function (_, generator) {
    var center = this.getFieldValue('CENTER');
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var width = generator.valueToCode(this, 'WID', generator.ORDER_ATOMIC);
    var symbol = generator.valueToCode(this, 'Symbol', generator.ORDER_ATOMIC);
    return ['' + str + '.' + center + '(' + width + ',' + symbol + ')', generator.ORDER_ATOMIC];
}

const text_find = function (_, generator) {
    var sentence = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var str = generator.valueToCode(this, 'STR', generator.ORDER_ATOMIC);
    return ['' + sentence + '.find(' + str + ')', generator.ORDER_ATOMIC];
}

const text_join_seq = function (_, generator) {
    var sentence = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var varName = generator.valueToCode(this, 'LIST', generator.ORDER_ASSIGNMENT) || '0';
    return [sentence + '.join(' + varName + ')', generator.ORDER_ATOMIC];
}

const text_replace = function (_, generator) {
    var sentence = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var str1 = generator.valueToCode(this, 'STR1', generator.ORDER_ATOMIC);
    var str2 = generator.valueToCode(this, 'STR2', generator.ORDER_ATOMIC);
    return ['' + sentence + '.replace(' + str1 + ',' + str2 + ')', generator.ORDER_ATOMIC];
}

const text_split = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var argument = generator.valueToCode(this, 'VAL', generator.ORDER_ATOMIC) || '""';
    var code = str + ".split(" + argument + ")";
    return [code, generator.ORDER_ATOMIC];
}

const text_strip = function (_, generator) {
    var towhat = this.getFieldValue('TOWHAT');
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = str + "." + towhat + "()";
    return [code, generator.ORDER_ATOMIC];
}

const text_format = function (_, generator) {
    // Create a list with any number of elements of any type.
    var s = this.getFieldValue('VAR');
    var code = new Array(this.itemCount_);
    var default_value = '0';
    for (var n = 0; n < this.itemCount_; n++) {

        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || default_value;
    }
    var code = s + '.format(' + code.join(', ') + ')';
    return [code, generator.ORDER_ATOMIC];
}

const text_format_noreturn = function (_, generator) {
    // Create a list with any number of elements of any type.
    var s = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = new Array(this.itemCount_);
    var default_value = '0';
    for (var n = 0; n < this.itemCount_; n++) {

        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || default_value;
    }
    var code = s + '.format(' + code.join(', ') + ')';
    return [code, generator.ORDER_ATOMIC];
}

const text_substring3 = text_substring
const text_compareTo = text_compare_to
const text_char_at3 = text_char_at

const text_encode = function (_, generator) {
    var code = this.getFieldValue('DIR');
    var varName = this.getFieldValue('CODE')
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    return [str + '.' + code + '("' + varName + '")', generator.ORDER_ATOMIC];
}

const text_eval = function (_, generator) {
    var codestr = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = "eval" + '(' + codestr + ')';
    return [code, generator.ORDER_ATOMIC];
}

const os_system = function (_, generator) {
    generator.definitions_['import_os'] = 'import os';
    var codestr = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = "os.system" + '(' + codestr + ')\n';
    return code;
}

/***/ }),

/***/ "../python/generators/tuple.js":
/*!*************************************!*\
  !*** ../python/generators/tuple.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tuple_change_to: () => (/* binding */ tuple_change_to),
/* harmony export */   tuple_create_with: () => (/* binding */ tuple_create_with),
/* harmony export */   tuple_create_with_noreturn: () => (/* binding */ tuple_create_with_noreturn),
/* harmony export */   tuple_create_with_text2: () => (/* binding */ tuple_create_with_text2),
/* harmony export */   tuple_create_with_text_return: () => (/* binding */ tuple_create_with_text_return),
/* harmony export */   tuple_del: () => (/* binding */ tuple_del),
/* harmony export */   tuple_find: () => (/* binding */ tuple_find),
/* harmony export */   tuple_getIndex: () => (/* binding */ tuple_getIndex),
/* harmony export */   tuple_getSublist: () => (/* binding */ tuple_getSublist),
/* harmony export */   tuple_get_random_item: () => (/* binding */ tuple_get_random_item),
/* harmony export */   tuple_get_sublist: () => (/* binding */ tuple_get_sublist),
/* harmony export */   tuple_join: () => (/* binding */ tuple_join),
/* harmony export */   tuple_length: () => (/* binding */ tuple_length),
/* harmony export */   tuple_max: () => (/* binding */ tuple_max),
/* harmony export */   tuple_totuple: () => (/* binding */ tuple_totuple),
/* harmony export */   tuple_trig: () => (/* binding */ tuple_trig)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const tuple_create_with = function (_, generator) {
    // Create a list with any number of elements of any type.
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    //var size=window.parseFloat(this.getFieldValue('SIZE'));
    var code = new Array(this.itemCount_);
    var default_value = '0';
    for (var n = 0; n < this.itemCount_; n++) {

        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || default_value;
    }
    // if (this.itemCount_!=1){
    //  generator.definitions_['var_declare'+varName] = varName+'= '+ '(' + code.join(', ') + ')\n';}
    // else {
    // generator.definitions_['var_declare'+varName] = varName+'= '+ '(' + code.join(', ') + ',)\n';}
    if (this.itemCount_ != 1) {
        var code = varName + '= ' + '(' + code.join(', ') + ')\n';
    }
    else {
        var code = varName + '= ' + '(' + code.join(', ') + ',)\n';
    }
    return code;
}

const tuple_create_with_text2 = function (_, generator) {
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    //var size=window.parseFloat(this.getFieldValue('SIZE'));
    var text = this.getFieldValue('TEXT');
    //generator.definitions_['var_declare'+varName] = varName+'= '+ '(' + text + ')\n';
    var code = varName + '= ' + '(' + text + ')\n';
    return code;
}

const tuple_create_with_text_return = function (_, generator) {
    var text = this.getFieldValue('TEXT');
    var code = '(' + text + ')';
    return [code, generator.ORDER_ATOMIC];
}

const tuple_getIndex = function (_, generator) {
    // Indexing into a list is the same as indexing into a string.
    var varName = generator.valueToCode(this, 'TUP', generator.ORDER_ASSIGNMENT) || '0';
    var argument0 = generator.valueToCode(this, 'AT',
        generator.ORDER_ADDITIVE) || '1';
    if (argument0.match(/^\d+$/)) {
        // If the index is a naked number, decrement it right now.
        argument0 = parseInt(argument0, 10);
    }
    // else {
    // If the index is dynamic, decrement it in code.
    // argument0;
    // }
    var code = varName + '[' + argument0 + ']';
    return [code, generator.ORDER_ATOMIC];
}

const tuple_length = function (_, generator) {
    var varName = generator.valueToCode(this, 'TUP', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'len(' + varName + ')';
    return [code, generator.ORDER_ATOMIC];
}

const tuple_del = function (_, generator) {
    var varName = generator.valueToCode(this, 'TUP', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'del ' + varName + '\n';
    return code;
}

const tuple_join = function (_, generator) {
    var varName1 = generator.valueToCode(this, 'TUP1', generator.ORDER_ASSIGNMENT) || '0';
    var varName2 = generator.valueToCode(this, 'TUP2', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName1 + " + " + varName2;
    return [code, generator.ORDER_ATOMIC];
}

const tuple_max = function (_, generator) {
    var varname = generator.valueToCode(this, 'TUP', generator.ORDER_ASSIGNMENT) || '0';
    var maxmin = this.getFieldValue('DIR');
    var code = maxmin + "(" + varname + ')';
    return [code, generator.ORDER_ATOMIC];
}

const tuple_change_to = function (_, generator) {
    var op = this.getFieldValue('OP');
    var varName = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var code = op + '(' + varName + ')\n';
    return [code, generator.ORDER_ATOMIC];
}

const tuple_find = function (_, generator) {
    var op = this.getFieldValue('OP');
    var varName = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var argument = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    if (op == 'INDEX')
        var code = varName + '.index(' + argument + ')';
    else if (op == 'COUNT')
        var code = varName + '.count(' + argument + ')';
    return [code, generator.ORDER_ATOMIC];
}

const tuple_trig = function (a, generator) {
    var b = a.getFieldValue("OP"), c;
    generator.definitions_['import_math'] = "import math";
    a = generator.valueToCode(a, 'data', generator.ORDER_NONE)
    switch (b) {
        case "LEN":
            c = "len(" + a + ")";
            break;
        case "SUM":
            c = "sum(" + a + ")";
            break;
        case "MIN":
            c = "min(" + a + ")";
            break;
        case "MAX":
            c = "max(" + a + ")";
            break;
        case 'AVERAGE':
            // generator.definitions_['from_numbers_import_Number'] =
            //   'from numbers import Number';
            var functionName = generator.provideFunction_(
                'math_mean',
                // This operation excludes null and values that aren't int or float:',
                // math_mean([null, null, "aString", 1, 9]) == 5.0.',
                ['def ' + generator.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',
                    '  localList = [e for e in myList if type(e) == int or type(e) == float]',
                    '  if not localList: return',
                    '  return float(sum(localList)) / len(localList)']);
            c = functionName + '(' + a + ')';
            break;
        case 'MEDIAN':
            // generator.definitions_['from_numbers_import_Number'] =
            //   'from numbers import Numberd';
            var functionName = generator.provideFunction_(
                'math_median',
                // This operation excludes null values:
                // math_median([null, null, 1, 3]) == 2.0.
                ['def ' + generator.FUNCTION_NAME_PLACEHOLDER_ + '(myList):',
                    '  localList = sorted([e for e in myList if type(e) == int or type(e) == float])',
                    '  if not localList: return',
                    '  if len(localList) % 2 == 0:',
                    '    return (localList[len(localList) // 2 - 1] + ' +
                'localList[len(localList) // 2]) / 2.0',
                    '  else:',
                    '    return localList[(len(localList) - 1) // 2]']);
            c = functionName + '(' + a + ')';
            break;
        case 'MODE':
            var functionName = generator.provideFunction_(
                'math_modes',
                // As a list of numbers can contain more than one mode,
                // the returned result is provided as an array.
                // Mode of [3, 'x', 'x', 1, 1, 2, '3'] -> ['x', 1].
                ['def ' + generator.FUNCTION_NAME_PLACEHOLDER_ + '(some_list):',
                    '  modes = []',
                    '  # Using a lists of [item, count] to keep count rather than dict',
                    '  # to avoid "unhashable" errors when the counted item is ' +
                'itself a list or dict.',
                    '  counts = []',
                    '  maxCount = 1',
                    '  for item in some_list:',
                    '    found = False',
                    '    for count in counts:',
                    '      if count[0] == item:',
                    '        count[1] += 1',
                    '        maxCount = max(maxCount, count[1])',
                    '        found = True',
                    '    if not found:',
                    '      counts.append([item, 1])',
                    '  for counted_item, item_count in counts:',
                    '    if item_count == maxCount:',
                    '      modes.append(counted_item)',
                    '  return modes']);
            c = functionName + '(' + a + ')';
            break;
        case 'STD_DEV':
            generator.definitions_['import_math'] = 'import math';
            var functionName = generator.provideFunction_(
                'math_standard_deviation',
                ['def ' + generator.FUNCTION_NAME_PLACEHOLDER_ + '(numbers):',
                    '  n = len(numbers)',
                    '  if n == 0: return',
                    '  mean = float(sum(numbers)) / n',
                    '  variance = sum((x - mean) ** 2 for x in numbers) / n',
                    '  return math.sqrt(variance)']);
            c = functionName + '(' + a + ')';
            break;
        default:
            throw 'Unknown operator: ' + b;
    }
    if (c)
        return [c, generator.ORDER_FUNCTION_CALL];

}

const tuple_getSublist = function (block, generator) {
    // Get sublist.
    var list = generator.valueToCode(block, 'LIST',
        generator.ORDER_MEMBER) || '[]';
    var where1 = block.getFieldValue('WHERE1');
    var where2 = block.getFieldValue('WHERE2');
    switch (where1) {
        case 'FROM_START':
            var at1 = generator.getAdjustedInt(block, 'AT1');
            if (at1 == '0') {
                at1 = '';
            }
            break;
        case 'FROM_END':
            var at1 = generator.getAdjustedInt(block, 'AT1', 1, true);
            break;
        case 'FIRST':
            var at1 = '0';
            break;
        default:
            throw 'Unhandled option (lists_getSublist)';
    }
    switch (where2) {
        case 'FROM_START':
            var at2 = generator.getAdjustedInt(block, 'AT2', 1);
            at2 = at2 - 1;
            break;
        case 'FROM_END':
            var at2 = generator.getAdjustedInt(block, 'AT2', 1, true);
            // Ensure that if the result calculated is 0 that sub-sequence will
            // include all elements as expected.
            if (!blockly_core__WEBPACK_IMPORTED_MODULE_0__.isNumber(String(at2))) {
                generator.definitions_['import_sys'] = 'import sys';
                at2 += ' or sys.maxsize';
            } else if (at2 == '0') {
                at2 = '';
            }
            break;
        case 'LAST':
            var at2 = '-1';
            break;
        default:
            throw 'Unhandled option (lists_getSublist)';
    }
    var code = list + '[' + at1 + ' : ' + at2 + ']';
    return [code, generator.ORDER_MEMBER];
}

const tuple_create_with_noreturn = function (_, generator) {
    // Create a list with any number of elements of any type.
    var code = new Array(this.itemCount_);
    var default_value = '0';


    for (var n = 0; n < this.itemCount_; n++) {

        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || default_value;
    }
    // if (this.itemCount_!=1){
    //  generator.definitions_['var_declare'+varName] = varName+'= '+ '(' + code.join(', ') + ')\n';}
    // else {
    // generator.definitions_['var_declare'+varName] = varName+'= '+ '(' + code.join(', ') + ',)\n';}
    if (this.itemCount_ != 1) {
        var code = '(' + code.join(', ') + ')';
    }
    else {
        var code = '(' + code.join(', ') + ',)';
    }

    return [code, generator.ORDER_ATOMIC];
}

const tuple_get_sublist = function (_, generator) {
    // Get sublist.
    var list = generator.valueToCode(this, 'LIST', generator.ORDER_ADDITIVE) || '0';
    var at1 = generator.valueToCode(this, 'AT1', generator.ORDER_ADDITIVE) || '0';
    var at2 = generator.valueToCode(this, 'AT2', generator.ORDER_ADDITIVE) || '0';
    var code = list + '[' + at1 + ' : ' + at2 + ']';
    return [code, generator.ORDER_ATOMIC];
}

const tuple_get_random_item = function (_, generator) {
    generator.definitions_['import_random'] = 'import random';
    var varName = generator.valueToCode(this, 'TUP', generator.ORDER_ADDITIVE) || 'mytup';
    var code = 'random.choice(' + varName + ')';
    return [code, generator.ORDER_ATOMIC];
}

const tuple_totuple = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0'
    return ['tuple(' + str + ')', generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python/generators/utility.js":
/*!***************************************!*\
  !*** ../python/generators/utility.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attribute_access: () => (/* binding */ attribute_access),
/* harmony export */   function_call: () => (/* binding */ function_call),
/* harmony export */   raw_block: () => (/* binding */ raw_block),
/* harmony export */   raw_empty: () => (/* binding */ raw_empty),
/* harmony export */   raw_expression: () => (/* binding */ raw_expression),
/* harmony export */   raw_table: () => (/* binding */ raw_table),
/* harmony export */   type_check: () => (/* binding */ type_check)
/* harmony export */ });
/**
 * @license
 * Visual Blocks Language
 *
 * Copyright 2012 Google Inc.
 * https://developers.google.com/blockly/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Generating Python for utility blocks.
 * @author acbart@vt.edu (Austin Cory Bart)
 */

const raw_block = function (block) {
    var code = block.getFieldValue('TEXT') + "\n";
    return code;
}

const raw_expression = function (block, generator) {
    var code = block.getFieldValue('TEXT');
    return [code, generator.ORDER_ATOMIC];
}

const raw_empty = function (block, generator) {
    var code = generator.valueToCode(block, 'VALUE',
        generator.ORDER_ATOMIC) || '';
    return code + "\n";
}

const raw_table = function () {
    //var code = block.getFieldValue('TEXT')+"\n";
    return '';//code;
}

const type_check = function (block, generator) {
    var value = generator.valueToCode(block, 'VALUE',
        generator.ORDER_MEMBER) || '___';
    var code = 'type(' + value + ')';
    return [code, generator.ORDER_ATOMIC];
}

const function_call = function (block, generator) {
    var name = block.getFieldValue('NAME');
    var hasReturn = block.hasReturn_;
    var args = new Array(block.itemCount_);
    for (var n = 0; n < block.itemCount_; n++) {
        args[n] = generator.valueToCode(block, 'ARGUMENT' + n,
            generator.ORDER_NONE) || '___';
    }
    var code = name + '(' + args.join(', ') + ')';
    if (hasReturn) {
        return [code, generator.ORDER_ATOMIC];
    }
    return code + '\n';
}

const attribute_access = function (block, generator) {
    var value_module = generator.valueToCode(block, 'MODULE', generator.ORDER_ATOMIC);
    var value_name = generator.valueToCode(block, 'NAME', generator.ORDER_ATOMIC);
    //去除掉两端的括号，如(val()) --> val()
    value_name = value_name.substring(1, value_name.length - 1);
    // TODO: Assemble JavaScript into code variable.
    var code = value_module + '.' + value_name;
    // TODO: Change ORDER_NONE to the correct strength.
    return [code, generator.ORDER_NONE];
}

/***/ }),

/***/ "../python/generators/variables.js":
/*!*****************************************!*\
  !*** ../python/generators/variables.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   controls_type: () => (/* binding */ controls_type),
/* harmony export */   controls_typeLists: () => (/* binding */ controls_typeLists),
/* harmony export */   lists_zip: () => (/* binding */ lists_zip),
/* harmony export */   unpack_iterable_object: () => (/* binding */ unpack_iterable_object),
/* harmony export */   variables_change: () => (/* binding */ variables_change),
/* harmony export */   variables_get: () => (/* binding */ variables_get),
/* harmony export */   variables_global: () => (/* binding */ variables_global),
/* harmony export */   variables_set: () => (/* binding */ variables_set)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const variables_get = function (_, generator) {
    // Variable getter.
    var code = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    return [code, generator.ORDER_ATOMIC];
}

// export const variables_declare = function() {
//   var dropdown_type = this.getFieldValue('TYPE');
//   var argument0;
//   //TODO: settype to variable
//   argument0 = generator.valueToCode(this, 'VALUE',generator.ORDER_ASSIGNMENT) ||  'None';
//   var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
//       Blockly.Variables.NAME_TYPE);

//   if (dropdown_type === 'number')
//       generator.definitions_['var_declare' + varName] = 'let ' + ' ' + varName + ' = 0;';
//   else if(dropdown_type === 'string')
//       generator.definitions_['var_declare' + varName] = 'let ' + ' ' + varName + ' = \'\';';
//   else if(dropdown_type === 'boolean')
//       generator.definitions_['var_declare' + varName] = 'let ' + ' ' + varName + ' = true;';
//   else if(dropdown_type.startsWith('Array'))
//       generator.definitions_['var_declare' + varName] = 'let ' + varName + ':' + dropdown_type + ' = [];';

//   if(generator.setups_['var_declare' + varName] === undefined) {
//       generator.setups_['var_declare' + varName] =  varName + ' = ' + argument0 + '\n';
//   }else {
//   }
//   return '';
// }

const variables_set = function (_, generator) {
    // Variable setter.
    if (this.getFieldValue('VAR') == "") {
        return "  = None\n";
    }
    var argument0 = generator.valueToCode(this, 'VALUE',
        generator.ORDER_ASSIGNMENT) || 'None';
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'), blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    return varName + ' = ' + argument0 + '\n';
}

const variables_change = function (_, generator) {
    // Variable setter.
    var operator = this.getFieldValue('OP');
    var varName = generator.valueToCode(this, 'MYVALUE', generator.ORDER_ATOMIC) || 'None';
    if (operator == 'bytes') { var code = operator + '(' + varName + ',"UTF-8")'; }
    else { var code = operator + '(' + varName + ')'; }
    return [code, generator.ORDER_ATOMIC];
}

const variables_global = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || 'None';
    var code = "global " + str + '\n';
    return code;
}

// ok
const controls_type = function (_, generator) {
    var data = generator.valueToCode(this, 'DATA', generator.ORDER_ATOMIC) || 'None'
    var code = 'type(' + data + ')';
    return [code, generator.ORDER_ATOMIC];
}

const controls_typeLists = function (_, generator) {
    //generator.definitions_['import_microbit_*'] = 'from microbit import *';
    var type = this.getFieldValue('type');
    // generator.definitions_['func_type' + type] = code;
    return [type, generator.ORDER_ATOMIC];
}

const lists_zip = function (_, generator) {
    var code = new Array(this.itemCount_);
    var default_value = '[]';
    for (var n = 0; n < this.itemCount_; n++) {
        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || default_value;
    }
    var code = 'zip(' + code.join(', ') + ')';
    return [code, generator.ORDER_ATOMIC];
}

const unpack_iterable_object = function (_, generator) {
    const varName = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '[]';
    const type = this.getFieldValue('TYPE');
    const code = `${type}(${varName})`;
    return [code, generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python/others/names.js":
/*!*********************************!*\
  !*** ../python/others/names.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _variables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variables */ "../python/others/variables.js");
/**
 * @license
 * Visual Blocks Editor
 *
 * Copyright 2012 Google Inc.
 * https://developers.google.com/blockly/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Utility functions for handling variables and procedure names.
 * @author fraser@google.com (Neil Fraser)
 */


/**
 * Class for a database of entity names (variables, functions, etc).
 * @param {string} reservedWords A comma-separated string of words that are
 *     illegal for use as names in a language (e.g. 'new,if,this,...').
 * @param {string=} opt_variablePrefix Some languages need a '$' or a namespace
 *     before all variable names.
 * @constructor
 */
class Names {
    constructor(reservedWords, opt_variablePrefix) {
        this.variablePrefix_ = opt_variablePrefix || '';
        this.reservedDict_ = Object.create(null);
        if (reservedWords) {
            var splitWords = reservedWords.split(',');
            for (var i = 0; i < splitWords.length; i++) {
                this.reservedDict_[splitWords[i]] = true;
            }
        }
        this.reset();
    }
    /**
     * Do the given two entity names refer to the same entity?
     * Blockly names are case-insensitive.
     * @param {string} name1 First name.
     * @param {string} name2 Second name.
     * @return {boolean} True if names are the same.
     */
    static equals(name1, name2) {
        return name1.toLowerCase() == name2.toLowerCase();
    }
    /**
     * When JavaScript (or most other languages) is generated, variable 'foo' and
     * procedure 'foo' would collide.  However, Blockly has no such problems since
     * variable get 'foo' and procedure call 'foo' are unambiguous.
     * Therefore, Blockly keeps a separate type name to disambiguate.
     * getName('foo', 'variable') -> 'foo'
     * getName('foo', 'procedure') -> 'foo2'
     */
    /**
     * Empty the database and start from scratch.  The reserved words are kept.
     */
    reset() {
        this.db_ = Object.create(null);
        this.dbReverse_ = Object.create(null);
        this.variableMap_ = null;
    }
    /**
     * Set the variable map that maps from variable name to variable object.
     * @param {!Blockly.VariableMap} map The map to track.
     * @package
     */
    setVariableMap(map) {
        this.variableMap_ = map;
    }
    /**
     * Get the name for a user-defined variable, based on its ID.
     * This should only be used for variables of type Variables.NAME_TYPE.
     * @param {string} id The ID to look up in the variable map.
     * @return {?string} The name of the referenced variable, or null if there was
     *     no variable map or the variable was not found in the map.
     * @private
     */
    getNameForUserVariable_(id) {
        if (!this.variableMap_) {
            /*
            console.log('Deprecated call to Names.prototype.getName without ' +
                'defining a variable map. To fix, add the folowing code in your ' +
                'generator\'s init() function:\n' +
                'Blockly.YourGeneratorName.variableDB_.setVariableMap(' +
                'workspace.getVariableMap());');
                */
            return null;
        }
        var variable = this.variableMap_.getVariableById(id);
        if (variable) {
            return variable.name;
        }
        return null;
    }
    /**
     * Convert a Blockly entity name to a legal exportable entity name.
     * @param {string} name The Blockly entity name (no constraints).
     * @param {string} type The type of entity in Blockly
     *     ('VARIABLE', 'PROCEDURE', 'BUILTIN', etc...).
     * @return {string} An entity name that is legal in the exported language.
     */
    getName(name, type) {
        if (type == _variables__WEBPACK_IMPORTED_MODULE_0__["default"].NAME_TYPE) {
            var varName = this.getNameForUserVariable_(name);
            if (varName) {
                name = varName;
            }
        }
        var normalized = name.toLowerCase() + '_' + type;

        var isVarType = type == _variables__WEBPACK_IMPORTED_MODULE_0__["default"].NAME_TYPE ||
            type == Names.DEVELOPER_VARIABLE_TYPE;

        var prefix = isVarType ? this.variablePrefix_ : '';
        if (normalized in this.db_) {
            return prefix + this.db_[normalized];
        }
        var safeName = this.getDistinctName(name, type);
        this.db_[normalized] = safeName.substr(prefix.length);
        return safeName;
    }
    /**
     * Convert a Blockly entity name to a legal exportable entity name.
     * Ensure that this is a new name not overlapping any previously defined name.
     * Also check against list of reserved words for the current language and
     * ensure name doesn't collide.
     * @param {string} name The Blockly entity name (no constraints).
     * @param {string} type The type of entity in Blockly
     *     ('VARIABLE', 'PROCEDURE', 'BUILTIN', etc...).
     * @return {string} An entity name that is legal in the exported language.
     */
    getDistinctName(name, type) {
        var safeName = this.safeName_(name);
        var i = '';
        while (this.dbReverse_[safeName + i] ||
            (safeName + i) in this.reservedDict_) {
            // Collision with existing name.  Create a unique name.
            i = i ? i + 1 : 2;
        }
        safeName += i;
        this.dbReverse_[safeName] = true;
        var isVarType = type == _variables__WEBPACK_IMPORTED_MODULE_0__["default"].NAME_TYPE ||
            type == Names.DEVELOPER_VARIABLE_TYPE;
        var prefix = isVarType ? this.variablePrefix_ : '';
        return prefix + safeName;
    }
    /**
     * Given a proposed entity name, generate a name that conforms to the
     * [_A-Za-z][_A-Za-z0-9]* format that most languages consider legal for
     * variables.
     * @param {string} name Potentially illegal entity name.
     * @return {string} Safe entity name.
     * @private
     */
    safeName_(name) {
        if (!name) {
            name = 'unnamed';
        } else {
            // Unfortunately names in non-latin characters will look like
            // _E9_9F_B3_E4_B9_90 which is pretty meaningless.
            // https://github.com/google/blockly/issues/1654
            name = encodeURI(name.replace(/ /g, '_')).replace(/[^,\w]/g, '_');
            // Most languages don't allow names with leading numbers.
            if ('0123456789'.indexOf(name[0]) != -1) {
                name = 'my_' + name;
            }
        }
        return name;
    }
}

/**
 * Constant to separate developer variable names from user-defined variable
 * names when running generators.
 * A developer variable will be declared as a global in the generated code, but
 * will never be shown to the user in the workspace or stored in the variable
 * map.
 */
Names.DEVELOPER_VARIABLE_TYPE = 'DEVELOPER_VARIABLE';

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Names);

/***/ }),

/***/ "../python/others/procedures.js":
/*!**************************************!*\
  !*** ../python/others/procedures.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Copyright 2012 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Utility functions for handling procedures.
 * @author fraser@google.com (Neil Fraser)
 */


const Procedures = {};

/**
 * Constant to separate procedure names from variables and generated functions
 * when running generators.
 * @deprecated Use Blockly.PROCEDURE_CATEGORY_NAME
 */
Procedures.NAME_TYPE = blockly_core__WEBPACK_IMPORTED_MODULE_0__.PROCEDURE_CATEGORY_NAME;

/**
 * Find all user-created procedure definitions in a workspace.
 * @param {!Blockly.Workspace} root Root workspace.
 * @return {!Array.<!Array.<!Array>>} Pair of arrays, the
 *     first contains procedures without return variables, the second with.
 *     Each procedure is defined by a three-element list of name, parameter
 *     list, and return value boolean.
 */
Procedures.allProcedures = function (root) {
    var blocks = root.getAllBlocks(false);
    var proceduresReturn = [];
    var proceduresNoReturn = [];
    for (var i = 0; i < blocks.length; i++) {
        if (blocks[i].getProcedureDef) {
            var tuple = blocks[i].getProcedureDef();
            if (tuple) {
                if (tuple[2]) {
                    proceduresReturn.push(tuple);
                } else {
                    proceduresNoReturn.push(tuple);
                }
            }
        }
    }
    proceduresNoReturn.sort(Procedures.procTupleComparator_);
    proceduresReturn.sort(Procedures.procTupleComparator_);
    return [proceduresNoReturn, proceduresReturn];
};

/**
 * Comparison function for case-insensitive sorting of the first element of
 * a tuple.
 * @param {!Array} ta First tuple.
 * @param {!Array} tb Second tuple.
 * @return {number} -1, 0, or 1 to signify greater than, equality, or less than.
 * @private
 */
Procedures.procTupleComparator_ = function (ta, tb) {
    return ta[0].toLowerCase().localeCompare(tb[0].toLowerCase());
};

/**
 * Ensure two identically-named procedures don't exist.
 * Take the proposed procedure name, and return a legal name i.e. one that
 * is not empty and doesn't collide with other procedures.
 * @param {string} name Proposed procedure name.
 * @param {!Blockly.Block} block Block to disambiguate.
 * @return {string} Non-colliding name.
 */
Procedures.findLegalName = function (name, block) {
    if (block.isInFlyout) {
        // Flyouts can have multiple procedures called 'do something'.
        return name;
    }
    name = name || blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['UNNAMED_KEY'] || 'unnamed';
    while (!Procedures.isLegalName_(name, block.workspace, block)) {
        // Collision with another procedure.
        var r = name.match(/^(.*?)(\d+)$/);
        if (!r) {
            name += '2';
        } else {
            name = r[1] + (parseInt(r[2], 10) + 1);
        }
    }
    return name;
};

/**
 * Does this procedure have a legal name?  Illegal names include names of
 * procedures already defined.
 * @param {string} name The questionable name.
 * @param {!Blockly.Workspace} workspace The workspace to scan for collisions.
 * @param {Blockly.Block=} opt_exclude Optional block to exclude from
 *     comparisons (one doesn't want to collide with oneself).
 * @return {boolean} True if the name is legal.
 * @private
 */
Procedures.isLegalName_ = function (name, workspace, opt_exclude) {
    return !Procedures.isNameUsed(name, workspace, opt_exclude);
};

/**
 * Return if the given name is already a procedure name.
 * @param {string} name The questionable name.
 * @param {!Blockly.Workspace} workspace The workspace to scan for collisions.
 * @param {Blockly.Block=} opt_exclude Optional block to exclude from
 *     comparisons (one doesn't want to collide with oneself).
 * @return {boolean} True if the name is used, otherwise return false.
 */
Procedures.isNameUsed = function (name, workspace, opt_exclude) {
    var blocks = workspace.getAllBlocks(false);
    // Iterate through every block and check the name.
    for (var i = 0; i < blocks.length; i++) {
        if (blocks[i] == opt_exclude) {
            continue;
        }
        if (blocks[i].getProcedureDef) {
            var procName = blocks[i].getProcedureDef();
            if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(procName[0], name)) {
                return true;
            }
        }
    }
    return false;
};

/**
 * Rename a procedure.  Called by the editable field.
 * @param {string} name The proposed new name.
 * @return {string} The accepted name.
 * @this {Blockly.Field}
 */
Procedures.rename = function (name) {
    // Strip leading and trailing whitespace.  Beyond this, all names are legal.
    name = name.trim();

    var legalName = Procedures.findLegalName(name, this.getSourceBlock());
    var oldName = this.getValue();
    if (oldName != name && oldName != legalName) {
        // Rename any callers.
        var blocks = this.getSourceBlock().workspace.getAllBlocks(false);
        for (var i = 0; i < blocks.length; i++) {
            if (blocks[i].renameProcedure) {
                blocks[i].renameProcedure(oldName, legalName);
            }
        }
    }
    return legalName;
};

/**
 * Construct the blocks required by the flyout for the procedure category.
 * @param {!Blockly.Workspace} workspace The workspace containing procedures.
 * @return {!Array.<!Element>} Array of XML block elements.
 */
Procedures.flyoutCategory = function (workspace) {
    var xmlList = [];
    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['procedures_defnoreturn']) {
        // <block type="procedures_defnoreturn" gap="16">
        //     <field name="NAME">do something</field>
        // </block>
        var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        block.setAttribute('type', 'procedures_defnoreturn');
        block.setAttribute('gap', 16);
        var nameField = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('field');
        nameField.setAttribute('name', 'NAME');
        nameField.appendChild(blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createTextNode(
            blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFNORETURN_PROCEDURE']));
        block.appendChild(nameField);
        xmlList.push(block);
    }
    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['procedures_defreturn']) {
        // <block type="procedures_defreturn" gap="16">
        //     <field name="NAME">do something</field>
        // </block>
        var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        block.setAttribute('type', 'procedures_defreturn');
        block.setAttribute('gap', 16);
        var nameField = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('field');
        nameField.setAttribute('name', 'NAME');
        nameField.appendChild(blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createTextNode(
            blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg['PROCEDURES_DEFRETURN_PROCEDURE']));
        block.appendChild(nameField);
        xmlList.push(block);
    }
    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['procedures_return']) {
        // <block type="procedures_return" gap="16"></block>
        var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        block.setAttribute('type', 'procedures_return');
        block.setAttribute('gap', 16);
        xmlList.push(block);
    }
    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['procedures_ifreturn']) {
        // <block type="procedures_ifreturn" gap="16"></block>
        var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        block.setAttribute('type', 'procedures_ifreturn');
        block.setAttribute('gap', 16);
        xmlList.push(block);
    }
    if (xmlList.length) {
        // Add slightly larger gap between system blocks and user calls.
        xmlList[xmlList.length - 1].setAttribute('gap', 24);
    }

    function populateProcedures(procedureList, templateName) {
        for (var i = 0; i < procedureList.length; i++) {
            var name = procedureList[i][0];
            var args = procedureList[i][1];
            // <block type="procedures_callnoreturn" gap="16">
            //   <mutation name="do something">
            //     <arg name="x"></arg>
            //   </mutation>
            // </block>
            var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
            block.setAttribute('type', templateName);
            block.setAttribute('gap', 16);
            var mutation = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('mutation');
            mutation.setAttribute('name', name);
            block.appendChild(mutation);
            for (var j = 0; j < args.length; j++) {
                var arg = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('arg');
                arg.setAttribute('name', args[j]);
                mutation.appendChild(arg);
            }
            xmlList.push(block);
        }
    }

    var tuple = Procedures.allProcedures(workspace);
    populateProcedures(tuple[0], 'procedures_callnoreturn');
    populateProcedures(tuple[1], 'procedures_callreturn');
    return xmlList;
};

/**
 * Find all the callers of a named procedure.
 * @param {string} name Name of procedure.
 * @param {!Blockly.Workspace} workspace The workspace to find callers in.
 * @return {!Array.<!Blockly.Block>} Array of caller blocks.
 */
Procedures.getCallers = function (name, workspace) {
    var callers = [];
    var blocks = workspace.getAllBlocks(false);
    // Iterate through every block and check the name.
    for (var i = 0; i < blocks.length; i++) {
        if (blocks[i].getProcedureCall) {
            var procName = blocks[i].getProcedureCall();
            // Procedure name may be null if the block is only half-built.
            if (procName && blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(procName, name)) {
                callers.push(blocks[i]);
            }
        }
    }
    return callers;
};

/**
 * When a procedure definition changes its parameters, find and edit all its
 * callers.
 * @param {!Blockly.Block} defBlock Procedure definition block.
 */
Procedures.mutateCallers = function (defBlock) {
    const oldRecordUndo = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.getRecordUndo();
    const procedureBlock = defBlock;
    const name = procedureBlock.getProcedureDef()[0];
    const xmlElement = defBlock.mutationToDom(true);
    const callers = blockly_core__WEBPACK_IMPORTED_MODULE_0__.Procedures.getCallers(name, defBlock.workspace);
    for (let i = 0, caller; (caller = callers[i]); i++) {
        const oldMutationDom = caller.mutationToDom();
        const oldMutation = oldMutationDom && blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.domToText(oldMutationDom);
        if (caller.domToMutation) {
            caller.domToMutation(xmlElement);
        }
        const newMutationDom = caller.mutationToDom();
        const newMutation = newMutationDom && blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.domToText(newMutationDom);
        if (oldMutation !== newMutation) {
            // Fire a mutation on every caller block.  But don't record this as an
            // undo action since it is deterministically tied to the procedure's
            // definition mutation.
            blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.setRecordUndo(false);
            blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.fire(
                new (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.get(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.BLOCK_CHANGE))(
                    caller,
                    'mutation',
                    null,
                    oldMutation,
                    newMutation,
                ),
            );
            blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.setRecordUndo(oldRecordUndo);
        }
    }
};

/**
 * Find the definition block for the named procedure.
 * @param {string} name Name of procedure.
 * @param {!Blockly.Workspace} workspace The workspace to search.
 * @return {Blockly.Block} The procedure definition block, or null not found.
 */
Procedures.getDefinition = function (name, workspace) {
    // Assume that a procedure definition is a top block.
    var blocks = workspace.getTopBlocks(false);
    for (var i = 0; i < blocks.length; i++) {
        if (blocks[i].getProcedureDef) {
            var tuple = blocks[i].getProcedureDef();
            if (tuple && blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(tuple[0], name)) {
                return blocks[i];
            }
        }
    }
    return null;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Procedures);

/***/ }),

/***/ "../python/others/variables.js":
/*!*************************************!*\
  !*** ../python/others/variables.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Visual Blocks Editor
 *
 * Copyright 2012 Google Inc.
 * https://developers.google.com/blockly/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Utility functions for handling variables.
 * @author fraser@google.com (Neil Fraser)
 */



const Variables = {};

/**
 * Category to separate variable names from procedures and generated functions.
 */
Variables.NAME_TYPE = 'VARIABLE';

/**
 * Find all user-created variables.
 * @param {!Blockly.Block|!Blockly.Workspace} root Root block or workspace.
 * @return {!Array.<string>} Array of variable names.
 */
Variables.allVariables = function (root) {
    var blocks;
    if (root.getDescendants) {
        // Root is Block.
        blocks = root.getDescendants();
    } else if (root.getAllBlocks) {
        // Root is Workspace.
        blocks = root.getAllBlocks();
    } else {
        throw 'Not Block or Workspace: ' + root;
    }
    var variableHash = Object.create(null);
    // Iterate through every block and add each variable to the hash.
    for (var x = 0; x < blocks.length; x++) {
        var blockVariables = blocks[x].getVars();
        for (var y = 0; y < blockVariables.length; y++) {
            var varName = blockVariables[y];
            // Variable name may be null if the block is only half-built.
            if (varName) {
                variableHash[varName.toLowerCase()] = varName;
            }
        }
    }
    // Flatten the hash into a list.
    var variableList = [];
    for (var name in variableHash) {
        variableList.push(variableHash[name]);
    }
    return variableList;
};

/**
 * Find all instances of the specified variable and rename them.
 * @param {string} oldName Variable to rename.
 * @param {string} newName New variable name.
 * @param {!Blockly.Workspace} workspace Workspace rename variables in.
 */
Variables.renameVariable = function (oldName, newName, workspace) {
    blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.setGroup(true);
    var blocks = workspace.getAllBlocks();
    // Iterate through every block.
    for (var i = 0; i < blocks.length; i++) {
        blocks[i].renameVar(oldName, newName);
    }
    blockly_core__WEBPACK_IMPORTED_MODULE_0__.Events.setGroup(false);
};

/**
 * Construct the blocks required by the flyout for the variable category.
 * @param {!Blockly.Workspace} workspace The workspace contianing variables.
 * @return {!Array.<!Element>} Array of XML block elements.
 */
Variables.flyoutCategory = function (workspace) {
    var variableList = Variables.allVariables(workspace);
    //variableList.sort(goog.string.caseInsensitiveCompare);
    // In addition to the user's variables, we also want to display the default
    // variable name at the top.  We also don't want this duplicated if the
    // user has created a variable of the same name.
    // alert(variableList)
    // goog.array.remove(variableList, Blockly.Msg.VARIABLES_DEFAULT_NAME);
    // variableList.unshift(Blockly.Msg.VARIABLES_DEFAULT_NAME);

    var xmlList = [];

    var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
    block.setAttribute('type', 'variables_global');
    xmlList.push(block);

    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['variables_set']) {
        //增加variables_declare模块
        var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        block.setAttribute('type', 'variables_set');
        xmlList.push(block);
    }//change tyep
    /*
      if (Blockly.Blocks['variables_change']) {
          //增加variables_declare模块
          var block = Blockly.utils.xml.createElement('block');
          block.setAttribute('type', 'variables_change');
          xmlList.push(block);
      }*/
    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['variables_change']) {
        //增加variables_declare模块
        var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        block.setAttribute('type', 'variables_change');
        xmlList.push(block);
    }
    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['controls_type']) {
        var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        block.setAttribute('type', 'controls_type');
        xmlList.push(block);
    }
    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['controls_typeLists']) {
        var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        block.setAttribute('type', 'controls_typeLists');
        xmlList.push(block);
    }
    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['lists_zip']) {
        var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        block.setAttribute('type', 'lists_zip');
        block.setAttribute('inline', 'false');
        var mutation = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('mutation');
        mutation.setAttribute('items', 2);
        block.appendChild(mutation);
        for (let i = 0; i < 2; i++) {
            let add = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('value');
            add.setAttribute('name', `ADD${i}`);
            // let childBlock = Blockly.utils.xml.createElement('block');
            // childBlock.setAttribute('type', 'list_many_input');
            // let field = Blockly.utils.xml.createElement('field');
            // let value = Blockly.utils.xml.createTextNode('0,1,2,3');
            // field.setAttribute('name', 'CONTENT');
            // field.appendChild(value);
            // childBlock.appendChild(field);
            // add.appendChild(childBlock);
            block.appendChild(add);
        }
        xmlList.push(block);
    }
    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['unpack_iterable_object']) {
        var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
        block.setAttribute('type', 'unpack_iterable_object');
        xmlList.push(block);
    }
    for (var i = 0; i < variableList.length; i++) {
        // alert(variableList)
        // if(i==0&& !(Blockly.Python.setups_['variables_set'+''])){
        // 	continue;
        // }
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['variables_set']) {
            var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
            block.setAttribute('type', 'variables_set');
            if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['variables_get']) {
                block.setAttribute('gap', 8);
            }
            var field = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('field', null, variableList[i]);
            field.setAttribute('name', 'VAR');
            var name = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createTextNode(variableList[i]);
            field.appendChild(name);
            block.appendChild(field);
            xmlList.push(block);
        }
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['variables_get']) {
            var block = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('block');
            block.setAttribute('type', 'variables_get');
            if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks['variables_set']) {
                block.setAttribute('gap', 24);
            }
            var field = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createElement('field', null, variableList[i]);
            field.setAttribute('name', 'VAR');
            var name = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.xml.createTextNode(variableList[i]);
            field.appendChild(name);
            block.appendChild(field);
            xmlList.push(block);
        }
    }
    return xmlList;
};

/**
* Return a new variable name that is not yet being used. This will try to
* generate single letter variable names in the range 'i' to 'z' to start with.
* If no unique name is located it will try 'i' to 'z', 'a' to 'h',
* then 'i2' to 'z2' etc.  Skip 'l'.
 * @param {!Blockly.Workspace} workspace The workspace to be unique in.
* @return {string} New variable name.
*/
Variables.generateUniqueName = function (workspace) {
    var variableList = Variables.allVariables(workspace);
    var newName = '';
    if (variableList.length) {
        var nameSuffix = 1;
        var letters = 'ijkmnopqrstuvwxyzabcdefgh';  // No 'l'.
        var letterIndex = 0;
        var potName = letters.charAt(letterIndex);
        while (!newName) {
            var inUse = false;
            for (var i = 0; i < variableList.length; i++) {
                if (variableList[i].toLowerCase() == potName) {
                    // This potential name is already used.
                    inUse = true;
                    break;
                }
            }
            if (inUse) {
                // Try the next potential name.
                letterIndex++;
                if (letterIndex == letters.length) {
                    // Reached the end of the character sequence so back to 'i'.
                    // a new suffix.
                    letterIndex = 0;
                    nameSuffix++;
                }
                potName = letters.charAt(letterIndex);
                if (nameSuffix > 1) {
                    potName += nameSuffix;
                }
            } else {
                // We can use the current potential name.
                newName = potName;
            }
        }
    } else {
        newName = 'i';
    }
    return newName;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Variables);

/***/ }),

/***/ "../python/python_generator.js":
/*!*************************************!*\
  !*** ../python/python_generator.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Python: () => (/* binding */ Python)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _others_names__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./others/names */ "../python/others/names.js");
/*
Overrides for generic Python code generation.
*/



/**
 * Python code generator.
 * @type {!Blockly.Generator}
 */
const Python = new blockly_core__WEBPACK_IMPORTED_MODULE_0__.Generator('Python');
Python.INDENT = "    ";

/**
 * List of illegal variable names.
 * This is not intended to be a security feature.  Blockly is 100% client-side,
 * so bypassing this list is trivial.  This is intended to prevent users from
 * accidentally clobbering a built-in object or function.
 * @private
 */
Python.addReservedWords(
    // import keyword
    // print(','.join(sorted(keyword.kwlist)))
    // https://docs.python.org/3/reference/lexical_analysis.html#keywords
    // https://docs.python.org/2/reference/lexical_analysis.html#keywords
    'False,None,True,and,as,assert,break,class,continue,def,del,elif,else,' +
    'except,exec,finally,for,from,global,if,import,in,is,lambda,nonlocal,not,' +
    'or,pass,print,raise,return,try,while,with,yield,' +
    // https://docs.python.org/3/library/constants.html
    // https://docs.python.org/2/library/constants.html
    'NotImplemented,Ellipsis,__debug__,quit,exit,copyright,license,credits,' +
    // >>> print(','.join(sorted(dir(__builtins__))))
    // https://docs.python.org/3/library/functions.html
    // https://docs.python.org/2/library/functions.html
    'ArithmeticError,AssertionError,AttributeError,BaseException,' +
    'BlockingIOError,BrokenPipeError,BufferError,BytesWarning,' +
    'ChildProcessError,ConnectionAbortedError,ConnectionError,' +
    'ConnectionRefusedError,ConnectionResetError,DeprecationWarning,EOFError,' +
    'Ellipsis,EnvironmentError,Exception,FileExistsError,FileNotFoundError,' +
    'FloatingPointError,FutureWarning,GeneratorExit,IOError,ImportError,' +
    'ImportWarning,IndentationError,IndexError,InterruptedError,' +
    'IsADirectoryError,KeyError,KeyboardInterrupt,LookupError,MemoryError,' +
    'ModuleNotFoundError,NameError,NotADirectoryError,NotImplemented,' +
    'NotImplementedError,OSError,OverflowError,PendingDeprecationWarning,' +
    'PermissionError,ProcessLookupError,RecursionError,ReferenceError,' +
    'ResourceWarning,RuntimeError,RuntimeWarning,StandardError,' +
    'StopAsyncIteration,StopIteration,SyntaxError,SyntaxWarning,SystemError,' +
    'SystemExit,TabError,TimeoutError,TypeError,UnboundLocalError,' +
    'UnicodeDecodeError,UnicodeEncodeError,UnicodeError,' +
    'UnicodeTranslateError,UnicodeWarning,UserWarning,ValueError,Warning,' +
    'ZeroDivisionError,_,__build_class__,__debug__,__doc__,__import__,' +
    '__loader__,__name__,__package__,__spec__,abs,all,any,apply,ascii,' +
    'basestring,bin,bool,buffer,bytearray,bytes,callable,chr,classmethod,cmp,' +
    'coerce,compile,complex,copyright,credits,delattr,dict,dir,divmod,' +
    'enumerate,eval,exec,execfile,exit,file,filter,float,format,frozenset,' +
    'getattr,globals,hasattr,hash,help,hex,id,input,int,intern,isinstance,' +
    'issubclass,iter,len,license,list,locals,long,map,max,memoryview,min,' +
    'next,object,oct,open,ord,pow,print,property,quit,range,raw_input,reduce,' +
    'reload,repr,reversed,round,set,setattr,slice,sorted,staticmethod,str,' +
    'sum,super,tuple,type,unichr,unicode,vars,xrange,zip'
);

/**
 * Order of operation ENUMs.
 * http://docs.python.org/reference/expressions.html#summary
 */
Python.ORDER_ATOMIC = 0;            // 0 "" ...
Python.ORDER_COLLECTION = 1;        // tuples, lists, dictionaries
Python.ORDER_STRING_CONVERSION = 1; // `expression...`
Python.ORDER_UNARY_POSTFIX = 1;     // expr++ expr-- () [] .
Python.ORDER_UNARY_PREFIX = 2;      // -expr !expr ~expr ++expr --expr
Python.ORDER_MEMBER = 2.1;          // . []
Python.ORDER_FUNCTION_CALL = 2.2;   // ()
Python.ORDER_EXPONENTIATION = 3;    // **
Python.ORDER_UNARY_SIGN = 4;        // + -
Python.ORDER_BITWISE_NOT = 4;       // ~
Python.ORDER_MULTIPLICATIVE = 5;    // * / // %
Python.ORDER_ADDITIVE = 6;          // + -
Python.ORDER_BITWISE_SHIFT = 7;     // << >>
Python.ORDER_BITWISE_AND = 8;       // &
Python.ORDER_BITWISE_XOR = 9;       // ^
Python.ORDER_BITWISE_OR = 10;       // |
Python.ORDER_RELATIONAL = 11;       // in, not in, is, is not,
//     <, <=, >, >=, <>, !=, ==
Python.ORDER_EQUALITY = 11;          // == != === !==
Python.ORDER_LOGICAL_NOT = 12;      // not
Python.ORDER_LOGICAL_AND = 13;      // and
Python.ORDER_LOGICAL_OR = 14;       // or
Python.ORDER_ASSIGNMENT = 14; // = *= /= ~/= %= += -= <<= >>= &= ^= |=
Python.ORDER_CONDITIONAL = 15;      // if else
Python.ORDER_LAMBDA = 16;           // lambda
Python.ORDER_NONE = 99;             // (...)

/**
 * List of outer-inner pairings that do NOT require parentheses.
 * @type {!Array.<!Array.<number>>}
 */
Python.ORDER_OVERRIDES = [
    // (foo()).bar -> foo().bar
    // (foo())[0] -> foo()[0]
    [Python.ORDER_FUNCTION_CALL, Python.ORDER_MEMBER],
    // (foo())() -> foo()()
    [Python.ORDER_FUNCTION_CALL, Python.ORDER_FUNCTION_CALL],
    // (foo.bar).baz -> foo.bar.baz
    // (foo.bar)[0] -> foo.bar[0]
    // (foo[0]).bar -> foo[0].bar
    // (foo[0])[1] -> foo[0][1]
    [Python.ORDER_MEMBER, Python.ORDER_MEMBER],
    // (foo.bar)() -> foo.bar()
    // (foo[0])() -> foo[0]()
    [Python.ORDER_MEMBER, Python.ORDER_FUNCTION_CALL],

    // not (not foo) -> not not foo
    // [Python.ORDER_LOGICAL_NOT, Python.ORDER_LOGICAL_NOT],
    // a and (b and c) -> a and b and c
    // [Python.ORDER_LOGICAL_AND, Python.ORDER_LOGICAL_AND],
    // a or (b or c) -> a or b or c
    // [Python.ORDER_LOGICAL_OR, Python.ORDER_LOGICAL_OR]
];

Python.init = function () {
    /**
      * Empty loops or conditionals are not allowed in Python.
      */
    Python.PASS = this.INDENT + 'pass\n';
    // Create a dictionary of definitions to be printed before the code.
    Python.definitions_ = Object.create(null);
    // Create a dictionary mapping desired function names in definitions_
    // to actual function names (to avoid collisions with user functions).
    Python.functionNames_ = Object.create(null);
    Python.setups_ = Object.create(null);
    Python.loops_ = Object.create(null);
    Python.codeEnd_ = Object.create(null);

    if (!Python.variableDB_) {
        Python.variableDB_ = new _others_names__WEBPACK_IMPORTED_MODULE_1__["default"](Python.RESERVED_WORDS_);
    } else {
        Python.variableDB_.reset();
    }
}

Python.finish = function (code) {
    // Convert the definitions dictionary into a list.
    if (code !== "") {
        code = code.replace(/\n/g, '\n');
        code = code.replace(/\n\s+$/, '\n');
    }
    var definitions = [];
    for (var name in Python.definitions_) {
        definitions.push(Python.definitions_[name]);
    }
    var functions = [];
    for (var name in Python.functions_) {
        functions.push(Python.functions_[name]);
    }
    var setups = [];
    for (var name in Python.setups_) {
        setups.push(Python.setups_[name]);
    }
    if (setups.length !== 0)
        setups.push('\n');
    var loops = [];
    for (var name in Python.loops_) {
        loops.push(Python.loops_[name]);
    }
    var codeEnd = [];
    for (var name in Python.codeEnd_) {
        codeEnd.push(Python.codeEnd_[name]);
    }
    if (codeEnd.length !== 0)
        codeEnd.push('\n');
    // Clean up temporary data.
    //delete Python.definitions_;
    //delete Python.functionNames_;
    //Python.variableDB_.reset();
    if (loops.length > 0)
        return definitions.join('\n') + '\n' + functions.join('\n') + '\n' + setups.join('') + '\n' + code + 'while True:\n' + loops.join('') + codeEnd.join('\n');
    return definitions.join('\n') + '\n' + functions.join('\n') + '\n' + setups.join('') + '\n' + code + codeEnd.join('\n');
}


/**
 * Naked values are top-level blocks with outputs that aren't plugged into
 * anything.
 * @param {string} line Line of generated code.
 * @return {string} Legal line of code.
 */
Python.scrubNakedValue = function (line) {
    return line + '\n';
}

/**
 * Encode a string as a properly escaped Python string, complete with quotes.
 * @param {string} string Text to encode.
 * @return {string} Python string.
 * @private
 */
Python.quote_ = function (string) {
    // Can't use goog.string.quote since % must also be escaped.
    string = string.replace(/\\/g, '\\\\')
        .replace(/\n/g, '\\\n');

    // Follow the CPython behaviour of repr() for a non-byte string.
    var quote = '\'';
    if (string.indexOf('\'') !== -1) {
        if (string.indexOf('"') === -1) {
            quote = '"';
        } else {
            string = string.replace(/'/g, '\\\'');
        }
    }
    return quote + string + quote;
}

/**
 * Encode a string as a properly escaped multiline Python string, complete
 * with quotes.
 * @param {string} string Text to encode.
 * @return {string} Python string.
 * @private
 */
Python.multiline_quote_ = function (string) {
    // Can't use goog.string.quote since % must also be escaped.
    string = string.replace(/'''/g, '\\\'\\\'\\\'');
    return '\'\'\'' + string + '\'\'\'';
}

/**
 * Common tasks for generating Python from blocks.
 * Handles comments for the specified block and any connected value blocks.
 * Calls any statements following this block.
 * @param {!Blockly.Block} block The current block.
 * @param {string} code The Python code created for this block.
 * @param {boolean=} opt_thisOnly True to generate code for only this statement.
 * @return {string} Python code with comments and subsequent blocks added.
 * @private
 */
Python.scrub_ = function (block, code, opt_thisOnly) {
    var commentCode = '';
    // Only collect comments for blocks that aren't inline.
    if (!block.outputConnection || !block.outputConnection.targetConnection) {
        // Collect comment for this block.
        var comment = block.getCommentText();
        if (comment) {
            comment = blockly_core__WEBPACK_IMPORTED_MODULE_0__.utils.string.wrap(comment,
                Python.COMMENT_WRAP - 3);
            commentCode += Python.prefixLines(comment + '\n', '# ');
        }
        // Collect comments for all value arguments.
        // Don't collect comments for nested statements.
        for (var i = 0; i < block.inputList.length; i++) {
            if (block.inputList[i].type == blockly_core__WEBPACK_IMPORTED_MODULE_0__.INPUT_VALUE) {
                var childBlock = block.inputList[i].connection.targetBlock();
                if (childBlock) {
                    var comment = Python.allNestedComments(childBlock);
                    if (comment) {
                        commentCode += Python.prefixLines(comment, '# ');
                    }
                }
            }
        }
    }
    var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
    var nextCode = opt_thisOnly ? '' : Python.blockToCode(nextBlock);
    return commentCode + code + nextCode;
}

/**
 * Gets a property and adjusts the value, taking into account indexing, and
 * casts to an integer.
 * @param {!Blockly.Block} block The block.
 * @param {string} atId The property ID of the element to get.
 * @param {number=} opt_delta Value to add.
 * @param {boolean=} opt_negate Whether to negate the value.
 * @return {string|number}
 */
Python.getAdjustedInt = function (block, atId, opt_delta, opt_negate) {
    var delta = opt_delta || 0;
    if (block.workspace.options.oneBasedIndex) {
        delta--;
    }
    var defaultAtIndex = block.workspace.options.oneBasedIndex ? '1' : '0';
    var atOrder = delta ? Python.ORDER_ADDITIVE :
        Python.ORDER_NONE;
    var at = Python.valueToCode(block, atId, atOrder) || defaultAtIndex;

    if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.isNumber(at)) {
        // If the index is a naked number, adjust it right now.
        at = parseInt(at, 10) + delta;
        if (opt_negate) {
            at = -at;
        }
    } else {
        // If the index is dynamic, adjust it in code.
        if (delta > 0) {
            at = 'int(' + at + ' + ' + delta + ')';
        } else if (delta < 0) {
            at = 'int(' + at + ' - ' + -delta + ')';
        } else {
            at = 'int(' + at + ')';
        }
        if (opt_negate) {
            at = '-' + at;
        }
    }
    return at;
}

/***/ }),

/***/ "../python_mixpy/blocks/ai.js":
/*!************************************!*\
  !*** ../python_mixpy/blocks/ai.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AI_ChooseAndGet: () => (/* binding */ AI_ChooseAndGet),
/* harmony export */   AI_Face_match: () => (/* binding */ AI_Face_match),
/* harmony export */   AI_ImageClassify: () => (/* binding */ AI_ImageClassify),
/* harmony export */   AI_ImageClassify_Func: () => (/* binding */ AI_ImageClassify_Func),
/* harmony export */   AI_Nlp: () => (/* binding */ AI_Nlp),
/* harmony export */   AI_Nlp_Func: () => (/* binding */ AI_Nlp_Func),
/* harmony export */   AI_Nlp_Func_sim: () => (/* binding */ AI_Nlp_Func_sim),
/* harmony export */   AI_Nlp_Sim: () => (/* binding */ AI_Nlp_Sim),
/* harmony export */   AI_Nlp_Topic: () => (/* binding */ AI_Nlp_Topic),
/* harmony export */   AI_Nlp_newsSummary: () => (/* binding */ AI_Nlp_newsSummary),
/* harmony export */   AI_Ocr: () => (/* binding */ AI_Ocr),
/* harmony export */   AI_Ocr_Func: () => (/* binding */ AI_Ocr_Func),
/* harmony export */   AI_Speech_asr: () => (/* binding */ AI_Speech_asr),
/* harmony export */   AI_Speech_synthesis: () => (/* binding */ AI_Speech_synthesis),
/* harmony export */   AI_audio: () => (/* binding */ AI_audio),
/* harmony export */   AI_client: () => (/* binding */ AI_client),
/* harmony export */   AI_photo: () => (/* binding */ AI_photo),
/* harmony export */   AI_result: () => (/* binding */ AI_result)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const AI_HUE = 205;

const AI_ChooseAndGet = {
    init: function () {
        this.setColour(AI_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CHOOSE_AND_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CHOOSE_AND_GET_ONE_FILE_NAME, "getOneFile"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CHOOSE_AND_GET_MANY_FILE_NAMES, "getManyFiles"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CHOOSE_AND_GET_DIR, "getDirectory"]
            ]), 'TYPE');
        this.setInputsInline(true);
        this.setOutput(true);
    }
}

const AI_client = {
    init: function () {
        this.setColour(AI_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SETUP)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify, "AipImageClassify"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipSpeech, "AipSpeech"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageCensor, "AipImageCensor"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipFace, "AipFace"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr, "AipOcr"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp, "AipNlp"]
            ]), 'CTYPE')
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('API_KEY')
            .appendField('API_KEY')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('SECRET_KEY')
            .appendField('SECRET_KEY')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setInputsInline(false);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const AI_Speech_synthesis = { //  AI_TYPE_FUNC
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipSpeech_synthesis)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('STR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.OLED_STRING)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('ATTR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipSpeech_synthesis_TOOLTIP)
        this.setInputsInline(false);
        this.setOutput(true);
    }
};

const AI_Speech_asr = { //  AI_TYPE_FUNC
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipSpeech_asr)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('FILE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipSpeech_File)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('ATTR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipSpeech_ASR_TOOLTIP)
        this.setInputsInline(false);
        this.setOutput(true);
    }
};

const AI_ImageClassify = { //  AI_TYPE_FUNC
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('FUNC')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_FUNC)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('ADDR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_Image)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('ATTR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_advancedGeneral_TOOLTIP)
        this.setInputsInline(false);
        this.setOutput(true);
    }
};


const AI_ImageClassify_Func = {
    init: function () {
        this.setColour(AI_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_advancedGeneral, "advancedGeneral"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_dishDetect, "dishDetect"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_carDetect, "carDetect"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_animalDetect, "animalDetect"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_plantDetect, "plantDetect"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_logoSearch, "logoSearch"]
            ]), 'TYPE')
        this.setOutput(true);
    }
};

const AI_Face_match = { //  AI_TYPE_FUNC
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipFace_match)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_Image + '1' + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_THE_PATH)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('VAR2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_Image + '2' + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_THE_PATH)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('ATTR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipFace_match_TOOLTIP)
        this.setInputsInline(false);
        this.setOutput(true);
    }
};

const AI_Ocr = { //  AI_TYPE_FUNC
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('FUNC')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_FUNC)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('ADDR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify_Image)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('ATTR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_TOOLTIP)
        this.setInputsInline(false);
        this.setOutput(true);
    }
};


const AI_Ocr_Func = {
    init: function () {
        this.setColour(AI_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_basicGeneral, "basicGeneral"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_webImage, "webImage"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_idcard, "idcard"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_bankcard, "bankcard"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_drivingLicense, "drivingLicense"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_vehicleLicense, "vehicleLicense"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_licensePlate, "licensePlate"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_businessLicense, "businessLicense"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_receipt, "receipt"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_trainTicket, "trainTicket"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_taxiReceipt, "taxiReceipt"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_form, "tableRecognition"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_vatInvoice, "vatInvoice"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_passport, "passport"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr_handwriting, "handwriting"]
            ]), 'TYPE')
        this.setOutput(true);
    }
};

const AI_Nlp = { //  AI_TYPE_FUNC
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('FUNC')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_FUNC)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('STR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.OLED_STRING)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('ATTR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_TOOLTIP)
        this.setInputsInline(false);
        this.setOutput(true);
    }
};

const AI_Nlp_Sim = { //  AI_TYPE_FUNC
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_Sim)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('FUNC')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_FUNC)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('STR1')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.OLED_STRING + '1')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('STR2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.OLED_STRING + '2')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('ATTR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_Sim_TOOLTIP)
        this.setInputsInline(false);
        this.setOutput(true);
    }
};

const AI_Nlp_Func = {
    init: function () {
        this.setColour(AI_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_lexer, "lexer"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_depParser, "depParser"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_wordEmbedding, "wordEmbedding"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_dnnlm, "dnnlm"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_commentTag, "commentTag"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_sentimentClassify, "sentimentClassify"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_keyword, "keyword"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_topic, "topic"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_ecnet, "ecnet"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_emotion, "emotion"]
            ]), 'TYPE')
        this.setOutput(true);
    }
};

const AI_Nlp_Func_sim = {
    init: function () {
        this.setColour(AI_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_wordSimEmbedding, "wordSimEmbedding"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_simnet, "simnet"]
            ]), 'TYPE')
        this.setOutput(true);
    }
};

const AI_Nlp_Topic = { //  AI_TYPE_FUNC
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_topic)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('STR1')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_Topic_Title)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('STR2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_Topic_Content)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_Topic_TOOLTIP)
        this.setInputsInline(false);
        this.setOutput(true);
    }
};

const AI_Nlp_newsSummary = { //  AI_TYPE_FUNC
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_summary)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('STR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_Topic_Content)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('LEN')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LIST_LEN)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('ATTR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_Summary_TOOLTIP)
        this.setInputsInline(false);
        this.setOutput(true);
    }
};


// [Blockly.Msg.MIXLY_AipNlp_topic, "topic"]
// [Blockly.Msg.MIXLY_AipNlp_keyword, "keyword"]

const AI_audio = {
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_AI_AUDIO);
        this.appendValueInput("TIME")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_AI_AUDIO_TIME);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_AI_AUDIO_TOOLTIP);
    }
};

const AI_photo = {
    init: function () {
        this.setColour(AI_HUE);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_AI_PHOTO);
        this.appendValueInput("BUT")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_AI_PHOTO_BUTTON);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_AI_PHOTO_TOOLTIP);
    }
};

const AI_result = {
    /**
     * Block for negation.
     * @this Blockly.Block
     */
    init: function () {

        this.setColour(AI_HUE);

        this.appendValueInput('AI')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_AI_RESULT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipImageClassify, "Image"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipSpeech_asr, "Speech"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipFace_match, "Face"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipOcr, "Ocr"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_simnet, "OcrSimilarity"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_sentimentClassify, "Emotion"],
            ]), 'CTYPE')

        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOGIC_NEGATE_TOOLTIP);
    }
};


/***/ }),

/***/ "../python_mixpy/blocks/algorithm.js":
/*!*******************************************!*\
  !*** ../python_mixpy/blocks/algorithm.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   algorithm_add_path: () => (/* binding */ algorithm_add_path),
/* harmony export */   algorithm_add_school: () => (/* binding */ algorithm_add_school),
/* harmony export */   algorithm_all_books: () => (/* binding */ algorithm_all_books),
/* harmony export */   algorithm_all_books_sequence: () => (/* binding */ algorithm_all_books_sequence),
/* harmony export */   algorithm_book_scale: () => (/* binding */ algorithm_book_scale),
/* harmony export */   algorithm_check_feet: () => (/* binding */ algorithm_check_feet),
/* harmony export */   algorithm_chick_calculate: () => (/* binding */ algorithm_chick_calculate),
/* harmony export */   algorithm_color_seclet: () => (/* binding */ algorithm_color_seclet),
/* harmony export */   algorithm_current_school: () => (/* binding */ algorithm_current_school),
/* harmony export */   algorithm_del_path: () => (/* binding */ algorithm_del_path),
/* harmony export */   algorithm_delete_book: () => (/* binding */ algorithm_delete_book),
/* harmony export */   algorithm_delete_books: () => (/* binding */ algorithm_delete_books),
/* harmony export */   algorithm_delete_books2: () => (/* binding */ algorithm_delete_books2),
/* harmony export */   algorithm_divide_books: () => (/* binding */ algorithm_divide_books),
/* harmony export */   algorithm_find_path: () => (/* binding */ algorithm_find_path),
/* harmony export */   algorithm_first_book: () => (/* binding */ algorithm_first_book),
/* harmony export */   algorithm_fz_calc: () => (/* binding */ algorithm_fz_calc),
/* harmony export */   algorithm_fz_calc_first_min: () => (/* binding */ algorithm_fz_calc_first_min),
/* harmony export */   algorithm_fz_compare: () => (/* binding */ algorithm_fz_compare),
/* harmony export */   algorithm_fz_move: () => (/* binding */ algorithm_fz_move),
/* harmony export */   algorithm_fz_set_min: () => (/* binding */ algorithm_fz_set_min),
/* harmony export */   algorithm_get_book_num: () => (/* binding */ algorithm_get_book_num),
/* harmony export */   algorithm_get_current_location: () => (/* binding */ algorithm_get_current_location),
/* harmony export */   algorithm_get_half_books: () => (/* binding */ algorithm_get_half_books),
/* harmony export */   algorithm_hxdb_add: () => (/* binding */ algorithm_hxdb_add),
/* harmony export */   algorithm_hxdb_init_soldier: () => (/* binding */ algorithm_hxdb_init_soldier),
/* harmony export */   algorithm_hxdb_last_line: () => (/* binding */ algorithm_hxdb_last_line),
/* harmony export */   algorithm_hxdb_result: () => (/* binding */ algorithm_hxdb_result),
/* harmony export */   algorithm_hxdb_stand_in_line: () => (/* binding */ algorithm_hxdb_stand_in_line),
/* harmony export */   algorithm_init_fzsf: () => (/* binding */ algorithm_init_fzsf),
/* harmony export */   algorithm_init_hxdb: () => (/* binding */ algorithm_init_hxdb),
/* harmony export */   algorithm_init_jttl: () => (/* binding */ algorithm_init_jttl),
/* harmony export */   algorithm_move_recent: () => (/* binding */ algorithm_move_recent),
/* harmony export */   algorithm_new_path: () => (/* binding */ algorithm_new_path),
/* harmony export */   algorithm_next_book: () => (/* binding */ algorithm_next_book),
/* harmony export */   algorithm_no_left: () => (/* binding */ algorithm_no_left),
/* harmony export */   algorithm_no_path: () => (/* binding */ algorithm_no_path),
/* harmony export */   algorithm_no_ring2: () => (/* binding */ algorithm_no_ring2),
/* harmony export */   algorithm_not_home: () => (/* binding */ algorithm_not_home),
/* harmony export */   algorithm_not_school: () => (/* binding */ algorithm_not_school),
/* harmony export */   algorithm_number_add: () => (/* binding */ algorithm_number_add),
/* harmony export */   algorithm_number_zero: () => (/* binding */ algorithm_number_zero),
/* harmony export */   algorithm_prepare: () => (/* binding */ algorithm_prepare),
/* harmony export */   algorithm_prepare2: () => (/* binding */ algorithm_prepare2),
/* harmony export */   algorithm_prepare_2_1: () => (/* binding */ algorithm_prepare_2_1),
/* harmony export */   algorithm_prepare_2_2: () => (/* binding */ algorithm_prepare_2_2),
/* harmony export */   algorithm_print_book2: () => (/* binding */ algorithm_print_book2),
/* harmony export */   algorithm_print_divide: () => (/* binding */ algorithm_print_divide),
/* harmony export */   algorithm_print_jttl_answer: () => (/* binding */ algorithm_print_jttl_answer),
/* harmony export */   algorithm_print_number: () => (/* binding */ algorithm_print_number),
/* harmony export */   algorithm_print_path: () => (/* binding */ algorithm_print_path),
/* harmony export */   algorithm_print_path2: () => (/* binding */ algorithm_print_path2),
/* harmony export */   algorithm_print_sequence: () => (/* binding */ algorithm_print_sequence),
/* harmony export */   algorithm_rabbit_add: () => (/* binding */ algorithm_rabbit_add),
/* harmony export */   algorithm_rabbit_number_in_range: () => (/* binding */ algorithm_rabbit_number_in_range),
/* harmony export */   algorithm_rabbit_zero: () => (/* binding */ algorithm_rabbit_zero),
/* harmony export */   algorithm_return_path: () => (/* binding */ algorithm_return_path),
/* harmony export */   algorithm_set_path: () => (/* binding */ algorithm_set_path),
/* harmony export */   algorithm_two_left: () => (/* binding */ algorithm_two_left),
/* harmony export */   algorithm_void_path: () => (/* binding */ algorithm_void_path),
/* harmony export */   algorithm_yes_ring2: () => (/* binding */ algorithm_yes_ring2),
/* harmony export */   hanoi_init: () => (/* binding */ hanoi_init),
/* harmony export */   hanoi_init_offline: () => (/* binding */ hanoi_init_offline),
/* harmony export */   hanoi_move: () => (/* binding */ hanoi_move)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const ALGORITHM_HUE = '#526FC3';

// sub_algorithm_1

const algorithm_prepare = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_PREPARE);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_add_school = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_ADD_SCHOOL);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_find_path = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_FIND_PATH);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_new_path = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_NEW_PATH);
        this.setOutput(true);
    }
}

const algorithm_set_path = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_SET_PATH);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_add_path = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_ADD_PATH);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_del_path = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_DEL_PATH);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_return_path = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_RETURN_PATH);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_no_left = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_NO_LEFT);
        this.setOutput(true);
    }
}

const algorithm_print_path = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_PRINT_PATH);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

// sub_algorithm_2

const algorithm_prepare2 = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_PREPARE2);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_current_school = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_CURRENT_SCHOOL);
        this.setOutput(true);
    }
}

const algorithm_no_path = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_NO_PATH);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

// sub_algorithm_3

const algorithm_prepare_2_1 = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_PREPARE_2_1);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_prepare_2_2 = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_PREPARE_2_2);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_move_recent = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_MOVE_RECENT);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_not_home = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_NOT_HOME);
        this.setOutput(true);
    }
};

const algorithm_not_school = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_NOT_SCHOOL);
        this.setOutput(true);
    }
};

const algorithm_print_path2 = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_PRINT_PATH2);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

// sub_algorithm_4 hanoi

const hanoi_init = {
    init: function () {
        this.appendDummyInput()
            .appendField("准备")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldNumber(3, 0, 100, 1), "NUM")
            .appendField("层汉诺塔");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const hanoi_move = {
    init: function () {
        this.appendDummyInput()
            .appendField("移动圆盘从");
        this.appendValueInput("FROM_NUM")
            .setCheck(null)
            .appendField("柱");
        this.appendDummyInput()
            .appendField("到");
        this.appendValueInput("TO_NUM")
            .setCheck(null)
            .appendField("柱");
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

// sub_algorithm_5

const algorithm_all_books = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_ALL_BOOKS);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_all_books_sequence = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_ALL_BOOKS2);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_first_book = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_FIRST_BOOK);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

// export const algorithm_no_ring = {
//   init: function() {
//     this.setColour(ALGORITHM_HUE);
//     this.appendDummyInput()
//     .appendField(Blockly.Msg.MIXLY_MIXPY_ALGORITHM_NO_RING);
//     this.setOutput(true);
//   }
// }

const algorithm_no_ring2 = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_NO_RING);
        this.setOutput(true);
    }
};

const algorithm_yes_ring2 = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_YES_RING);
        this.setOutput(true);
    }
};

const algorithm_next_book = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_NEXT_BOOK);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_two_left = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_TWO_LEFT);
        this.setOutput(true);
    }
}

const algorithm_divide_books = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_DIVIDE_BOOKS);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_get_half_books = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_GET_HALF_BOOKS);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

// export const algorithm_check_half_books = {
//   init: function() {
//     this.setColour(ALGORITHM_HUE);
//     this.appendDummyInput()
//     .appendField(Blockly.Msg.MIXLY_MIXPY_ALGORITHM_CHECK_HALF_BOOKS);
//     this.setPreviousStatement(true, null);
//     this.setNextStatement(true, null);
//   }
// };

const algorithm_delete_book = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_DELETE_BOOK);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_delete_books = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_DELETE_BOOKS);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_delete_books2 = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_DELETE_BOOKS2);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

// export const algorithm_print_book = {
//   init: function() {
//     this.setColour(ALGORITHM_HUE);
//     this.appendDummyInput()
//     .appendField(Blockly.Msg.MIXLY_MIXPY_ALGORITHM_PRINT_BOOK);
//     this.setPreviousStatement(true, null);
//     this.setNextStatement(true, null);
//   }
// };

const algorithm_print_book2 = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_PRINT_BOOK);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

// sub_algorithm_6

const algorithm_book_scale = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("设置待查书总数 N=")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ["5", "5"],
                ["10", "10"],
                ["20", "20"],
                ["50", "50"]
            ]), "NUM");
        this.setInputsInline(false);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_number_zero = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_NUMBER_ZERO);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_number_add = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_NUMBER_ADD);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_print_number = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_PRINT_NUMBER);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_get_book_num = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField('n' + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_VALUE2)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('50'), 'NUM');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_print_sequence = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_PRINT_SEQUENCE);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_print_divide = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_PRINT_DIVIDE);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

// sub_algorithm_7

const algorithm_init_jttl = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("初始化鸡兔同笼问题：");
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("有若干只鸡、兔在同一个笼子里。");
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("从上面数鸡兔有10个头，");
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("从下面数鸡兔有32只脚。");
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("问笼中有多少只鸡和多少只兔？");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_rabbit_zero = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("假设兔子的数量为0只");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_rabbit_number_in_range = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("兔子的数量在范围之内");
        this.setOutput(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_chick_calculate = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("根据（头数-兔子数）计算出鸡的数量");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_check_feet = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("计算得到脚的数量正确");
        this.setOutput(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_print_jttl_answer = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("输出鸡、兔的数量");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_rabbit_add = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("假设兔子数量要更多一只");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

// sub_algorithm_8

const algorithm_init_fzsf = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("加载路线图");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_fz_calc = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("计算")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ["S1", "1"],
                ["S2", "2"],
                ["S3", "3"],
                ["S4", "4"]
            ]), "PATHNAME")
            .appendField("长度");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_fz_calc_first_min = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("设置S1为Smin");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_fz_compare = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ["S1", "1"],
                ["S2", "2"],
                ["S3", "3"],
                ["S4", "4"]
            ]), "PATHNAME")
            .appendField("的长度比")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ["S1", "1"],
                ["S2", "2"],
                ["S3", "3"],
                ["S4", "4"]
            ]), "PATHNAME2")
            .appendField("短");
        this.setOutput(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_fz_set_min = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("设置")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ["S1", "1"],
                ["S2", "2"],
                ["S3", "3"],
                ["S4", "4"]
            ]), "PATHNAME")
            .appendField("为Smin");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_fz_move = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("按照Smin移动");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

// sub_algorithm_8

const algorithm_init_hxdb = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("初始化韩信点兵问题：");
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("有未知数量的若干士兵。");
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("若3人一排列队，多1人；");
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("若5人一排列队，多2人；");
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("若7人一排列队，多2人；");
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("问士兵的数量最少是多少人？");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_hxdb_init_soldier = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("初始化士兵为")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput("7"), "NUM")
            .appendField("个");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_hxdb_stand_in_line = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("使士兵")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ["3", "3"],
                ["5", "5"],
                ["7", "7"]
            ]), "NUM")
            .appendField("人一排列队");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_hxdb_last_line = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("剩余")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput("1"), "NUM")
            .appendField("个士兵");
        this.setOutput(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_hxdb_add = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("增加1个士兵");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_hxdb_result = {
    init: function () {
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.LEFT)
            .appendField("输出士兵数量");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

// others

const hanoi_init_offline = {
    init: function () {
        this.appendDummyInput()
            .appendField("准备")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldNumber(3, 0, 100, 1), "NUM")
            .appendField("层汉诺塔");
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_COLOUR);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(ALGORITHM_HUE);
        this.setInputsInline(true);
        this.setTooltip('');
        this.setHelpUrl('');
    }
};

const algorithm_get_current_location = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_GET_CURRENT_LOCATION);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const algorithm_void_path = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_ALGORITHM_VOID_PATH);
        this.setOutput(true);
    }
}

const algorithm_color_seclet = {
    init: function () {
        this.setColour(ALGORITHM_HUE);
        this.appendDummyInput("")
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour("ff0000"), "COLOR");
        this.setInputsInline(true);
        this.setOutput(true, String);
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/communicate.js":
/*!*********************************************!*\
  !*** ../python_mixpy/blocks/communicate.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   requests_attribute: () => (/* binding */ requests_attribute),
/* harmony export */   requests_get: () => (/* binding */ requests_get),
/* harmony export */   requests_get_old: () => (/* binding */ requests_get_old),
/* harmony export */   requests_method: () => (/* binding */ requests_method),
/* harmony export */   requests_post: () => (/* binding */ requests_post)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const COMMUNICATE_HUE = '#3288dd'; //'#3288dd';

const requests_get_old = {
    init: function () {
        this.setColour(COMMUNICATE_HUE);
        this.appendValueInput("DOMAIN")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DISPLAY_IMAGE_LET2)
            .setCheck(String);
        this.appendDummyInput("")

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_REQUESTS_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('response'), 'VAR')

        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_REQUESTS_GET_TOOLTIP);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }

}

const requests_get = {
    init: function () {
        this.setColour(COMMUNICATE_HUE);
        this.appendValueInput("URL")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DISPLAY_IMAGE_LET2)
            .setCheck(String);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_CONDUCT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([["get", "get"], ["head", "head"], ["delete", "delete"]]), 'TYPE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_REQUESTS)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_REQUESTS_GET_RESULT)
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip("");
    },
}

const requests_post = {
    init: function () {
        this.setColour(COMMUNICATE_HUE);
        this.appendValueInput("URL")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DISPLAY_IMAGE_LET2)
            .setCheck(String);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_CONDUCT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([["post", "post"], ["put", "put"], ["patch", "patch"]]), 'TYPE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_REQUESTS)
        this.appendValueInput("data")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_REQUESTS + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.OLED_STRING)
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_REQUESTS_GET_RESULT)
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip("");
    },
}


const requests_attribute = {
    init: function () {
        this.appendValueInput('VAL')

        var attr = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_REQUESTS_GET_ATTR_STATUS_CODE, 'status_code'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_REQUESTS_GET_ATTR_TEXT, 'text'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_REQUESTS_GET_ATTR_COOKIES, 'cookies'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_REQUESTS_GET_ATTR_CONTENT, 'content'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_TEXT_ENCODE, 'encoding']
        ];
        this.setColour(COMMUNICATE_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(attr), 'ATTR')

        this.setInputsInline(true);
        this.setOutput(true, String);
    }
};



const requests_method = {
    init: function () {
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DISPLAY_IMAGE_LET2)
            .setCheck(String);
        var method = [
            ['post', 'post'], ['put', 'put'],
            ['delete', 'delete'], ['head', 'head'],
            ['option', 'option']
        ];
        this.setColour(COMMUNICATE_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_CONDUCT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(method), 'DIR')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_REQUESTS)


        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'forward': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_FORWARD,
                'backward': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_BACKWARD
            };
            return TOOLTIPS[mode];
        });
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/cv.js":
/*!************************************!*\
  !*** ../python_mixpy/blocks/cv.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cv_destroy_all: () => (/* binding */ cv_destroy_all),
/* harmony export */   cv_face_classifier: () => (/* binding */ cv_face_classifier),
/* harmony export */   cv_face_detect: () => (/* binding */ cv_face_detect),
/* harmony export */   cv_face_detect_all: () => (/* binding */ cv_face_detect_all),
/* harmony export */   cv_line_rect: () => (/* binding */ cv_line_rect),
/* harmony export */   cv_read_image: () => (/* binding */ cv_read_image),
/* harmony export */   cv_show_image: () => (/* binding */ cv_show_image),
/* harmony export */   cv_text: () => (/* binding */ cv_text),
/* harmony export */   cv_waitkey: () => (/* binding */ cv_waitkey),
/* harmony export */   cv_write_image: () => (/* binding */ cv_write_image)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const CV_HUE = "f0a559";

const cv_read_image = {
    init: function () {
        this.setColour(CV_HUE);
        this.appendValueInput("FILE")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_IMREAD);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true);
    }
};

const cv_show_image = {
    init: function () {
        this.setColour(CV_HUE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.OLED_BITMAP);
        this.appendValueInput('data')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AipNlp_Topic_Title);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
    }
}

const cv_write_image = {
    init: function () {
        this.setColour(CV_HUE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_IMWRITE);
        this.appendValueInput('data')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_NAME);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
    }
}

const cv_waitkey = {
    init: function () {
        this.setColour(CV_HUE);
        this.appendValueInput('data')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DELAY);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MILLIS + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_OR_PRESS)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_WAITKEY_TOOLTIP)
    }
}

const cv_destroy_all = {
    init: function () {
        this.setColour(CV_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DESTROY_ALL)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
    }
}

const cv_line_rect = {
    init: function () {
        this.setColour(CV_HUE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_IMAGE);
        var line_rect =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_RECT, 'rectangle'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_LINE, 'line']];

        this.appendValueInput('x1')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DISPLAY_DRAW)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(line_rect), 'DIR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DRAWLINE_BEGIN + '(x1')
        this.appendValueInput('y1')
            .setCheck(Number)
            .appendField(',y1');
        this.appendValueInput('x2')
            .setCheck(Number)
            .appendField(') ' + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DRAWLINE_END + '(x2');
        this.appendValueInput('y2')
            .setCheck(Number)
            .appendField(',y2');
        this.appendDummyInput()
            .appendField(') ' + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DRAWLINE_COLOR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour('#ff0000'), 'FIELDNAME');
        this.appendValueInput('thick')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DRAWLINE_THICKNESS);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DRAWLINE_RECT_TOOLTIP)
    }
}

const cv_text = {
    init: function () {
        this.setColour(CV_HUE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_IMAGE);
        var font =
            [['SIMPLEX', 'SIMPLEX'], ['PLAIN', 'PLAIN'], ['DUPLEX', 'DUPLEX'], ['COMPLEX', 'COMPLEX'], ['COMPLEX_SMALL', 'COMPLEX_SMALL'], ['TRIPLEX', 'TRIPLEX'], ['SCRIPT_SIMPLEX', 'SCRIPT_SIMPLEX'], ['SCRIPT_COMPLEX', 'SCRIPT_COMPLEX'],];
        this.appendValueInput('data')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DRAWTEXT);
        this.appendValueInput('x1')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DRAWLINE_BEGIN + '(x1')
        this.appendValueInput('y1')
            .setCheck(Number)
            .appendField(',y1');
        this.appendDummyInput()
            .appendField(') ' + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_NAME)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(font), 'font');
        this.appendValueInput('size')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_NUM);
        this.appendDummyInput()
            .appendField(') ' + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DRAWLINE_COLOR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour('#ff0000'), 'FIELDNAME');
        this.appendValueInput('thick')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DRAWLINE_THICKNESS);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_DRAWLINE_RECT_TOOLTIP)
    }
}

const cv_face_classifier = {
    init: function () {
        this.setColour(CV_HUE);
        this.appendValueInput("FILE")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_FACE_CLASSIFIER);
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true);
    }
};

const cv_face_detect = {
    init: function () {
        this.setColour(CV_HUE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_IMAGE);
        this.appendValueInput("FACE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_FACE_DETECT);
        this.appendValueInput('SCALE')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_FACE_DETECT_SCALE)
        this.appendValueInput('NEIGHBOR')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_FACE_DETECT_NEIGHBOR)
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true);
    }
};

const cv_face_detect_all = {
    init: function () {
        this.setColour(CV_HUE);
        this.appendValueInput("FILE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_IMAGE);
        this.appendValueInput("FACE")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_FACE_DETECT);
        this.appendValueInput('SCALE')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_FACE_DETECT_SCALE)
        this.appendValueInput('NEIGHBOR')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_FACE_DETECT_NEIGHBOR)
        this.appendValueInput('x1')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CV_FACE_DETECT_RANGE)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_TUPLE_MIN)
        this.appendValueInput('y1')
            .setCheck(Number)
            .appendField('×')
        this.appendValueInput('x2')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_TUPLE_MAX)
        this.appendValueInput('y2')
            .setCheck(Number)
            .appendField('×')
        this.setInputsInline(true);
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setOutput(true);
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/data.js":
/*!**************************************!*\
  !*** ../python_mixpy/blocks/data.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   array_create: () => (/* binding */ array_create),
/* harmony export */   array_toarray: () => (/* binding */ array_toarray),
/* harmony export */   dataframe_aggregate_func: () => (/* binding */ dataframe_aggregate_func),
/* harmony export */   dataframe_create: () => (/* binding */ dataframe_create),
/* harmony export */   dataframe_create_from_index: () => (/* binding */ dataframe_create_from_index),
/* harmony export */   dataframe_create_from_one_index: () => (/* binding */ dataframe_create_from_one_index),
/* harmony export */   dataframe_fillna: () => (/* binding */ dataframe_fillna),
/* harmony export */   dataframe_get: () => (/* binding */ dataframe_get),
/* harmony export */   dataframe_groupby: () => (/* binding */ dataframe_groupby),
/* harmony export */   dataframe_head_tail: () => (/* binding */ dataframe_head_tail),
/* harmony export */   dataframe_info: () => (/* binding */ dataframe_info),
/* harmony export */   dataframe_median: () => (/* binding */ dataframe_median),
/* harmony export */   dataframe_select: () => (/* binding */ dataframe_select),
/* harmony export */   dataframe_sort_values: () => (/* binding */ dataframe_sort_values),
/* harmony export */   matrix_multiplication: () => (/* binding */ matrix_multiplication),
/* harmony export */   matrix_transpose: () => (/* binding */ matrix_transpose),
/* harmony export */   numpy_argmin_template_match: () => (/* binding */ numpy_argmin_template_match),
/* harmony export */   numpy_astype: () => (/* binding */ numpy_astype),
/* harmony export */   numpy_c_: () => (/* binding */ numpy_c_),
/* harmony export */   numpy_dot: () => (/* binding */ numpy_dot),
/* harmony export */   numpy_linalg_det: () => (/* binding */ numpy_linalg_det),
/* harmony export */   numpy_linalg_inv: () => (/* binding */ numpy_linalg_inv),
/* harmony export */   numpy_max: () => (/* binding */ numpy_max),
/* harmony export */   numpy_mean: () => (/* binding */ numpy_mean),
/* harmony export */   numpy_mean_digit: () => (/* binding */ numpy_mean_digit),
/* harmony export */   numpy_min: () => (/* binding */ numpy_min),
/* harmony export */   numpy_ones: () => (/* binding */ numpy_ones),
/* harmony export */   numpy_random_random: () => (/* binding */ numpy_random_random),
/* harmony export */   numpy_reshape: () => (/* binding */ numpy_reshape),
/* harmony export */   numpy_shape: () => (/* binding */ numpy_shape),
/* harmony export */   numpy_size: () => (/* binding */ numpy_size),
/* harmony export */   numpy_square: () => (/* binding */ numpy_square),
/* harmony export */   numpy_std: () => (/* binding */ numpy_std),
/* harmony export */   numpy_sum: () => (/* binding */ numpy_sum),
/* harmony export */   numpy_trig: () => (/* binding */ numpy_trig),
/* harmony export */   pandas_drop_columns: () => (/* binding */ pandas_drop_columns),
/* harmony export */   pandas_dropna: () => (/* binding */ pandas_dropna),
/* harmony export */   pandas_readcsv: () => (/* binding */ pandas_readcsv),
/* harmony export */   pl_axes: () => (/* binding */ pl_axes),
/* harmony export */   pl_bar: () => (/* binding */ pl_bar),
/* harmony export */   pl_hist: () => (/* binding */ pl_hist),
/* harmony export */   pl_label: () => (/* binding */ pl_label),
/* harmony export */   pl_legend: () => (/* binding */ pl_legend),
/* harmony export */   pl_pie: () => (/* binding */ pl_pie),
/* harmony export */   pl_plot: () => (/* binding */ pl_plot),
/* harmony export */   pl_plot_bar: () => (/* binding */ pl_plot_bar),
/* harmony export */   pl_plot_easy: () => (/* binding */ pl_plot_easy),
/* harmony export */   pl_plot_scatter: () => (/* binding */ pl_plot_scatter),
/* harmony export */   pl_plot_xy: () => (/* binding */ pl_plot_xy),
/* harmony export */   pl_savefig: () => (/* binding */ pl_savefig),
/* harmony export */   pl_show: () => (/* binding */ pl_show),
/* harmony export */   pl_subplot: () => (/* binding */ pl_subplot),
/* harmony export */   pl_text: () => (/* binding */ pl_text),
/* harmony export */   pl_ticks: () => (/* binding */ pl_ticks),
/* harmony export */   pl_title: () => (/* binding */ pl_title),
/* harmony export */   plot_axes: () => (/* binding */ plot_axes),
/* harmony export */   plot_bar: () => (/* binding */ plot_bar),
/* harmony export */   plot_cla: () => (/* binding */ plot_cla),
/* harmony export */   plot_hist: () => (/* binding */ plot_hist),
/* harmony export */   plot_label: () => (/* binding */ plot_label),
/* harmony export */   plot_legend: () => (/* binding */ plot_legend),
/* harmony export */   plot_pie: () => (/* binding */ plot_pie),
/* harmony export */   plot_plot: () => (/* binding */ plot_plot),
/* harmony export */   plot_plot_bar: () => (/* binding */ plot_plot_bar),
/* harmony export */   plot_plot_easy: () => (/* binding */ plot_plot_easy),
/* harmony export */   plot_plot_scatter: () => (/* binding */ plot_plot_scatter),
/* harmony export */   plot_plot_xy: () => (/* binding */ plot_plot_xy),
/* harmony export */   plot_savefig: () => (/* binding */ plot_savefig),
/* harmony export */   plot_show: () => (/* binding */ plot_show),
/* harmony export */   plot_subplot: () => (/* binding */ plot_subplot),
/* harmony export */   plot_text: () => (/* binding */ plot_text),
/* harmony export */   plot_ticks: () => (/* binding */ plot_ticks),
/* harmony export */   plot_title: () => (/* binding */ plot_title),
/* harmony export */   py_sum: () => (/* binding */ py_sum),
/* harmony export */   pylab_imshow: () => (/* binding */ pylab_imshow),
/* harmony export */   series_create: () => (/* binding */ series_create),
/* harmony export */   series_create_from_index: () => (/* binding */ series_create_from_index),
/* harmony export */   series_create_from_text: () => (/* binding */ series_create_from_text),
/* harmony export */   series_get_num: () => (/* binding */ series_get_num),
/* harmony export */   series_index_value: () => (/* binding */ series_index_value)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const DATA_HUE = 170//'#5ec73d'//195;

const series_create = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput("")

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_create)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('ser1'), 'VAR')
        this.appendValueInput('SER')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_via)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_create_TOOLTIP);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const series_create_from_index = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput("")

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_create)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('ser1'), 'VAR')
        this.appendValueInput('SER')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_via)
        this.appendValueInput('INDEX')
            .setCheck([String, 'List'])
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_set_index)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_create_index_TOOLTIP);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const dataframe_create = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput("")

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_dataframe_create)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('df1'), 'VAR')
        this.appendValueInput('SER')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_via)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_dataframe_create_TOOLTIP);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const dataframe_create_from_one_index = {
    init: function () {
        this.setColour(DATA_HUE);
        var column_raw =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATAFRAME_RAW, 'index'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATAFRAME_COLUMN, 'columns']];
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_dataframe_create)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('df1'), 'VAR')
        this.appendValueInput('SER')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_via)
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(column_raw), 'COLUMN_RAW')
        this.appendValueInput('INDEX')
            .setCheck([String, 'List'])
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_set_index)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_dataframe_create_index_TOOLTIP);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const dataframe_create_from_index = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput("")

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_dataframe_create)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('df1'), 'VAR')
        this.appendValueInput('SER')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_series_via)
        this.appendValueInput('INDEX_COLUMN')
            .setCheck([String, 'List'])
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_dataframe_set_index_column)
        this.appendValueInput('INDEX_RAW')
            .setCheck([String, 'List'])
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_dataframe_set_index_raw)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        //this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_dataframe_create_index_TOOLTIP);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const series_create_from_text = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput("")

            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('ser1'), 'VAR')

            .appendField(' = [')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('1,2,3'), 'TEXT')
            .appendField(']');

        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_SERIES_CREATE_FROM_TEXT);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const series_index_value = {
    /**
     * Block for list length.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DATA_HUE);
        var index_value =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SERIES_INDEX, 'index'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_VALUE, 'value']];
        this.appendValueInput('SERIES')
            .setCheck('Series')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SERIES_INDEX_VALUE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(index_value), 'INDEX_VALUE')

        this.setOutput(true, 'List');
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('INDEX_VALUE');
            var TOOLTIPS = {
                'index': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SERIES_INDEX_TOOLTIP,
                'value': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_VALUE_TOOLTIP
            };
            return TOOLTIPS[mode];
        });
    }
};

const series_get_num = {
    init: function () {
        this.setColour(DATA_HUE);
        //this.setOutput(true, Number);
        this.setOutput(true);
        this.appendValueInput('SER')
            .setCheck('Series')
        this.appendValueInput('AT')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_LISTS_GET_INDEX1);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_LISTS_GET_INDEX2);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_GET_INDEX_TOOLTIP);
    }
};

const pl_plot_easy = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('SER')
            .setCheck('Series')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_SOCKET_MAKE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const pl_plot = {
    init: function () {
        this.setColour(DATA_HUE);
        var line_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_SOLID, '-'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_DOTTED, '--'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_CHAIN, '-.'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_POINT_DOTTED, ':'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_INOUT_PULL_NONE, ""]];
        var color_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_BLUE, 'b'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_GREEN, 'g'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_RED, 'r'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_CYAN, 'c'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_MAGENTA, 'm'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_YELLOW, 'y'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_BLACK, 'k'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_WHITE, 'w']
        ];
        var dot_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CIRCULAR, '.'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PIXEL, ','], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_LARGE_DOT, 'o'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_DOWN, 'v'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_UP, '^'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_LEFT, '<'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_RIGHT, '>'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_UP, '1'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_DOWN, '2'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_LEFT, '3'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_RIGHT, '4'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_SQUARE, 's'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PENTAGON, 'p'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_STAR, '*'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_VERTICAL, 'h'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_HORIZONTAL, 'H'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PLUS, '+'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CROSS, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND, 'D'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND_SMALL, 'd'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_VERTICAL, '|'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HORIZONTAL, '_']
        ];

        this.appendValueInput('SER')
            .setCheck('Series')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_SOCKET_MAKE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(dot_type), 'DOT')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(line_type), 'LINE')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_COLOUR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(color_type), 'COLOR')
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const pl_show = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_SHOW);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const pl_axes = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_AXES);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const pl_legend = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_LEGEND);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const pl_title = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_TITLE);
        this.appendValueInput('TITLE')
            .setCheck(String);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const pl_label = {
    init: function () {
        this.setColour(DATA_HUE);
        var xylabel =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYLAB_LABEL_X, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYLAB_LABEL_Y, 'y']];
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_SET_LABEL)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(xylabel), 'DIR');
        this.appendValueInput('LABEL')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_LABEL)
            .setCheck(String);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        // var thisBlock = this;
        // this.setTooltip(function() {
        //   var mode = thisBlock.getFieldValue('DIR');
        //   var TOOLTIPS = {
        //     'x': Blockly.Msg.MIXLY_TOOLTIP_TURTEL_FORWARD,
        //     'y': Blockly.Msg.MIXLY_TOOLTIP_TURTEL_BACKWARD
        //   };
        //   return TOOLTIPS[mode];
        // });
    }
};

const array_create = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('FROM')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SPLITBYDOU)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_DATA_ARRAY_CREATE_FROM);
        this.appendValueInput('TO')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_DATA_ARRAY_CREATE_TO);
        this.appendValueInput('STEP')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_STEP);
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_RANGE_TOOLTIP);
    }
};

const pl_plot_bar = {
    init: function () {
        this.setColour(DATA_HUE);
        var plot_bar =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_BAR_PLOT, 'plot'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_BAR_BAR, 'bar']];
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DISPLAY_DRAW)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(plot_bar), 'DIR');
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_X);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_Y);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'plot': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_XY_TOOLTIP,
                'bar': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_BAR_EASY_TOOLTIP
            };
            return TOOLTIPS[mode];
        });
    }
};

const pl_plot_scatter = {
    init: function () {
        this.setColour(DATA_HUE);
        var color_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_BLUE, 'b'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_GREEN, 'g'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_RED, 'r'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_CYAN, 'c'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_MAGENTA, 'm'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_YELLOW, 'y'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_BLACK, 'k'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_WHITE, 'w']
        ];
        var dot_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CIRCULAR, '.'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PIXEL, ','], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_LARGE_DOT, 'o'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_DOWN, 'v'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_UP, '^'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_LEFT, '<'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_RIGHT, '>'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_UP, '1'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_DOWN, '2'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_LEFT, '3'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_RIGHT, '4'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_SQUARE, 's'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PENTAGON, 'p'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_STAR, '*'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_VERTICAL, 'h'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_HORIZONTAL, 'H'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PLUS, '+'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CROSS, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND, 'D'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND_SMALL, 'd'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_VERTICAL, '|'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HORIZONTAL, '_']
        ];
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_SCATTER)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_X);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_Y);
        this.appendValueInput('S')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_NUMBER);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(dot_type), 'DOT');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_COLOUR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(color_type), 'COLOR');
        this.appendValueInput('TAG')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip("");
    }
};

const pl_plot_xy = {
    init: function () {
        this.setColour(DATA_HUE);
        var line_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_SOLID, '-'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_DOTTED, '--'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_CHAIN, '-.'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_POINT_DOTTED, ':'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_INOUT_PULL_NONE, ""]
        ];
        var color_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_BLUE, 'b'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_GREEN, 'g'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_RED, 'r'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_CYAN, 'c'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_MAGENTA, 'm'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_YELLOW, 'y'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_BLACK, 'k'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_WHITE, 'w']
        ];
        var dot_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CIRCULAR, '.'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PIXEL, ','], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_LARGE_DOT, 'o'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_DOWN, 'v'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_UP, '^'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_LEFT, '<'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_RIGHT, '>'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_UP, '1'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_DOWN, '2'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_LEFT, '3'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_RIGHT, '4'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_SQUARE, 's'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PENTAGON, 'p'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_STAR, '*'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_VERTICAL, 'h'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_HORIZONTAL, 'H'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PLUS, '+'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CROSS, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND, 'D'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND_SMALL, 'd'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_VERTICAL, '|'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HORIZONTAL, '_']
        ];
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_XY)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_X);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_Y);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(dot_type), 'DOT')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(line_type), 'LINE')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_COLOUR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(color_type), 'COLOR')
        this.appendValueInput('TAG')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_XY_TOOLTIP);
    }
};

const pl_bar = {
    init: function () {
        this.setColour(DATA_HUE);
        var align =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_ALIGN_CENTER, 'center'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.AILGN_EDGE, 'edge']];
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_BAR)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_X);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_Y);
        this.appendValueInput('WIDTH')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_WIDTH);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_BAR_ALIGN)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(align), 'ALIGN')
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_COLOUR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour('#0000ff'), 'COLOR');
        this.appendValueInput('TAG')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_XY_TOOLTIP);
    }
};

const pl_pie = {
    init: function () {
        this.setColour(DATA_HUE);
        var shadow =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_PIE_SHADOW_N, 'False'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_PIE_SHADOW_Y, 'True']];
        var autopct =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_PIE_SHADOW_N, 'None'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_AUTOPCT_Z, '%.0f%%'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_AUTOPCT_O, '%.1f%%'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_AUTOPCT_T, '%.2f%%']];
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_BLEND_RATIO);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG);
        this.appendValueInput('EXPLODE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_EXPLODE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_AUTOPCT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(autopct), 'autopct')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_SHADOW)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(shadow), 'SHADOW')
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_XY_TOOLTIP);
    }
};

const pl_hist = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_HIST)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SD_DATA);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_MONITOR_SCROLL_INTERVAL);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const pl_ticks = {
    init: function () {
        this.setColour(DATA_HUE);
        var xylabel =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYLAB_LABEL_X, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYLAB_LABEL_Y, 'y']];
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SETTING)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(xylabel), 'DIR');
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_I2C_VALUE)
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TOOLTIP);
    }
};

const numpy_trig = {
    /**
     * Block for trigonometry operators.
     * @this Blockly.Block
     */
    init: function () {
        var OPERATORS = [
            ['sin', 'sin'],
            ['cos', 'cos'],
            ['tan', 'tan'],
            ['arcsin', 'arcsin'],
            ['arccos', 'arccos'],
            ['arctan', 'arctan'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_TO_ROUND, 'round'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_TO_CEIL, 'ceil'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_TO_FLOOR, 'floor']
        ];
        this.setColour(DATA_HUE);
        this.setOutput(true);
        this.setInputsInline(true);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_NUMPY_TRIG)
        this.appendValueInput('NUM')
            .setCheck(Number)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(OPERATORS), 'OP');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_NUMPY_TRIG_TOOLTIP);
    }
};

const pl_subplot = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('VET')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_SUBPLOT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_SUBPLOT_VERTICLE);
        this.appendValueInput('HOR')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_SUBPLOT_HORIZEN);
        this.appendValueInput('NUM')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_SUBPLOT_NUM);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_RANGE_TOOLTIP);
    }
};

const pandas_readcsv = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput("FILENAME")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_PANDAS_READ_CSV);
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PANDAS_READCSV_HEADER_Y, '0'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PANDAS_READCSV_HEADER_N, 'None']]), 'MODE');
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PANDAS_READCSV_TITLE);
        this.setOutput(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PANDAS_READCSV_TOOLTIP);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const dataframe_get = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('DICT')
            .setCheck('Dict')
        this.appendValueInput('KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_DATAFRAME_GET)
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_DATAFRAME_GET_INDEX)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATAFRAME_COLUMN, 'column'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATAFRAME_RAW, 'raw']]), 'MODE')
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_DATAFRAME_GET_TOOLTIP);
    }
};

const pl_savefig = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput("FILE")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_SAVEFIG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setOutput(false);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_SAVEFIG_TOOLTIP);
    }
};

const pl_text = {
    init: function () {
        this.setColour(DATA_HUE);
        var halign =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TRIM_LEFT, 'right'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_CENTER, 'center'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TRIM_RIGHT, 'left']];
        var valign =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_TOP, 'bottom'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_CENTER, 'center'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_BOTTOM, 'top']];
        this.appendValueInput('VET')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SETTING)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_X);
        this.appendValueInput('HOR')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_Y);
        this.appendValueInput('NUM')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_TAG);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_HOR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(halign), 'HALIGN');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_VER)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(valign), 'VALIGN');
        this.appendValueInput('FONTNUM')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_NUM);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_TOOLTIP);
    }
};

const array_toarray = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOARRAY);
        this.setOutput(true, 'List');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TOOLTIP_TOARRAY);
    }
};

const plot_plot_easy = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('SER')
            .setCheck('Series')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_SOCKET_MAKE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const plot_plot = {
    init: function () {
        this.setColour(DATA_HUE);
        var line_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_SOLID, '-'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_DOTTED, '--'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_CHAIN, '-.'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_POINT_DOTTED, ':'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_INOUT_PULL_NONE, ""]];
        var color_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_BLUE, 'b'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_GREEN, 'g'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_RED, 'r'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_CYAN, 'c'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_MAGENTA, 'm'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_YELLOW, 'y'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_BLACK, 'k'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_WHITE, 'w']
        ];
        var dot_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CIRCULAR, '.'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PIXEL, ','], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_LARGE_DOT, 'o'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_DOWN, 'v'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_UP, '^'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_LEFT, '<'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_RIGHT, '>'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_UP, '1'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_DOWN, '2'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_LEFT, '3'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_RIGHT, '4'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_SQUARE, 's'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PENTAGON, 'p'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_STAR, '*'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_VERTICAL, 'h'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_HORIZONTAL, 'H'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PLUS, '+'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CROSS, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND, 'D'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND_SMALL, 'd'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_VERTICAL, '|'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HORIZONTAL, '_']
        ];

        this.appendValueInput('SER')
            .setCheck('Series')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_SOCKET_MAKE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(dot_type), 'DOT')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(line_type), 'LINE')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_COLOUR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(color_type), 'COLOR')
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const plot_show = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_SHOW);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const plot_axes = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_AXES);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const plot_legend = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_LEGEND);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const plot_title = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_TITLE);
        this.appendValueInput('TITLE')
            .setCheck(String);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const plot_label = {
    init: function () {
        this.setColour(DATA_HUE);
        var xylabel =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYLAB_LABEL_X, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYLAB_LABEL_Y, 'y']];
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_SET_LABEL)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(xylabel), 'DIR');
        this.appendValueInput('LABEL')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_LABEL)
            .setCheck(String);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        // var thisBlock = this;
        // this.setTooltip(function() {
        //   var mode = thisBlock.getFieldValue('DIR');
        //   var TOOLTIPS = {
        //     'x': Blockly.Msg.MIXLY_TOOLTIP_TURTEL_FORWARD,
        //     'y': Blockly.Msg.MIXLY_TOOLTIP_TURTEL_BACKWARD
        //   };
        //   return TOOLTIPS[mode];
        // });
    }
};

const plot_plot_bar = {
    init: function () {
        this.setColour(DATA_HUE);
        var plot_bar =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_BAR_PLOT, 'plot'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_BAR_BAR, 'bar']];
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DISPLAY_DRAW)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(plot_bar), 'DIR');
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_X);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_Y);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'plot': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_XY_TOOLTIP,
                'bar': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_BAR_EASY_TOOLTIP
            };
            return TOOLTIPS[mode];
        });
    }
};

const plot_plot_scatter = {
    init: function () {
        this.setColour(DATA_HUE);
        var color_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_BLUE, 'b'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_GREEN, 'g'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_RED, 'r'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_CYAN, 'c'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_MAGENTA, 'm'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_YELLOW, 'y'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_BLACK, 'k'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_WHITE, 'w']
        ];
        var dot_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CIRCULAR, '.'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PIXEL, ','], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_LARGE_DOT, 'o'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_DOWN, 'v'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_UP, '^'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_LEFT, '<'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_RIGHT, '>'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_UP, '1'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_DOWN, '2'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_LEFT, '3'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_RIGHT, '4'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_SQUARE, 's'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PENTAGON, 'p'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_STAR, '*'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_VERTICAL, 'h'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_HORIZONTAL, 'H'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PLUS, '+'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CROSS, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND, 'D'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND_SMALL, 'd'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_VERTICAL, '|'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HORIZONTAL, '_']
        ];
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_SCATTER)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_X);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_Y);
        this.appendValueInput('S')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_NUMBER);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(dot_type), 'DOT');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_COLOUR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(color_type), 'COLOR');
        this.appendValueInput('TAG')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip("");
    }
};

const plot_plot_xy = {
    init: function () {
        this.setColour(DATA_HUE);
        var line_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_SOLID, '-'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_DOTTED, '--'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_CHAIN, '-.'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE_POINT_DOTTED, ':'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_INOUT_PULL_NONE, ""]
        ];
        var color_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_BLUE, 'b'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_GREEN, 'g'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_RGB_RED, 'r'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_CYAN, 'c'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_MAGENTA, 'm'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_YELLOW, 'y'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_BLACK, 'k'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_WHITE, 'w']
        ];
        var dot_type = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CIRCULAR, '.'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PIXEL, ','], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_LARGE_DOT, 'o'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_DOWN, 'v'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_UP, '^'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_LEFT, '<'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIANGLE_RIGHT, '>'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_UP, '1'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_DOWN, '2'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_LEFT, '3'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_TRIMARKER_RIGHT, '4'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_SQUARE, 's'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PENTAGON, 'p'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_STAR, '*'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_VERTICAL, 'h'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HEXAGON_HORIZONTAL, 'H'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_PLUS, '+'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_CROSS, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND, 'D'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_DIAMOND_SMALL, 'd'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_VERTICAL, '|'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT_HORIZONTAL, '_']
        ];
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_XY)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_X);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_Y);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_DOT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(dot_type), 'DOT')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_PYLAB_PLOT_LINE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(line_type), 'LINE')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_COLOUR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(color_type), 'COLOR')
        this.appendValueInput('TAG')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_XY_TOOLTIP);
    }
};

const plot_bar = {
    init: function () {
        this.setColour(DATA_HUE);
        var align =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_ALIGN_CENTER, 'center'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.AILGN_EDGE, 'edge']];
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_BAR)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_X);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_Y);
        this.appendValueInput('WIDTH')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_WIDTH);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_BAR_ALIGN)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(align), 'ALIGN')
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_COLOUR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour('#0000ff'), 'COLOR');
        this.appendValueInput('TAG')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_XY_TOOLTIP);
    }
};

const plot_pie = {
    init: function () {
        this.setColour(DATA_HUE);
        var shadow =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_PIE_SHADOW_N, 'False'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_PIE_SHADOW_Y, 'True']];
        var autopct =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_PIE_SHADOW_N, 'None'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_AUTOPCT_Z, '%.0f%%'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_AUTOPCT_O, '%.1f%%'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_AUTOPCT_T, '%.2f%%']];
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.COLOUR_BLEND_RATIO);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG);
        this.appendValueInput('EXPLODE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_EXPLODE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_AUTOPCT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(autopct), 'autopct')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PIE_SHADOW)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(shadow), 'SHADOW')
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_PLOT_XY_TOOLTIP);
    }
};

const plot_hist = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_HIST)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SD_DATA);
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_MONITOR_SCROLL_INTERVAL);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const plot_ticks = {
    init: function () {
        this.setColour(DATA_HUE);
        var xylabel =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYLAB_LABEL_X, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYLAB_LABEL_Y, 'y']];
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SETTING)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(xylabel), 'DIR');
        this.appendValueInput('A')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_I2C_VALUE)
        this.appendValueInput('B')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TOOLTIP);
    }
};

const plot_subplot = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('VET')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_SUBPLOT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_SUBPLOT_VERTICLE);
        this.appendValueInput('HOR')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_SUBPLOT_HORIZEN);
        this.appendValueInput('NUM')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_SUBPLOT_NUM);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_RANGE_TOOLTIP);
    }
};

const plot_savefig = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_SAVEFIG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setOutput(false);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_SAVEFIG_TOOLTIP);
    }
};

const plot_text = {
    init: function () {
        this.setColour(DATA_HUE);
        var halign =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TRIM_LEFT, 'right'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_CENTER, 'center'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_TRIM_RIGHT, 'left']];
        var valign =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_TOP, 'bottom'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_CENTER, 'center'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_BOTTOM, 'top']];
        this.appendValueInput('VET')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SETTING)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_X);
        this.appendValueInput('HOR')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_Y);
        this.appendValueInput('NUM')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_TAG);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_HOR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(halign), 'HALIGN');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_VER)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(valign), 'VALIGN');
        this.appendValueInput('FONTNUM')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_NUM);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_TEXT_TOOLTIP);
    }
};

const numpy_shape = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('获取维度');
        this.setOutput(true);
        this.setTooltip('Returns the shape of the array.');
    }
};

const numpy_reshape = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('变形');
        this.appendValueInput('DIMENSIONS')
            .appendField('后维度为');
        this.setOutput(true);
        this.setTooltip('Reshapes the array to the specified dimensions.');
    }
};

const numpy_astype = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('把');
        this.appendDummyInput()
            .appendField('转换为')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['uint8', 'numpy.uint8'],
                ['int32', 'numpy.int32'],
                ['float32', 'numpy.float32'],
                ['float64', 'numpy.float64']
                // 可以根据需要添加更多的类型
            ]), 'TYPE');
        this.setOutput(true);
        this.setTooltip('Converts array to specified type.');
    }
};

const pylab_imshow = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('展示图像');
        this.appendDummyInput()
            .appendField('颜色')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['gray', 'gray'],
                ['viridis', 'viridis'],
                ['plasma', 'plasma'],
                ['inferno', 'inferno'],
                ['magma', 'magma'],
                ['cividis', 'cividis'],
                ['hot', 'hot'],
                ['cool', 'cool'],
                ['spring', 'spring'],
                ['summer', 'summer'],
                ['autumn', 'autumn'],
                ['winter', 'winter'],
                ['jet', 'jet']
                // 可以根据需要添加更多的类型
            ]), 'COLORMAP');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip('Displays an image with the specified colormap.');
    }
};

const numpy_mean_digit = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('X')
            .appendField('从数据集');
        this.appendValueInput('Y')
            .appendField('获取平均图像，标签');
        this.appendValueInput('DIGIT')
            .appendField('为');
        this.setOutput(true);
        this.setTooltip('Computes the mean of X where y equals the specified digit.');
    }
};

const numpy_argmin_template_match = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('IMAGE')
            .appendField('获取模板匹配结果，图片：');
        this.appendValueInput('TEMPLATES')
            .appendField('模板：');
        this.setOutput(true);
        this.setTooltip('Finds the index of the template that minimizes the sum of absolute differences with the image.');
    }
};

const numpy_mean = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('获取平均值');
        this.appendDummyInput()
            .appendField('沿着axis')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['None', 'NONE'],
                ['0', '0'],
                ['1', '1']
            ]), 'AXIS');
        this.setOutput(true);
        this.setTooltip('Computes the mean of the array along the specified axis.');
    }
};

const numpy_std = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('获取标准差');
        this.appendDummyInput()
            .appendField('沿着axis')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['None', 'NONE'],
                ['0', '0'],
                ['1', '1']
            ]), 'AXIS');
        this.setOutput(true);
        this.setTooltip('Computes the standard deviation of the array along the specified axis.');
    }
};

const pandas_dropna = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('DF')
            .appendField('丢弃缺省值');
        this.setOutput(true);
        this.setTooltip('Drops rows with NaN values from the dataframe.');
    }
};

const pandas_drop_columns = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('DATAFRAME')
            .appendField('从数据集');
        this.appendValueInput('COLUMNS')
            .appendField('中删除列');
        this.appendDummyInput()
            .appendField('沿着axis')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['行', '0'],
                ['列', '1']
            ]), 'AXIS');
        this.setOutput(true);
        this.setTooltip('Drops columns from dataframe.');
    }
};

const numpy_ones = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('NUM')
            .appendField('生成单位行向量');
        this.setOutput(true);
        this.setTooltip('Creates an array of ones with the specified length.');
    }
};

const numpy_c_ = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY1')
            .appendField('列拼接：数组1');
        this.appendValueInput('ARRAY2')
            .appendField('数组2');
        this.setOutput(true);
        this.setTooltip('Concatenates two arrays along the second axis using numpy.c_.');
    }
};

const numpy_linalg_det = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('获取行列式');
        this.setOutput(true);
        this.setTooltip('Computes the determinant of an array using numpy.linalg.det.');
    }
};

const matrix_transpose = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('MATRIX')
            .appendField('获取转置');
        this.setOutput(true);
        this.setTooltip('Computes the transpose of the given matrix.');
    }
};

const matrix_multiplication = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('MATRIX1');
        this.appendValueInput('MATRIX2')
            .appendField('@');
        this.setOutput(true);
        this.setTooltip('Multiplies two matrices.');
    }
};

const numpy_linalg_inv = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('获取逆矩阵');
        this.setOutput(true);
        this.setTooltip('Computes the inverse of the given matrix using numpy.linalg.inv.');
    }
};

const dataframe_median = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('DATAFRAME')
            .appendField('获取中位数');
        this.setOutput(true);
        this.setTooltip('Computes the median of the given dataframe.');
    }
};

const dataframe_fillna = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('DATAFRAME')
            .appendField('填充缺失值');
        this.appendValueInput('VALUE')
            .appendField('填充值');
        this.appendDummyInput()
            .appendField('是否修改原数据')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['True', 'True'],
                ['False', 'False']
            ]), 'INPLACE');
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip('Fills NaN values in the dataframe with the specified value.');
    }
};

const dataframe_info = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('DATAFRAME')
            .appendField('获取DataFrame信息');
        this.setOutput(true);
        this.setTooltip('Displays information about the DataFrame.');
    }
};

const numpy_min = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('获取最小值');
        this.appendDummyInput()
            .appendField('沿着axis')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['None', 'None'],
                ['行', '0'],
                ['列', '1']
            ]), 'AXIS');
        this.setOutput(true);
        this.setTooltip('Returns the minimum value along the specified axis.');
    }
};

const numpy_max = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('获取最大值');
        this.appendDummyInput()
            .appendField('沿着axis')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['None', 'None'],
                ['行', '0'],
                ['列', '1']
            ]), 'AXIS');
        this.setOutput(true);
        this.setTooltip('Returns the maximum value along the specified axis.');
    }
};

const numpy_size = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('获取数组大小');
        this.setOutput(true);
        this.setTooltip('Returns the size of the array.');
    }
};

const numpy_dot = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY1')
            .appendField('点乘数组1');
        this.appendValueInput('ARRAY2')
            .appendField('点乘数组2');
        this.setOutput(true);
        this.setTooltip('Returns the dot product of two arrays.');
    }
};

const numpy_square = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('获取平方数组');
        this.setOutput(true);
        this.setTooltip('Returns the element-wise square of the array.');
    }
};

const numpy_sum = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('获取数组元素和');
        this.setOutput(true);
        this.setTooltip('Returns the sum of the array.');
    }
};

const numpy_random_random = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('SIZE')
            .appendField('生成随机数组');
        this.setOutput(true);
        this.setTooltip('Returns a random array of the specified size.');
    }
};

const py_sum = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('ARRAY')
            .appendField('Python求和');
        this.setOutput(true);
        this.setTooltip('Returns the sum of the iterable.');
    }
};

const dataframe_sort_values = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('DICT')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .setCheck('Dict');
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('值排序');
        this.appendValueInput('KEY')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('标签');
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('排序方式')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['升序', 'True'],
                ['降序', 'False']
            ]), 'AS_CENDING');
        this.setOutput(true);
        this.setInputsInline(true);
        this.setTooltip('');
    }
}

const dataframe_head_tail = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('DICT')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .setCheck('Dict');
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('获取')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['前几行', 'head'],
                ['最后几行', 'tail']
            ]), 'TYPE');
        this.appendValueInput('LINES')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('行数');
        this.setOutput(true);
        this.setInputsInline(true);
        this.setTooltip('');
    }
}

const dataframe_select = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('DICT')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .setCheck('Dict');
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('筛选数据');
        this.appendValueInput('KEY')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('满足条件');
        this.setOutput(true);
        this.setInputsInline(true);
        this.setTooltip('');
    }
}

const dataframe_groupby = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendValueInput('DICT')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .setCheck('Dict');
        this.appendValueInput('KEY')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('通过标签');
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('分组');
        this.setOutput(true);
        this.setInputsInline(true);
        this.setTooltip('');
    }
}

const dataframe_aggregate_func = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                ['求最小值', 'min'],
                ['求最大值', 'max'],
                ['求和', 'sum'],
                ['求平均值', 'mean'],
                ['求中位数', 'median'],
                ['求标准差', 'std']
            ]), 'TYPE');
        this.appendValueInput('DICT')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .setCheck('Dict');
        this.setOutput(true);
        this.setInputsInline(true);
        this.setTooltip('');
    }
}

const plot_cla = {
    init: function () {
        this.setColour(DATA_HUE);
        this.appendDummyInput()
            .appendField('清除已有图像');
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/datastructure.js":
/*!***********************************************!*\
  !*** ../python_mixpy/blocks/datastructure.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ds_add_node_by_attr: () => (/* binding */ ds_add_node_by_attr),
/* harmony export */   ds_add_node_by_name: () => (/* binding */ ds_add_node_by_name),
/* harmony export */   ds_create_linkedlist: () => (/* binding */ ds_create_linkedlist),
/* harmony export */   ds_create_linkedlist_container: () => (/* binding */ ds_create_linkedlist_container),
/* harmony export */   ds_create_linkedlist_item: () => (/* binding */ ds_create_linkedlist_item),
/* harmony export */   ds_create_node: () => (/* binding */ ds_create_node),
/* harmony export */   ds_del_node_by_attr: () => (/* binding */ ds_del_node_by_attr),
/* harmony export */   ds_del_node_by_name: () => (/* binding */ ds_del_node_by_name),
/* harmony export */   ds_get_node_attr: () => (/* binding */ ds_get_node_attr),
/* harmony export */   ds_reverse_linkedlist: () => (/* binding */ ds_reverse_linkedlist),
/* harmony export */   ds_set_node_attr: () => (/* binding */ ds_set_node_attr)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const DS_HUE = 80;

const ds_create_linkedlist = {

    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */

    init: function () {
        this.setColour(DS_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldLabel(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_LINKEDLIST_NEW))
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldLabel(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_LINKEDLIST_HEAD))
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('head'), 'VAR')
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldLabel(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_LINKEDLIST_TYPE))
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('tag'), 'TYPE')
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_LINKEDLIST_ATTRIBUTE);
        this.itemCount_ = 1;
        this.updateShape_();
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['ds_create_linkedlist_item'], this));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_LINKEDLIST_TOOLTIP);
    },

    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */

    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },

    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */

    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },

    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */

    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('ds_create_linkedlist_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('ds_create_linkedlist_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },

    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */

    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');

        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }

        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },

    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */

    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },

    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */

    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        }

        var keyNames = [];
        for (var i = 0; this.getInput('ADD' + i); i++) {
            //this.getInput('VALUE' + i).removeField("KEY"+i);
            keyNames.push(this.getFieldValue("KEY" + i))
            this.removeInput('ADD' + i);
        }
        // Rebuild block.
        //if (this.itemCount_ == 0) {
        //  this.getField('TIP').setText(Blockly.Msg.DICTS_CREATE_EMPTY_TITLE);
        // } else {
        //  this.getField('TIP').setText(Blockly.Msg.DS_CREATE_LINKEDLIST_NEW);
        for (var i = 0; i < this.itemCount_; i++) {
            this.appendValueInput('ADD' + i)
                .setCheck(null)
                .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
                .appendField(
                    new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(keyNames.length > i
                        ? keyNames[i]
                        : 'name'),
                    'KEY' + i)
                .appendField("=")

        }
    }, getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};



const ds_create_linkedlist_container = {

    /**
     * Mutator block for list container.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_LINKEDLIST_CONTAINER_TITLE);
        this.appendStatementInput('STACK');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_LINKEDLIST_CONTAINER_TOOLTIP);
        this.contextMenu = false;
    }
};

const ds_create_linkedlist_item = {
    /**
     * Mutator bolck for adding items.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(DS_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_LINKEDLIST_ITEM_TITLE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_LINKEDLIST_ITEM_TOOLTIP);
        this.contextMenu = false;
    }
};


const ds_create_node = {
    init: function () {
        this.setColour(DS_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_NODE_USE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('tag'), 'TYPE')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_NODE_NEW)
        this.appendValueInput('NODE')
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_NODE_TOOLTIP);
    }
}

const ds_get_node_attr = {
    init: function () {
        this.setColour(DS_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_GET_NODE_ATTR_NODE)
        this.appendValueInput('NODE')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('name'), 'TYPE')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_ADD_VALUE)
        this.setOutput(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_GET_NODE_ATTR_TOOLTIP);
    }
}

const ds_set_node_attr = {
    init: function () {
        this.setColour(DS_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_SET_NODE_ATTR_NODE)
        this.appendValueInput('NODE')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AIP_ATTR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('name'), 'TYPE')
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_SET_NODE_ATTR_SET)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_SET_NODE_ATTR_TOOLTIP);
    }
}

const ds_add_node_by_name = {
    init: function () {
        this.setColour(DS_HUE);
        this.appendValueInput('NODE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_HEAD_NODE)
        var pos =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_BEFORE, 'before'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_AFTER, 'after']];
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_LINKEDLIST)
        this.appendValueInput('NODE2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_SET_NODE_ATTR_NODE)
        this.appendValueInput('NODE3')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(pos), 'DIR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_TOOLTIP);
    }
}

const ds_add_node_by_attr = {
    init: function () {
        this.setColour(DS_HUE);
        this.appendValueInput('NODE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_HEAD_NODE)
        var pos =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_BEFORE, 'before'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_AFTER, 'after']];
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_LINKEDLIST)
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_CREATE_LINKEDLIST_ITEM_TITLE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('name'), 'TYPE')
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AS)
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_ATTR)
        this.appendValueInput('NODE3')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(pos), 'DIR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_TOOLTIP);
    }
}

const ds_del_node_by_name = {
    init: function () {
        this.setColour(DS_HUE);
        this.appendValueInput('NODE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_HEAD_NODE)

        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_LINKEDLIST)
        this.appendValueInput('NODE2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_DEL_NODE_NAME)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_DEL_NODE_TOOLTIP);
    }
}

const ds_del_node_by_attr = {
    init: function () {
        this.setColour(DS_HUE);
        this.appendValueInput('NODE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_HEAD_NODE)

        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_LINKEDLIST)
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_DEL_NODE_ATTR)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('name'), 'TYPE')
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_AS)
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_ATTR)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_DEL_NODE_TOOLTIP);
    }
}

const ds_reverse_linkedlist = {
    init: function () {
        this.setColour(DS_HUE);
        this.appendValueInput('NODE')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_ADD_NODE_HEAD_NODE)

        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_REVERSE_LINKEDLIST)
        this.appendValueInput('NODE2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_REVERSE_LINKEDLIST_NEW_HEAD)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DS_DEL_NODE_TOOLTIP);
    }
}

/***/ }),

/***/ "../python_mixpy/blocks/factory.js":
/*!*****************************************!*\
  !*** ../python_mixpy/blocks/factory.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   factory_block: () => (/* binding */ factory_block),
/* harmony export */   factory_block_return: () => (/* binding */ factory_block_return),
/* harmony export */   factory_block_return_with_textarea: () => (/* binding */ factory_block_return_with_textarea),
/* harmony export */   factory_block_with_textarea: () => (/* binding */ factory_block_with_textarea),
/* harmony export */   factory_callMethod_noreturn: () => (/* binding */ factory_callMethod_noreturn),
/* harmony export */   factory_callMethod_return: () => (/* binding */ factory_callMethod_return),
/* harmony export */   factory_create_with_container: () => (/* binding */ factory_create_with_container),
/* harmony export */   factory_create_with_item: () => (/* binding */ factory_create_with_item),
/* harmony export */   factory_declare: () => (/* binding */ factory_declare),
/* harmony export */   factory_from_import: () => (/* binding */ factory_from_import),
/* harmony export */   factory_function_noreturn: () => (/* binding */ factory_function_noreturn),
/* harmony export */   factory_function_return: () => (/* binding */ factory_function_return),
/* harmony export */   factory_import: () => (/* binding */ factory_import)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const FACTORY_HUE = "#777777"; //65;

const factory_from_import = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField("from ")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('ESP32'), 'path')
            .appendField(" import ")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('*'), 'module');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const factory_import = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField("import ")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('module'), 'module');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const factory_function_noreturn = {
    init: function () {
        //console.log('init');
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('my_function'), 'NAME');
        this.itemCount_ = 1;
        this.arguments_ = ['x'];//add
        this.updateShape_();
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['factory_create_with_item'], this));
    },
    mutationToDom: function () {
        //console.log('mutationToDom');
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        //add
        for (var i = 0; i < this.arguments_.length; i++) {
            var parameter = document.createElement('arg');
            parameter.setAttribute('name', this.arguments_[i]);
            container.appendChild(parameter);
        }
        return container;
    },
    domToMutation: function (xmlElement) {
        //console.log('domToMutation');
        this.arguments_ = [];//add
        //add
        for (var i = 0; xmlElement.childNodes[i]; i++) {
            let childNode = xmlElement.childNodes[i];
            if (childNode.nodeName.toLowerCase() == 'arg') {
                this.arguments_.push(childNode.getAttribute('name'));
            }
        }
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    decompose: function (workspace) {
        //console.log('decompose');
        var containerBlock =
            workspace.newBlock('factory_create_with_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('factory_create_with_item');
            itemBlock.initSvg();
            itemBlock.setFieldValue(this.arguments_[i], 'NAME');//add
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    compose: function (containerBlock) {
        //console.log('compose');
        this.arguments_ = [];//add
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            this.arguments_.push(itemBlock.getFieldValue('NAME'));//add
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i)
                    .connection.connect(connections[i]);
            }
        }
    },
    saveConnections: function (containerBlock) {
        //console.log('saveConnections');
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    updateShape_: function () {
        //console.log('updateShape_');
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ADD' + i)) {
                this.removeInput('ADD' + i);
                i++;
            }
        }
        // Rebuild block.
        for (var i = 0; i < this.itemCount_; i++) {
            this.appendValueInput('ADD' + i)
                .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
                .appendField(this.arguments_[i]);
        }
    }
};

const factory_create_with_container = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PARAMS);
        this.appendStatementInput('STACK');
        this.contextMenu = false;
    }
};

const factory_create_with_item = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_WITH_ITEM_TITLE + ':')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('x'), 'NAME');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.contextMenu = false;
    }
};

const factory_function_return = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('my_function'), 'NAME');
        this.itemCount_ = 1;
        this.arguments_ = ['x'];//add
        this.updateShape_();
        this.setOutput(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['factory_create_with_item'], this));
    },
    mutationToDom: factory_function_noreturn.mutationToDom,
    domToMutation: factory_function_noreturn.domToMutation,
    decompose: factory_function_noreturn.decompose,
    compose: factory_function_noreturn.compose,
    saveConnections: factory_function_noreturn.saveConnections,
    updateShape_: factory_function_noreturn.updateShape_
};

const factory_declare = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('test'), 'NAME')
            .appendField("=")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('Test'), 'TYPE')
            .appendField("()");
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
}


const factory_callMethod_noreturn = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('test'), 'NAME')
            .appendField('.')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('callMethod'), 'METHOD');
        this.itemCount_ = 1;
        this.arguments_ = ['x'];//add
        this.updateShape_();
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['factory_create_with_item'], this));
    },
    mutationToDom: factory_function_noreturn.mutationToDom,
    domToMutation: factory_function_noreturn.domToMutation,
    decompose: factory_function_noreturn.decompose,
    compose: factory_function_noreturn.compose,
    saveConnections: factory_function_noreturn.saveConnections,
    updateShape_: factory_function_noreturn.updateShape_
};

const factory_callMethod_return = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('test'), 'NAME')
            .appendField('.')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('callMethod'), 'METHOD');
        this.itemCount_ = 1;
        this.arguments_ = ['x'];//add
        this.updateShape_();
        this.setOutput(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['factory_create_with_item'], this));
    },
    mutationToDom: factory_function_noreturn.mutationToDom,
    domToMutation: factory_function_noreturn.domToMutation,
    decompose: factory_function_noreturn.decompose,
    compose: factory_function_noreturn.compose,
    saveConnections: factory_function_noreturn.saveConnections,
    updateShape_: factory_function_noreturn.updateShape_
};

const factory_block = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('display.scroll("Hello World!")'), 'VALUE');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const factory_block_return = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('test'), 'VALUE');
        this.setOutput(true);
    }
};

const factory_block_with_textarea = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldMultilineInput('display.scroll("Hello World!")\ndisplay.scroll("Hello Mixly!")'), 'VALUE');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const factory_block_return_with_textarea = {
    init: function () {
        this.setColour(FACTORY_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldMultilineInput('Hello\nMixly'), 'VALUE');
        this.setOutput(true);
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/hardware.js":
/*!******************************************!*\
  !*** ../python_mixpy/blocks/hardware.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hardware_arduino_analog_read: () => (/* binding */ hardware_arduino_analog_read),
/* harmony export */   hardware_arduino_analog_write: () => (/* binding */ hardware_arduino_analog_write),
/* harmony export */   hardware_arduino_digital_read: () => (/* binding */ hardware_arduino_digital_read),
/* harmony export */   hardware_arduino_digital_write: () => (/* binding */ hardware_arduino_digital_write),
/* harmony export */   hardware_arduino_start: () => (/* binding */ hardware_arduino_start),
/* harmony export */   inout_highlow: () => (/* binding */ inout_highlow)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const HARDWARE_HUE = 40;

const hardware_arduino_start = {
    init: function () {
        this.setColour(HARDWARE_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_HARDWARE)
        this.appendValueInput('SUB')
            .setCheck("var");
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_HARDWARE_START)
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
    }
};

const inout_highlow = {
    init: function () {
        this.setColour(HARDWARE_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_HIGH, "HIGH"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LOW, "LOW"]]), 'BOOL')
        this.setOutput(true, Boolean);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_INOUT_HIGHLOW);
    }
};

const hardware_arduino_digital_write = {
    init: function () {
        this.setColour(HARDWARE_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_HARDWARE)
            .setCheck("var");
        this.appendValueInput("PIN", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Digital_PINMODEOUT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PIN)
            .setCheck(Number);
        this.appendValueInput("STAT")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_STAT)
            .setCheck([Number, Boolean]);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_INOUT_DIGITAL_WRITE_TOOLTIP);
    }
};

const hardware_arduino_digital_read = {
    init: function () {
        this.setColour(HARDWARE_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_HARDWARE)
            .setCheck("var");
        this.appendValueInput("PIN", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Digital_PINMODEIN)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PIN)
            .setCheck(Number);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_MACHINE_VALUE)
        this.setInputsInline(true);
        this.setOutput(true, [Boolean, Number]);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_INOUT_DIGITAL_READ);
    }
};

const hardware_arduino_analog_write = {
    init: function () {
        this.setColour(HARDWARE_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_HARDWARE)
            .setCheck("var");
        this.appendValueInput("PIN", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Analog_PINMODEOUT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PIN)
            .setCheck(Number);
        this.appendValueInput("NUM", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_VALUE2)
            .setCheck(Number);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_INOUT_ANALOG_WRITE);
    }
};

const hardware_arduino_analog_read = {
    init: function () {
        this.setColour(HARDWARE_HUE);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_HARDWARE)
            .setCheck("var");
        this.appendValueInput("PIN", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Analog_PINMODEIN)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PIN)
            .setCheck(Number);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_MACHINE_VALUE)
        this.setInputsInline(true);
        this.setOutput(true, [Boolean, Number]);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_INOUT_ANALOG_READ);
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/inout.js":
/*!***************************************!*\
  !*** ../python_mixpy/blocks/inout.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inout_input: () => (/* binding */ inout_input),
/* harmony export */   inout_print: () => (/* binding */ inout_print),
/* harmony export */   inout_print_container: () => (/* binding */ inout_print_container),
/* harmony export */   inout_print_end: () => (/* binding */ inout_print_end),
/* harmony export */   inout_print_inline: () => (/* binding */ inout_print_inline),
/* harmony export */   inout_print_item: () => (/* binding */ inout_print_item),
/* harmony export */   inout_print_many: () => (/* binding */ inout_print_many),
/* harmony export */   inout_type_input: () => (/* binding */ inout_type_input),
/* harmony export */   pyinout_type_input: () => (/* binding */ pyinout_type_input)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const inout_input = {
    init: function () {
        this.setColour(20);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_inout_raw_input)
            .setCheck(String);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.INOUT_input_TOOLTIP);
    }
};

const inout_print = {
    init: function () {
        this.setColour(20);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SERIAL_PRINTLN);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.BLOCKPY_PRINT_TOOLTIP);
    }
};

const inout_print_inline = {
    init: function () {
        this.setColour(20);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SERIAL_PRINT);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEXT_PRINT_TOOLTIP);
    }
};

const inout_print_end = {
    init: function () {
        this.setColour(20);
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SERIAL_PRINT);
        this.appendValueInput("END")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ENDSWITH);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_INOUT_PRINT_END_TOOLTIP);
    }
};

const inout_type_input = {
    init: function () {

        var input_type =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_STRING, 'str'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_INT, 'int']
                , [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_FLOAT, 'float']];
        this.setColour(20);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(input_type), 'DIR')
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_MUTATORCONTAINER_TITLE)
            .setCheck(String);

        this.setInputsInline(true);
        this.setOutput(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'str': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_STR_INPUT_TOOLTIP,
                'int': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_INT_INPUT_TOOLTIP,
                'float': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_FLOAT_INPUT_TOOLTIP
            };
            return TOOLTIPS[mode];
        });
    }
};

const pyinout_type_input = {
    init: function () {

        var input_type =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_STRING, 'str'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_INT, 'int']
                , [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LANG_MATH_FLOAT, 'float']];
        this.setColour(20);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(input_type), 'DIR')
        this.appendValueInput("VAR")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PROCEDURES_MUTATORCONTAINER_TITLE)
            .setCheck(String);

        this.setInputsInline(true);
        this.setOutput(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'str': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_STR_INPUT_TOOLTIP,
                'int': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_INT_INPUT_TOOLTIP,
                'float': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_FLOAT_INPUT_TOOLTIP
            };
            return TOOLTIPS[mode];
        });
    }
};

const inout_print_many = {

    init: function () {
        this.setColour(20);

        this.itemCount_ = 2;
        this.updateShape_();
        this.setPreviousStatement(false);
        this.setNextStatement(false);
        this.setInputsInline(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.icons.MutatorIcon(['inout_print_item'], this));
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_PRINT_MANY_TOOLTIP);
    },

    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },

    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },

    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('inout_print_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('inout_print_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },

    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i)
                    .connection.connect(connections[i]);
            }
        }
    },

    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },

    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        } else {
            var i = 0;
            while (this.getInput('ADD' + i)) {
                this.removeInput('ADD' + i);
                i++;
            }
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            this.appendDummyInput('EMPTY')
                .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_PRINT_EMPTY);
        } else {
            for (var i = 0; i < this.itemCount_; i++) {
                var input = this.appendValueInput('ADD' + i);
                if (i == 0) {
                    input.appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SERIAL_PRINTLN);
                }
            }
        }
    }
};
const inout_print_container = {
    init: function () {
        this.setColour(20);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SERIAL_PRINTLN);
        this.appendStatementInput('STACK');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_PRINT_MANY_CONTAINER_TOOLTIP);
        this.contextMenu = false;
    }
};

const inout_print_item = {
    init: function () {
        this.setColour(20);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LISTS_CREATE_WITH_ITEM_TITLE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_INOUT_PRINT_MANY_ITEM_TOOLTIP);
        this.contextMenu = false;
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/iot.js":
/*!*************************************!*\
  !*** ../python_mixpy/blocks/iot.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IOT_EMQX_INIT_AND_CONNECT_BY_MIXLY_CODE: () => (/* binding */ IOT_EMQX_INIT_AND_CONNECT_BY_MIXLY_CODE),
/* harmony export */   IOT_EMQX_INIT_AND_CONNECT_BY_SHARE_CODE: () => (/* binding */ IOT_EMQX_INIT_AND_CONNECT_BY_SHARE_CODE),
/* harmony export */   IOT_EMQX_PING: () => (/* binding */ IOT_EMQX_PING),
/* harmony export */   IOT_FORMATTING: () => (/* binding */ IOT_FORMATTING),
/* harmony export */   IOT_FORMAT_STRING: () => (/* binding */ IOT_FORMAT_STRING),
/* harmony export */   IOT_MIXIO_NTP: () => (/* binding */ IOT_MIXIO_NTP),
/* harmony export */   IOT_MIXIO_PUBLISH: () => (/* binding */ IOT_MIXIO_PUBLISH),
/* harmony export */   IOT_MIXIO_SUBSCRIBE: () => (/* binding */ IOT_MIXIO_SUBSCRIBE),
/* harmony export */   IOT_MIXIO_UNSUBSCRIBE: () => (/* binding */ IOT_MIXIO_UNSUBSCRIBE),
/* harmony export */   iot_checkonenet: () => (/* binding */ iot_checkonenet),
/* harmony export */   iot_client_onboard: () => (/* binding */ iot_client_onboard),
/* harmony export */   iot_create_with_item: () => (/* binding */ iot_create_with_item),
/* harmony export */   iot_http_client: () => (/* binding */ iot_http_client),
/* harmony export */   iot_http_data: () => (/* binding */ iot_http_data),
/* harmony export */   iot_mixio_check: () => (/* binding */ iot_mixio_check),
/* harmony export */   iot_mixio_connect: () => (/* binding */ iot_mixio_connect),
/* harmony export */   iot_mixio_connect_only: () => (/* binding */ iot_mixio_connect_only),
/* harmony export */   iot_mixio_disconnect: () => (/* binding */ iot_mixio_disconnect),
/* harmony export */   iot_mixio_format_msg: () => (/* binding */ iot_mixio_format_msg),
/* harmony export */   iot_mixio_format_topic: () => (/* binding */ iot_mixio_format_topic),
/* harmony export */   iot_mixly_key: () => (/* binding */ iot_mixly_key),
/* harmony export */   iot_mixly_key_py: () => (/* binding */ iot_mixly_key_py),
/* harmony export */   iot_mqtt_client: () => (/* binding */ iot_mqtt_client),
/* harmony export */   iot_mqtt_data: () => (/* binding */ iot_mqtt_data),
/* harmony export */   iot_onenet_check: () => (/* binding */ iot_onenet_check),
/* harmony export */   iot_onenet_connect: () => (/* binding */ iot_onenet_connect),
/* harmony export */   iot_onenet_disconnect: () => (/* binding */ iot_onenet_disconnect),
/* harmony export */   iot_onenet_publish: () => (/* binding */ iot_onenet_publish),
/* harmony export */   iot_onenet_publish_dict: () => (/* binding */ iot_onenet_publish_dict),
/* harmony export */   iot_onenetconnect: () => (/* binding */ iot_onenetconnect),
/* harmony export */   iot_onenetdisconnect: () => (/* binding */ iot_onenetdisconnect),
/* harmony export */   iot_publish: () => (/* binding */ iot_publish),
/* harmony export */   iot_publish_container: () => (/* binding */ iot_publish_container),
/* harmony export */   iot_publish_item: () => (/* binding */ iot_publish_item)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mixly */ "mixly");
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mixly__WEBPACK_IMPORTED_MODULE_1__);



const IOT_HUE = '#526FC3';
//'#2FAD7A';

const iot_onenet_connect = {
    init: function () {
        this.setColour("#78AAE0");
        this.appendValueInput('VAR')
            .setCheck("var")
            .appendField("OneNET" + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TUPLE_JOIN);
        this.appendValueInput('CLIENT')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_ONENET_CLIENT);
        this.appendValueInput('SERVER')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_ONENET_SERVER);
        this.appendValueInput('USERNAME')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_ONENET_USERNAME);
        this.appendValueInput('PASSWORD')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_ONENET_PASSWORD);
        this.appendValueInput('TOPIC')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_ONENET_TOPIC);
        this.appendValueInput('SUB')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_ONENET_SUB);
        //this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_ONENET_CONNECT_TOOLTIP);
    }
};

const iot_onenet_disconnect = {
    init: function () {
        this.setColour("#78AAE0");
        this.appendValueInput('VAR')
            .setCheck("var")
            .appendField("OneNET")
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_DISCONNECT_ONENET);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_ONENET_DISCONNECT_TOOLTIP);
    }
};

const iot_onenet_check = {
    init: function () {
        this.setColour("#78AAE0");
        this.appendValueInput('VAR')
            .setCheck("var")
            .appendField("OneNET")
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_CHECK_ONENET);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_ONENET_CHECK_TOOLTIP);
    }
};

const iot_onenet_publish_dict = {
    init: function () {
        this.setColour("#78AAE0");
        this.appendValueInput('VAR')
            .setCheck("var")
            .appendField("OneNET")
        this.appendValueInput('DICT')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_PUBLISH_ONENET);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_ONENET_PRINT_DATA)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldCheckbox('TRUE'), 'is_print');
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_ONENET_PUBLISH_DICT_TOOLTIP);
    }
};

const iot_onenet_publish = {
    /**
     * Block for creating a list with any number of elements of any type.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour("#78AAE0");
        this.appendValueInput('VAR')
            .setCheck("var")
            .appendField("OneNET")
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldLabel(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_PUBLISH_ONENET), 'TIP')
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
        this.itemCount_ = 2;
        this.updateShape_();
        this.setInputsInline(false);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setMutator(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.Mutator(['iot_publish_item']));
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_ONENET_PUBLISH_TOOLTIP);
    },
    /**
     * Create XML to represent list inputs.
     * @return {Element} XML storage element.
     * @this Blockly.Block
     */
    mutationToDom: function () {
        var container = document.createElement('mutation');
        container.setAttribute('items', this.itemCount_);
        return container;
    },
    /**
     * Parse XML to restore the list inputs.
     * @param {!Element} xmlElement XML storage element.
     * @this Blockly.Block
     */
    domToMutation: function (xmlElement) {
        this.itemCount_ = parseInt(xmlElement.getAttribute('items'), 10);
        this.updateShape_();
    },
    /**
     * Populate the mutator's dialog with this block's components.
     * @param {!Blockly.Workspace} workspace Mutator's workspace.
     * @return {!Blockly.Block} Root block in mutator.
     * @this Blockly.Block
     */
    decompose: function (workspace) {
        var containerBlock =
            workspace.newBlock('iot_publish_container');
        containerBlock.initSvg();
        var connection = containerBlock.getInput('STACK').connection;
        for (var i = 0; i < this.itemCount_; i++) {
            var itemBlock = workspace.newBlock('iot_create_with_item');
            itemBlock.initSvg();
            connection.connect(itemBlock.previousConnection);
            connection = itemBlock.nextConnection;
        }
        return containerBlock;
    },
    /**
     * Reconfigure this block based on the mutator dialog's components.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    compose: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        // Count number of inputs.
        var connections = [];
        var i = 0;
        while (itemBlock) {
            connections[i] = itemBlock.valueConnection_;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
            i++;
        }
        this.itemCount_ = i;
        this.updateShape_();
        // Reconnect any child blocks.
        for (var i = 0; i < this.itemCount_; i++) {
            if (connections[i]) {
                this.getInput('ADD' + i).connection.connect(connections[i]);
            }
        }
    },
    /**
     * Store pointers to any connected child blocks.
     * @param {!Blockly.Block} containerBlock Root block in mutator.
     * @this Blockly.Block
     */
    saveConnections: function (containerBlock) {
        var itemBlock = containerBlock.getInputTargetBlock('STACK');
        var i = 0;
        while (itemBlock) {
            var input = this.getInput('ADD' + i);
            itemBlock.valueConnection_ = input && input.connection.targetConnection;
            i++;
            itemBlock = itemBlock.nextConnection &&
                itemBlock.nextConnection.targetBlock();
        }
    },
    /**
     * Modify this block to have the correct number of inputs.
     * @private
     * @this Blockly.Block
     */
    updateShape_: function () {
        // Delete everything.
        if (this.getInput('EMPTY')) {
            this.removeInput('EMPTY');
        }
        var keyNames = [];
        for (var i = 0; this.getInput('ADD' + i); i++) {
            //this.getInput('VALUE' + i).removeField("KEY"+i);
            keyNames.push(this.getFieldValue("KEY" + i))
            this.removeInput('ADD' + i);
        }
        // Rebuild block.
        if (this.itemCount_ == 0) {
            //this.getField('TIP')
            //.setText(Blockly.Msg.MIXLY_ESP32_PUBLISH_ONENET_EMPTY);
            this.setFieldValue(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_PUBLISH_ONENET_EMPTY, 'TIP');
        } else {
            //this.getField('TIP')
            //.setText(Blockly.Msg.MIXLY_ESP32_PUBLISH_ONENET);
            this.setFieldValue(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_PUBLISH_ONENET, 'TIP');
            for (var i = 0; i < this.itemCount_; i++) {
                this.appendValueInput('ADD' + i)
                    .setCheck(null)
                    .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
                    .appendField(
                        new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(
                            keyNames.length > i
                                ? keyNames[i]
                                : '"key' + (i + 1) + '"'),
                        'KEY' + i)
                    .appendField(":")
            }
        }
    }, getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const iot_publish_container = {
    /**
     * Mutator block for list container.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_TYPE_DICT);
        this.appendStatementInput('STACK');
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_CONTAINER_TOOLTIP);
        this.contextMenu = false;
    }
};


const iot_publish_item = {
    /**
     * Mutator bolck for adding items.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_ITEM_TITLE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_ITEM_TOOLTIP);
        this.contextMenu = false;
    }
};

const iot_create_with_item = {
    /**
     * Mutator bolck for adding items.
     * @this Blockly.Block
     */
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_ITEM_TITLE);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_CREATE_WITH_ITEM_TOOLTIP);
        this.contextMenu = false;
    }
};


const iot_mixio_connect = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CREATE_MQTT_CLIENT_AND_CONNECT);
        this.appendValueInput('SERVER')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_SERVER)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
        this.appendValueInput('USERNAME')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_WIFI_USERNAME)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
        this.appendValueInput('PASSWORD')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_IOT_PASSWORD)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
        this.appendValueInput('PROJECT')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_PROJECT)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const IOT_MIXIO_PUBLISH = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField("MixIO")
        this.appendValueInput('TOPIC')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_PUBLISH_NEW)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_PUBLISH_TOPIC);
        this.appendValueInput('MSG')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.HTML_BODY);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_EMQX_PUBLISH_TOOLTIP);
    }
};

const IOT_MIXIO_SUBSCRIBE = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField("MixIO")
        this.appendValueInput('TOPIC')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_SUBSCRIBE + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_MSG)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_PUBLISH_TOPIC);
        this.appendValueInput('METHOD')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_SET_METHOD);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_EMQX_SUBSCRIBE_TOOLTIP);
    }
};

const IOT_MIXIO_UNSUBSCRIBE = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField("MixIO")
        this.appendValueInput('TOPIC')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MSG.stop + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_SUBSCRIBE)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_PUBLISH_TOPIC);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_EMQX_SUBSCRIBE_TOOLTIP);
    }
};

const iot_mixio_disconnect = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField("MixIO")
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_DISCONNECT_ONENET);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        // this.setTooltip(Blockly.Msg.MIXLY_ESP32_IOT_ONENET_DISCONNECT_TOOLTIP);
    }
};

const iot_mixio_connect_only = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField("MixIO")
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_CONNECT);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        // this.setTooltip(Blockly.Msg.MIXLY_ESP32_IOT_ONENET_DISCONNECT_TOOLTIP);
    }
};

const iot_mixio_check = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField("MixIO")
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_CHECK_ONENET);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        // this.setTooltip(Blockly.Msg.MIXLY_ESP32_IOT_ONENET_CHECK_TOOLTIP);
    }
};

const iot_mixio_format_topic = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_FORMAT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.MQTT_Topic);
        this.setInputsInline(true);
        this.setOutput(true);
    }
};

const iot_mixio_format_msg = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_FORMAT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_PUBLISH_MSG);
        this.setInputsInline(true);
        this.setOutput(true);
    }
};

const IOT_FORMATTING = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_MAP_FORMATING);
        this.setOutput(true);
        // this.setTooltip();
    }
};

const IOT_FORMAT_STRING = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROPYTHON_FORMAT + '(Json)');
        this.setOutput(true);
        // this.setTooltip();
    }
};

const IOT_EMQX_PING = {
    init: function () {
        this.setColour(IOT_HUE);
        // this.appendValueInput('VAR')
        //     .setCheck("var")
        this.appendDummyInput()
            .appendField("MixIO")
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_PING);
        this.setInputsInline(true);
        this.setOutput(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_ESP32_IOT_EMQX_PING_TOOLTIP);
    }
};

const IOT_MIXIO_NTP = {
    init: function () {
        this.setColour(IOT_HUE);
        // this.appendValueInput('VAR')
        //     .setCheck("var")
        this.appendDummyInput()
            .appendField("MixIO")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET_NTP)
        this.appendValueInput('addr')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.blynk_SERVER_ADD);
        this.setInputsInline(true);
        this.setOutput(true);
    }
};

const IOT_EMQX_INIT_AND_CONNECT_BY_SHARE_CODE = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CREATE_MQTT_CLIENT_AND_CONNECT);
        this.appendValueInput('SERVER')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_SERVER)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_FOR_INPUT_WITH + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXIO_SHARE_KEY)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};


const IOT_EMQX_INIT_AND_CONNECT_BY_MIXLY_CODE = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CREATE_MQTT_CLIENT_AND_CONNECT);
        this.appendValueInput('SERVER')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_EMQX_SERVER)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.appendValueInput('KEY')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CONTROLS_FOR_INPUT_WITH + "Mixly Key")
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};


const iot_mixly_key_py = {
    init: function () {
        this.VISITOR_ID = mixly__WEBPACK_IMPORTED_MODULE_1__.Config.BOARD.visitorId.str32.substring(0, 8).toUpperCase();
        this.setColour(IOT_HUE);
        this.appendDummyInput("")
            .appendField(this.newQuote_(true))
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(this.visitorId), 'VISITOR_ID')
            .appendField(this.newQuote_(false));
        this.setOutput(true, null);
    },
    onchange: function () {
        const nowVisitorId = this.getFieldValue('VISITOR_ID');
        if (this.VISITOR_ID !== nowVisitorId)
            this.setFieldValue(this.VISITOR_ID, 'VISITOR_ID');
    },
    newQuote_: function (open) {
        if (open == this.RTL) {
            var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAqUlEQVQI1z3KvUpCcRiA8ef9E4JNHhI0aFEacm1o0BsI0Slx8wa8gLauoDnoBhq7DcfWhggONDmJJgqCPA7neJ7p934EOOKOnM8Q7PDElo/4x4lFb2DmuUjcUzS3URnGib9qaPNbuXvBO3sGPHJDRG6fGVdMSeWDP2q99FQdFrz26Gu5Tq7dFMzUvbXy8KXeAj57cOklgA+u1B5AoslLtGIHQMaCVnwDnADZIFIrXsoXrgAAAABJRU5ErkJggg==';
        } else {
            var file = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAn0lEQVQI1z3OMa5BURSF4f/cQhAKjUQhuQmFNwGJEUi0RKN5rU7FHKhpjEH3TEMtkdBSCY1EIv8r7nFX9e29V7EBAOvu7RPjwmWGH/VuF8CyN9/OAdvqIXYLvtRaNjx9mMTDyo+NjAN1HNcl9ZQ5oQMM3dgDUqDo1l8DzvwmtZN7mnD+PkmLa+4mhrxVA9fRowBWmVBhFy5gYEjKMfz9AylsaRRgGzvZAAAAAElFTkSuQmCC';
        }
        return new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldImage(file, 12, 12, '"');
    }
};

const iot_mixly_key = {
    init: function () {
        this.VISITOR_ID = mixly__WEBPACK_IMPORTED_MODULE_1__.Config.BOARD.visitorId.str32.substring(0, 8).toUpperCase();
        this.setColour(IOT_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput(this.visitorId), 'VISITOR_ID');
        this.setOutput(true, null);
    },
    onchange: function () {
        const nowVisitorId = this.getFieldValue('VISITOR_ID');
        if (this.VISITOR_ID !== nowVisitorId)
            this.setFieldValue(this.VISITOR_ID, 'VISITOR_ID');
    }
};

const iot_client_onboard = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField('MixIO')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MSG.catEthernet_clinet);
        this.setOutput(true);
        this.setInputsInline(true);
    }
};

const iot_http_client = {
    init: function () {
        this.setColour(IOT_HUE);
        // this.appendValueInput('VAR')
        //     .setCheck("var")
        this.appendDummyInput()
            .appendField("HTTP" + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
        this.appendValueInput('addr')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DISPLAY_IMAGE_LET2);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_REQUESTS_GET)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET_CURRENT_TIME)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_OPEN_DEBUG)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_MOVE_TRUE, "True"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_MOVE_FALSE, "False"]
            ]), "key");
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const iot_http_data = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField("HTTP" + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_REQUESTS_LEN, "client_len"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_REQUESTS_GET_LEN, "server_len"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_REQUESTS_MESSAGE, "text"]
            ]), "key");
        this.setOutput(true);
        this.setInputsInline(true);

    }
};

const iot_mqtt_client = {
    init: function () {
        this.setColour(IOT_HUE);
        // this.appendValueInput('VAR')
        //     .setCheck("var")
        this.appendDummyInput()
            .appendField("MQTT" + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
        this.appendValueInput('addr')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_CONNECTTO);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_INIT_SUBSCRIBE)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.MQTT_Topic)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET_CURRENT_TIME, ""],
            ]), "key")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_OPEN_DEBUG)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_MOVE_TRUE, "True"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_MOVE_FALSE, "False"]
            ]), "key2");
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const iot_mqtt_data = {
    init: function () {
        this.setColour(IOT_HUE);
        this.appendDummyInput()
            .appendField("MQTT" + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_Client)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_REQUESTS_LEN, "client_len"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_REQUESTS_GET_LEN, "server_len"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_REQUESTS_MESSAGE, "time_msg()"]
            ]), "key");
        this.setOutput(true);
        this.setInputsInline(true);

    }
};

// export const iot_wificonnect = iot_wifi_connect;
const iot_onenetconnect = iot_onenet_connect;
const iot_onenetdisconnect = iot_onenet_disconnect;
const iot_checkonenet = iot_onenet_check;
const iot_publish = iot_onenet_publish;



/***/ }),

/***/ "../python_mixpy/blocks/pins.js":
/*!**************************************!*\
  !*** ../python_mixpy/blocks/pins.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pins_analog_read: () => (/* binding */ pins_analog_read),
/* harmony export */   pins_analog_write: () => (/* binding */ pins_analog_write),
/* harmony export */   pins_digital_read: () => (/* binding */ pins_digital_read),
/* harmony export */   pins_digital_write: () => (/* binding */ pins_digital_write)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mixly */ "mixly");
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mixly__WEBPACK_IMPORTED_MODULE_1__);



const PINS_HUE = 230;

const pins_digital_write = {
    init: function () {
        this.setColour(PINS_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(mixly__WEBPACK_IMPORTED_MODULE_1__.Profile.default.digital_write), 'PIN');
        this.setOutput(true);
    }
};

const pins_digital_read = {
    init: function () {
        this.setColour(PINS_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(mixly__WEBPACK_IMPORTED_MODULE_1__.Profile.default.digital_read), 'PIN');
        this.setOutput(true);
    }
};

const pins_analog_write = {
    init: function () {
        this.setColour(PINS_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(mixly__WEBPACK_IMPORTED_MODULE_1__.Profile.default.analog_write), 'PIN');
        this.setOutput(true);
    }
};

const pins_analog_read = {
    init: function () {
        this.setColour(PINS_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(mixly__WEBPACK_IMPORTED_MODULE_1__.Profile.default.analog_read), 'PIN');
        this.setOutput(true);
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/serial.js":
/*!****************************************!*\
  !*** ../python_mixpy/blocks/serial.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   serial_close: () => (/* binding */ serial_close),
/* harmony export */   serial_open: () => (/* binding */ serial_open),
/* harmony export */   serial_read_b: () => (/* binding */ serial_read_b),
/* harmony export */   serial_write: () => (/* binding */ serial_write)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const SERIAL_HUE = 40;

const serial_open = {
    init: function () {
        var bps = [
            ["115200", '115200'], ["256000", '256000'], ["128000", '128000'], ["57600", '57600'], ["56000", '56000'],
            ["43000", '43000'], ["38400", '38400'], ["28800", '28800'], ["19200", '19200'], ["9600", '9600'],
            ["4800", '4800'], ["2400", '2400'], ["1200", '1200'], ["600", '600'], ["300", '300'], ["110", '110']
        ];
        this.setColour(SERIAL_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldLabel(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_SERIAL_OPEN))
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('ser'), 'SER')
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SERIAL_BEGIN)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(bps), 'BPS')
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_SERIAL_OPEN_TIMEOUT);
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_SERIAL_OPEN_TOOLTIP);
    }
};

const serial_write = {
    init: function () {
        this.setColour(SERIAL_HUE);
        this.appendValueInput('SER')
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_SERIAL_WRITE);
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_SERIAL_WRITE_TOOLTIP);
    }
};

const serial_read_b = {
    init: function () {
        this.setColour(SERIAL_HUE);
        this.appendValueInput('SER')
        this.appendValueInput('VAR')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_SERIAL_READ);
        this.setInputsInline(true);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_SERIAL_READ_TOOLTIP);
    }
};

const serial_close = {
    init: function () {
        this.setColour(SERIAL_HUE);
        this.appendValueInput('SER')
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_SERIAL_CLOSE);
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXPY_SERIAL_CLOSE_TOOLTIP);
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/sklearn.js":
/*!*****************************************!*\
  !*** ../python_mixpy/blocks/sklearn.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sklearn_DecisionTreeClassifier_Regressor: () => (/* binding */ sklearn_DecisionTreeClassifier_Regressor),
/* harmony export */   sklearn_GaussianNB: () => (/* binding */ sklearn_GaussianNB),
/* harmony export */   sklearn_KMeans: () => (/* binding */ sklearn_KMeans),
/* harmony export */   sklearn_KNeighborsClassifier_Regressor: () => (/* binding */ sklearn_KNeighborsClassifier_Regressor),
/* harmony export */   sklearn_LinearRegression: () => (/* binding */ sklearn_LinearRegression),
/* harmony export */   sklearn_RandomForestClassifier_Regressor: () => (/* binding */ sklearn_RandomForestClassifier_Regressor),
/* harmony export */   sklearn_Ridge: () => (/* binding */ sklearn_Ridge),
/* harmony export */   sklearn_cluster_centers_labels_inertia: () => (/* binding */ sklearn_cluster_centers_labels_inertia),
/* harmony export */   sklearn_coef_intercept: () => (/* binding */ sklearn_coef_intercept),
/* harmony export */   sklearn_data_target: () => (/* binding */ sklearn_data_target),
/* harmony export */   sklearn_fit: () => (/* binding */ sklearn_fit),
/* harmony export */   sklearn_fit_no_target: () => (/* binding */ sklearn_fit_no_target),
/* harmony export */   sklearn_load: () => (/* binding */ sklearn_load),
/* harmony export */   sklearn_make_blobs: () => (/* binding */ sklearn_make_blobs),
/* harmony export */   sklearn_make_classification: () => (/* binding */ sklearn_make_classification),
/* harmony export */   sklearn_make_regression: () => (/* binding */ sklearn_make_regression),
/* harmony export */   sklearn_predict: () => (/* binding */ sklearn_predict),
/* harmony export */   sklearn_save_load_model: () => (/* binding */ sklearn_save_load_model),
/* harmony export */   sklearn_score: () => (/* binding */ sklearn_score),
/* harmony export */   sklearn_score_no_target: () => (/* binding */ sklearn_score_no_target),
/* harmony export */   sklearn_train_test_split: () => (/* binding */ sklearn_train_test_split),
/* harmony export */   sklearn_train_test_split_no_target: () => (/* binding */ sklearn_train_test_split_no_target)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const SKLEARN_HUE = 80;

const sklearn_make_classification = {
    init: function () {
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_CLASSIFICATION_GENERATION);
        this.appendValueInput("n_samples")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_SAMPLES);
        this.appendValueInput("n_features")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_FEATURES);
        this.appendValueInput("n_informative")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_EFFECTIVE_FEATURES);
        this.appendValueInput("n_redundant")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_REDUNDANT_FEATURES);
        this.appendValueInput("n_repeated")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_REPEATED_FEATURES);
        this.appendValueInput("n_classes")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_CLASSES);
        this.appendValueInput("n_clusters_per_class")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_CLUSTERS_PER_CLASSES);
        this.appendValueInput("random_state")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.RANDOM_SEED);
        this.setInputsInline(false);
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 生成回归样本
const sklearn_make_regression = {
    init: function () {
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_REGRESSION_GENERATION);
        this.appendValueInput("n_samples")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_SAMPLES);
        this.appendValueInput("n_features")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_FEATURES);
        this.appendValueInput("n_informative")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_EFFECTIVE_FEATURES);
        this.appendValueInput("n_targets")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_LABELS);
        this.appendValueInput("bias")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DEVIATION);
        this.appendValueInput("noise")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NOISE);
        this.appendValueInput("random_state")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.RANDOM_SEED);
        this.setInputsInline(false);
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 生成聚类样本
const sklearn_make_blobs = {
    init: function () {
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_CLUSTERING_GENERATION);
        this.appendValueInput("n_samples")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_SAMPLES);
        this.appendValueInput("n_features")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_FEATURES);
        this.appendValueInput("centers")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_CLUSTERS);
        this.appendValueInput("cluster_std")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.STANDARD_DEVIATION_OF_CLUSTER);
        this.appendValueInput("center_box")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CLUSTER_BOUNDING_BOX);
        this.appendValueInput("shuffle")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SHUFFLE_SAMPLES);
        this.appendValueInput("random_state")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.RANDOM_SEED);
        this.setInputsInline(false);
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 加载数据集
const sklearn_load = {
    init: function () {
        var data = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_LOAD_IRIS, "load_iris"],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_LOAD_BOSTON, "load_boston"],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_LOAD_DIABETES, "load_diabetes"],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_LOAD_BREAST_CANCER, "load_breast_cancer"],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_LOAD_LINNERUD, "load_linnerud"],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_LOAD_DIGITS, "load_digits"]
        ];
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LOAD)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(data), "type")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput("iris"), "name");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    },
    getVars: function () {
        return [this.getFieldValue('name')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('name'))) {
            this.setTitleValue(newName, 'name');
        }
    }
};

//sklearn 获取特征值/标签值/标签/特征
const sklearn_data_target = {
    init: function () {
        this.appendValueInput("name")
            .setCheck(null)
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATA_SET);
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.EIGENVALUES, "data"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LABEL_VALUE, "target"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.FEATURE, "feature_names"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PYLAB_TICKS_TAG, "target_names"]]), "type");
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 数据集分割
const sklearn_train_test_split = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATA_SEGMENTATION);
        this.appendValueInput("train_data")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.EIGENVALUES);
        this.appendValueInput("train_target")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LABEL_VALUE);
        this.appendValueInput("test_size")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEST_SET_PROPORTION);
        this.appendValueInput("rondom_state")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.RANDOM_SEED);
        this.setInputsInline(false);
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 数据集分割-无标签值
const sklearn_train_test_split_no_target = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DATA_SEGMENTATION);
        this.appendValueInput("train_data")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.EIGENVALUES);
        this.appendValueInput("test_size")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TEST_SET_PROPORTION);
        this.appendValueInput("rondom_state")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.RANDOM_SEED);
        this.setInputsInline(false);
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 初始化线性回归
const sklearn_LinearRegression = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_LINEARREGRESSION_INIT);
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("fit_intercept")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_CALCULATE_MODEL_INTERRUPT);
        this.appendValueInput("normalize")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_REGRESSION_NORMIALIZATION);
        this.appendValueInput("n_jobs")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_THREADS);
        this.setInputsInline(false);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 初始化岭回归
const sklearn_Ridge = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_RIDGE_INIT);
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("alpha")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_REGULA_INTENSITY);
        this.appendValueInput("fit_intercept")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_CALCULATE_MODEL_INTERRUPT);
        this.appendValueInput("normalize")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_REGRESSION_NORMIALIZATION);
        this.appendValueInput("max_iter")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_MAX_ITER);
        this.appendValueInput("random_state")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.RANDOM_SEED);
        this.setInputsInline(false);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 初始化决策树 分类/回归算法
const sklearn_DecisionTreeClassifier_Regressor = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_DECISIONTREE_INIT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_CLASSIFICATION_ALGORITHM, "DecisionTreeClassifier"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_REGRESSION_ALGORITHM, "DecisionTreeRegressor"]]), "type");
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("max_depth")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_MAXIMUM_TREE_DEPTH);
        this.appendValueInput("random_state")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.RANDOM_SEED);
        this.setInputsInline(false);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 初始化随机森林 分类/回归算法
const sklearn_RandomForestClassifier_Regressor = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_RANDOMFOREST_INIT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_CLASSIFICATION_ALGORITHM, "RandomForestClassifier"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_REGRESSION_ALGORITHM, "RandomForestRegressor"]]), "type");
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("n_estimators")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_TREES);
        this.appendValueInput("max_depth")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_MAXIMUM_TREE_DEPTH);
        this.appendValueInput("n_jobs")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_THREADS);
        this.appendValueInput("random_state")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.RANDOM_SEED);
        this.setInputsInline(false);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 初始化K近邻 分类/回归算法
const sklearn_KNeighborsClassifier_Regressor = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_KNN_INIT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_CLASSIFICATION_ALGORITHM, "KNeighborsClassifier"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_REGRESSION_ALGORITHM, "KNeighborsRegressor"]]), "type");
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("K")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField("K");
        this.appendValueInput("n_jobs")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_THREADS);
        this.setInputsInline(false);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 初始化高斯贝叶斯分类算法
const sklearn_GaussianNB = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_GAUSSINNB_INIT);
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 初始化K-均值聚类
const sklearn_KMeans = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_KMEANS_INIT);
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("n_clusters")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.NUMBER_OF_CLUSTERS_JUST);
        this.appendValueInput("max_iter")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_MAX_ITER);
        this.appendValueInput("random_state")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.RANDOM_SEED);
        this.appendValueInput("n_jobs")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_THREADS);
        this.setInputsInline(false);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 训练模型
const sklearn_fit = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TRAINING_MODEL);
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("train_data")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.EIGENVALUES);
        this.appendValueInput("train_target")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LABEL_VALUE);
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 训练模型-无标签值
const sklearn_fit_no_target = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TRAINING_MODEL);
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("train_data")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.EIGENVALUES);
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 模型预测
const sklearn_predict = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_PRODICTION);
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("train_data")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.EIGENVALUES);
        this.setInputsInline(true);
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 计算模型得分
const sklearn_score = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CALCULATE_THE_SCORE);
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("train_data")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.EIGENVALUES);
        this.appendValueInput("train_target")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.LABEL_VALUE);
        this.setInputsInline(true);
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 计算模型得分 - 无标签值
const sklearn_score_no_target = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.CALCULATE_THE_SCORE);
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("train_data")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.EIGENVALUES);
        this.setInputsInline(true);
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 线性回归 模型获取 斜率/截距
const sklearn_coef_intercept = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_GENERALIZED_LINEAR_REGRESSION);
        this.appendValueInput("model_name")
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .setCheck(null)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendDummyInput()
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_COEF, "coef_"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_INTERCEPT, "intercept_"]]), "type");
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn K-均值聚类 模型获取 簇中心坐标/聚类后的标签/所有点到对应簇中心的距离平方和
const sklearn_cluster_centers_labels_inertia = {
    init: function () {
        this.appendDummyInput()
            .appendField("sklearn " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_CLUSTERING);
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_GET)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_CLUSTER_CENTER, "cluster_centers_"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_LABELS_AFTER_CLUSTERING, "labels_"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_CLUSTERING_SUM_OF_SQUARED_DISTANCES, "inertia_"]]), "type");
        this.setInputsInline(true);
        this.setOutput(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

//sklearn 保存/加载模型
const sklearn_save_load_model = {
    init: function () {
        this.appendValueInput("model_name")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField("sklearn")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_SAVE_MODEL, "dump"], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.SKLEARN_LOAD_MODEL, "load"]]), "type")
            .appendField(" " + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MODEL_NAME);
        this.appendValueInput("address")
            .setCheck(null)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_PY_STORAGE_THE_PATH);
        this.setInputsInline(true);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(SKLEARN_HUE);
        this.setTooltip("");
        this.setHelpUrl("");
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/system.js":
/*!****************************************!*\
  !*** ../python_mixpy/blocks/system.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Panic_with_status_code: () => (/* binding */ Panic_with_status_code),
/* harmony export */   base_delay: () => (/* binding */ base_delay),
/* harmony export */   controls_millis: () => (/* binding */ controls_millis),
/* harmony export */   controls_mstimer2: () => (/* binding */ controls_mstimer2),
/* harmony export */   controls_mstimer2_start: () => (/* binding */ controls_mstimer2_start),
/* harmony export */   controls_mstimer2_stop: () => (/* binding */ controls_mstimer2_stop),
/* harmony export */   reset: () => (/* binding */ reset),
/* harmony export */   time_localtime: () => (/* binding */ time_localtime),
/* harmony export */   time_sleep: () => (/* binding */ time_sleep)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const SYSTEM_HUE = 120;

const base_delay = {
    init: function () {
        this.setColour(SYSTEM_HUE);
        this.appendValueInput("DELAY_TIME", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DELAY + '(' + blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MILLIS + ')')
            .setCheck(Number);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_CONTROL_DELAY);
    }
};

const controls_millis = {
    init: function () {
        this.setColour(SYSTEM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_time_time);
        this.setOutput(true, Number);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_CONTROL_MILLIS);
    }
};

const time_localtime = {
    init: function () {
        this.setColour(SYSTEM_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME)
        this.appendDummyInput()
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown([
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME_ALL, "all"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME_YEAR, "0"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME_MONTH, "1"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME_DATE, "2"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME_HOUR, "3"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME_MINUTE, "4"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME_SECOND, "5"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME_INWEEK, "6"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME_INYEAR, "7"],
                [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SYSTEM_TIME_LOCALTIME_DST, "8"]
            ]), "op");
        this.setOutput(true);
        this.setInputsInline(true);
    }
};

const Panic_with_status_code = {
    init: function () {
        this.setColour(SYSTEM_HUE);
        this.appendValueInput("STATUS_CODE", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_Panic_with_status_code)
            .setCheck(Number);
        this.setPreviousStatement(true, null);
        // this.setNextStatement(true, null);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_CONTROL_DELAY);
    }
};

const reset = {
    init: function () {
        this.setColour(SYSTEM_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_Reset_micro);
        this.setPreviousStatement(true);
        // this.setNextStatement(true);
    }
};

const controls_mstimer2 = {
    init: function () {
        this.setColour(SYSTEM_HUE);
        this.appendValueInput('TIME')
            .setCheck(Number)
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField('MsTimer2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MSTIMER2_EVERY);
        this.appendDummyInput()
            .appendField('ms');
        this.appendStatementInput('DO')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MSTIMER2_DO);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const controls_mstimer2_start = {
    init: function () {
        this.setColour(SYSTEM_HUE);
        this.appendDummyInput()
            .appendField('MsTimer2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MSTIMER2_START);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const controls_mstimer2_stop = {
    init: function () {
        this.setColour(SYSTEM_HUE);
        this.appendDummyInput()
            .appendField('MsTimer2')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_STOP);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const time_sleep = {
    init: function () {
        this.setColour(SYSTEM_HUE);
        this.appendValueInput("DELAY_TIME", Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_DELAY)
            .setCheck(Number);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SECOND)
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_CONTROL_DELAY);
    }
};

/***/ }),

/***/ "../python_mixpy/blocks/turtle.js":
/*!****************************************!*\
  !*** ../python_mixpy/blocks/turtle.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   turtle_bgcolor: () => (/* binding */ turtle_bgcolor),
/* harmony export */   turtle_bgcolor_hex: () => (/* binding */ turtle_bgcolor_hex),
/* harmony export */   turtle_bgcolor_hex_new: () => (/* binding */ turtle_bgcolor_hex_new),
/* harmony export */   turtle_circle: () => (/* binding */ turtle_circle),
/* harmony export */   turtle_circle_advanced: () => (/* binding */ turtle_circle_advanced),
/* harmony export */   turtle_clear: () => (/* binding */ turtle_clear),
/* harmony export */   turtle_clone: () => (/* binding */ turtle_clone),
/* harmony export */   turtle_color: () => (/* binding */ turtle_color),
/* harmony export */   turtle_color_hex: () => (/* binding */ turtle_color_hex),
/* harmony export */   turtle_color_seclet: () => (/* binding */ turtle_color_seclet),
/* harmony export */   turtle_create: () => (/* binding */ turtle_create),
/* harmony export */   turtle_done: () => (/* binding */ turtle_done),
/* harmony export */   turtle_exitonclick: () => (/* binding */ turtle_exitonclick),
/* harmony export */   turtle_fill: () => (/* binding */ turtle_fill),
/* harmony export */   turtle_fillcolor: () => (/* binding */ turtle_fillcolor),
/* harmony export */   turtle_fillcolor_hex: () => (/* binding */ turtle_fillcolor_hex),
/* harmony export */   turtle_fillcolor_hex_new: () => (/* binding */ turtle_fillcolor_hex_new),
/* harmony export */   turtle_getscreen: () => (/* binding */ turtle_getscreen),
/* harmony export */   turtle_goto: () => (/* binding */ turtle_goto),
/* harmony export */   turtle_listen: () => (/* binding */ turtle_listen),
/* harmony export */   turtle_move: () => (/* binding */ turtle_move),
/* harmony export */   turtle_numinput: () => (/* binding */ turtle_numinput),
/* harmony export */   turtle_onclick: () => (/* binding */ turtle_onclick),
/* harmony export */   turtle_onkey: () => (/* binding */ turtle_onkey),
/* harmony export */   turtle_ontimer: () => (/* binding */ turtle_ontimer),
/* harmony export */   turtle_pencolor: () => (/* binding */ turtle_pencolor),
/* harmony export */   turtle_pencolor_hex: () => (/* binding */ turtle_pencolor_hex),
/* harmony export */   turtle_pencolor_hex_new: () => (/* binding */ turtle_pencolor_hex_new),
/* harmony export */   turtle_penup: () => (/* binding */ turtle_penup),
/* harmony export */   turtle_pos_shape: () => (/* binding */ turtle_pos_shape),
/* harmony export */   turtle_rotate: () => (/* binding */ turtle_rotate),
/* harmony export */   turtle_screen_delay: () => (/* binding */ turtle_screen_delay),
/* harmony export */   turtle_screen_savefig: () => (/* binding */ turtle_screen_savefig),
/* harmony export */   turtle_setheading: () => (/* binding */ turtle_setheading),
/* harmony export */   turtle_setxy: () => (/* binding */ turtle_setxy),
/* harmony export */   turtle_shape: () => (/* binding */ turtle_shape),
/* harmony export */   turtle_shapesize: () => (/* binding */ turtle_shapesize),
/* harmony export */   turtle_size: () => (/* binding */ turtle_size),
/* harmony export */   turtle_size_speed: () => (/* binding */ turtle_size_speed),
/* harmony export */   turtle_speed: () => (/* binding */ turtle_speed),
/* harmony export */   turtle_textinput: () => (/* binding */ turtle_textinput),
/* harmony export */   turtle_visible: () => (/* binding */ turtle_visible),
/* harmony export */   turtle_write: () => (/* binding */ turtle_write),
/* harmony export */   turtle_write_format: () => (/* binding */ turtle_write_format),
/* harmony export */   turtle_write_format_skulpt: () => (/* binding */ turtle_write_format_skulpt)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const TURTLE_HUE = 180;

const turtle_create = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_create)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('tina'), 'VAR')
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_create_TOOLTIP);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }
};

const turtle_done = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_TURTLE_DONE);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_exitonclick = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_TURTLE_EXITONCLICK);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_move = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        var front_back =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_forward, 'forward'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_backward, 'backward']];
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            // .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_MOVE_BY)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(front_back), 'DIR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_MOVE_BY_num);

        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'forward': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_FORWARD,
                'backward': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_BACKWARD
            };
            return TOOLTIPS[mode];
        });
    }
};

const turtle_rotate = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        var front_back =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_left, 'left'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_right, 'right']];
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            // .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_rotate)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(front_back), 'DIR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MICROBIT_JS_BY_ANGLE);

        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'left': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_LEFT,
                'right': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_RIGHT
            };
            return TOOLTIPS[mode];
        });
    }
};

const turtle_setheading = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.appendValueInput('data')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_setheading);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_setheading_degree);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_screen_delay = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.appendValueInput('data')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_SCREEN_DELAY);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MILLIS);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_SCREEN_DELAY);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_goto = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.appendValueInput('data')
            .setCheck(Number)

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_goto);
        this.appendValueInput('val')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_goto_y);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_goto_position);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_setxy = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        var set_xy =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYLAB_LABEL_X, 'x'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYLAB_LABEL_Y, 'y']];
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(set_xy), 'DIR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TURTLE_SETXY);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TURTLE_SETXY_TOOLTIP);
    }
};

const turtle_pos_shape = {

    init: function () {
        this.setColour(TURTLE_HUE);
        var pos_shape =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_POS, 'pos'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_SHAPE, 'shape'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_HEADING, 'heading'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TURTLE_WIDTH, 'width'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_GET_SHAPESIZE, 'shapesize'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SPEED, 'speed']];
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_POS_SHAPE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(pos_shape), 'DIR')
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'pos': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_POS,
                'shape': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_SHAPE,
                'heading': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_HEADING,
                'width': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_WIDTH,
                'speed': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_GET_SPEED,
                'shapesize': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_GET_SHAPESIZE_TOOLTIP
            };
            return TOOLTIPS[mode];
        });
        this.setOutput(true);
        this.setInputsInline(true);

    }
};


const turtle_clear = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        var clear_reset =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_LCD_STAT_CLEAR, 'clear'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_reset, 'reset']
                , [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_home, 'home']];
        this.setColour(TURTLE_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(clear_reset), 'DIR')


        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'clear': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_CLEAR,
                'reset': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_RESET,
                'home': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_HOME
            };
            return TOOLTIPS[mode];
        });
    }
};

const turtle_penup = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        var penup_down =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_penup, 'penup'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_pendown, 'pendown']];
        this.setColour(TURTLE_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(penup_down), 'DIR')


        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'penup': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_PENUP,
                'pendown': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_PENDOWN
            };
            return TOOLTIPS[mode];
        });
    }
};

const turtle_fill = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        var fill =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_beginfill, 'begin'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_endfill, 'end']];
        this.setColour(TURTLE_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(fill), 'DIR')


        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'begin': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_BEGINFILL,
                'end': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_ENDFILL
            };
            return TOOLTIPS[mode];
        });
    }
};


const turtle_size_speed = {
    init: function () {
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('tina'), 'TUR')
        var size_speed =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_size, 'pensize'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_SPEED, 'speed']];
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            // .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_set)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(size_speed), 'DIR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_set_num);

        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'pensize': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_SIZE,
                'speed': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_SPEED
            };
            return TOOLTIPS[mode];
        });
    }
};

const turtle_size = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.appendValueInput('data')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_set_size);

        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_SIZE);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};


const turtle_speed = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.appendValueInput('data')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_set_speed);

        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_SPEED);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_circle = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        var circle_dot =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_circle, 'circle'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_dot, 'dot']];
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            // .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_draw)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(circle_dot), 'DIR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_radius);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'circle': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_CIRCLE,
                'dot': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_DOT
            };
            return TOOLTIPS[mode];
        });
    }
};

const turtle_circle_advanced = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')

        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            // .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TURTLE_DRAW_CIRCLE)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_radius);
        this.appendValueInput('data')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_angle);

        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_CIRCLE);
    }
};

const turtle_visible = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        var visible =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_hide, 'hideturtle'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_show, 'showturtle']];
        this.setColour(TURTLE_HUE);
        this.appendDummyInput("")
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(visible), 'DIR')
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        var thisBlock = this;
        this.setTooltip(function () {
            var mode = thisBlock.getFieldValue('DIR');
            var TOOLTIPS = {
                'hideturtle': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_HIDE,
                'showturtle': blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_TURTEL_SHOW
            };
            return TOOLTIPS[mode];
        });
    }
};


const turtle_bgcolor = {
    init: function () {

        this.setColour(TURTLE_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_bgcolor)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour('#ff0000'), 'FIELDNAME');
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_pencolor = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_pencolor)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour('#ff0000'), 'FIELDNAME');
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_fillcolor = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_fillcolor)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour('#ff0000'), 'FIELDNAME');
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_clone = {

    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_CLONE);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_CLONE_TOOLTIP);
        this.setOutput(true);
    }
};

const turtle_bgcolor_hex_new = {
    init: function () {

        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_bgcolor);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_pencolor_hex_new = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_pencolor);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_fillcolor_hex_new = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_fillcolor);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_color = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_pencolor)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour('#ff0000'), 'FIELDNAME');
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_fillcolor)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour('#ff0000'), 'FIELDNAME2');
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_color_hex = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR1')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_pencolor);
        this.appendValueInput('VAR2')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_fillcolor);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_bgcolor_hex = {
    init: function () {

        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_bgcolor_hex);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_pencolor_hex = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_pencolor_hex);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_fillcolor_hex = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_fillcolor_hex);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_shape = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        var shape = [
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_shape_arrow, 'arrow'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_shape_turtle, 'turtle'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_shape_circle, 'circle'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_shape_square, 'square'],
            [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_shape_triangle, 'triangle'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_shape_classic, 'classic']
        ];
        this.setColour(TURTLE_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_shape)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(shape), 'DIR');

        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_SHAPE_TOOLTIP);
    }
};

const turtle_shapesize = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')

        this.setColour(TURTLE_HUE);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_SHAPESIZE);
        this.appendValueInput('WID')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_SHAPESIZE_WID);
        this.appendValueInput('LEN')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_SHAPESIZE_LEN);
        this.appendValueInput('OUTLINE')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_SHAPESIZE_OUTLINE);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TOOLTIP_SHAPESIZE);
    }
};

const turtle_numinput = {
    init: function () {
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TURTLE_NUMINPUT)
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TITLE')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TURTLE_TEXTINPUT_TITLE);
        this.appendValueInput('PROMPT')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TURTLE_TEXTINPUT_PROMPT);
        this.appendValueInput('DEFAULT')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.DICTS_DEFAULT_VALUE);
        this.appendValueInput('MIN')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_MIN);
        this.appendValueInput('MAX')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MATH_ONLIST_OPERATOR_MAX);
        this.setInputsInline(true);
        this.setOutput(true, Number);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_NUMINPUT_TOOLTIP);
    }
};

const turtle_textinput = {
    init: function () {
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TURTLE_TEXTINPUT)
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TITLE')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TURTLE_TEXTINPUT_TITLE);
        this.appendValueInput('PROMPT')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_MIXPY_TURTLE_TEXTINPUT_PROMPT);
        this.setInputsInline(true);
        this.setOutput(true, String);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_TEXTINPUT_TOOLTIP);
    }
};

const turtle_write = {
    init: function () {
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_write);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_WRITE_TOOLTIP);
    }
};

const turtle_write_format = {
    init: function () {
        var move =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_MOVE_FALSE, 'False'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_MOVE_TRUE, 'True']];
        var align =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_ALIGN_LEFT, 'left'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_ALIGN_CENTER, 'center'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_ALIGN_RIGHT, 'right']];
        var fonttype =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_TYPE_NORMAL, 'normal'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_TYPE_BOLD, 'bold'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_TYPE_ITALIC, 'italic'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_TYPE_BOLD_ITALIC, 'bold","italic']];
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_write);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_MOVE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(move), 'MOVE');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_ALIGN)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(align), 'ALIGN');
        this.appendValueInput('FONTNAME')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_NAME);
        this.appendValueInput('FONTNUM')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_NUM);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_TYPE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(fonttype), 'FONTTYPE');
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_WRITE_TOOLTIP);
    }
};

const turtle_write_format_skulpt = {
    init: function () {
        var move =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_MOVE_FALSE, 'False'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_MOVE_TRUE, 'True']];
        var align =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_ALIGN_LEFT, 'left'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_ALIGN_CENTER, 'center'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_ALIGN_RIGHT, 'right']];
        var fonttype =
            [[blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_TYPE_NORMAL, 'normal'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_TYPE_BOLD, 'bold'], [blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_TYPE_ITALIC, 'italic']];
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.setColour(TURTLE_HUE);
        this.appendValueInput('VAR')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.blockpy_turtle_write);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_MOVE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(move), 'MOVE');
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_ALIGN)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(align), 'ALIGN');
        this.appendValueInput('FONTNAME')
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_NAME);
        this.appendValueInput('FONTNUM')
            .setCheck(Number)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_NUM);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTLE_WRITE_FONT_TYPE)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldDropdown(fonttype), 'FONTTYPE');
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.TURTLE_WRITE_TOOLTIP);
    }
};


const turtle_color_seclet = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendDummyInput("")
            .setAlign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.inputs.Align.RIGHT)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldColour("ff0000"), "COLOR");
        this.setInputsInline(true);
        this.setOutput(true, String);
    }
};

const turtle_getscreen = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
            .setCheck('Turtle')
        this.appendDummyInput("")

            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_GETSCREEN)
            .appendField(new blockly_core__WEBPACK_IMPORTED_MODULE_0__.FieldTextInput('screen'), 'VAR')

        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_GETSCREEN_TOOLTIP);
    },
    getVars: function () {
        return [this.getFieldValue('VAR')];
    },
    renameVar: function (oldName, newName) {
        if (blockly_core__WEBPACK_IMPORTED_MODULE_0__.Names.equals(oldName, this.getFieldValue('VAR'))) {
            this.setTitleValue(newName, 'VAR');
        }
    }

}

const turtle_onkey = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_EVENT_ONKEY);
        this.appendValueInput('callback')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_THREAD_USE)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_EVENT_ONKEY_TOOLTIP);
    }
};

const turtle_onclick = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_EVENT_ONCLICK);
        this.appendValueInput('callback')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_THREAD_USE)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_EVENT_ONCLICK_TOOLTIP);
    }
};

const turtle_ontimer = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
        this.appendValueInput('VAR')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_EVENT_ONTIMER);
        this.appendDummyInput("")
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_mSecond);
        this.appendValueInput('callback')
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_PYTHON_CONTROLS_THREAD_USE)
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setInputsInline(true);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_EVENT_ONTIMER_TOOLTIP);
    }
};

const turtle_listen = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
        this.appendDummyInput()
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.MIXLY_TURTEL_SCREEN_LISTEN);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
    }
};

const turtle_screen_savefig = {
    init: function () {
        this.setColour(TURTLE_HUE);
        this.appendValueInput('TUR')
        this.appendValueInput("FILE")
            .setCheck(String)
            .appendField(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_PL_SAVEFIG);
        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setOutput(false);
        this.setTooltip(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.mixpy_TURTLE_SAVEFIG_TOOLTIP);
    }
};

/***/ }),

/***/ "../python_mixpy/export.js":
/*!*********************************!*\
  !*** ../python_mixpy/export.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PythonMixpyAIBlocks: () => (/* reexport module object */ _blocks_ai__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   PythonMixpyAIGenerators: () => (/* reexport module object */ _generators_ai__WEBPACK_IMPORTED_MODULE_15__),
/* harmony export */   PythonMixpyAlgorithmBlocks: () => (/* reexport module object */ _blocks_algorithm__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   PythonMixpyAlgorithmGenerators: () => (/* reexport module object */ _generators_algorithm__WEBPACK_IMPORTED_MODULE_16__),
/* harmony export */   PythonMixpyCVBlocks: () => (/* reexport module object */ _blocks_cv__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   PythonMixpyCVGenerators: () => (/* reexport module object */ _generators_cv__WEBPACK_IMPORTED_MODULE_18__),
/* harmony export */   PythonMixpyCommunicateBlocks: () => (/* reexport module object */ _blocks_communicate__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   PythonMixpyCommunicateGenerators: () => (/* reexport module object */ _generators_communicate__WEBPACK_IMPORTED_MODULE_17__),
/* harmony export */   PythonMixpyDataBlocks: () => (/* reexport module object */ _blocks_data__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   PythonMixpyDataGenerators: () => (/* reexport module object */ _generators_data__WEBPACK_IMPORTED_MODULE_19__),
/* harmony export */   PythonMixpyDatastructureBlocks: () => (/* reexport module object */ _blocks_datastructure__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   PythonMixpyDatastructureGenerators: () => (/* reexport module object */ _generators_datastructure__WEBPACK_IMPORTED_MODULE_20__),
/* harmony export */   PythonMixpyFactoryBlocks: () => (/* reexport module object */ _blocks_factory__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   PythonMixpyFactoryGenerators: () => (/* reexport module object */ _generators_factory__WEBPACK_IMPORTED_MODULE_21__),
/* harmony export */   PythonMixpyHardwareBlocks: () => (/* reexport module object */ _blocks_hardware__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   PythonMixpyHardwareGenerators: () => (/* reexport module object */ _generators_hardware__WEBPACK_IMPORTED_MODULE_22__),
/* harmony export */   PythonMixpyIOTBlocks: () => (/* reexport module object */ _blocks_iot__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   PythonMixpyIOTGenerators: () => (/* reexport module object */ _generators_iot__WEBPACK_IMPORTED_MODULE_24__),
/* harmony export */   PythonMixpyInoutBlocks: () => (/* reexport module object */ _blocks_inout__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   PythonMixpyInoutGenerators: () => (/* reexport module object */ _generators_inout__WEBPACK_IMPORTED_MODULE_23__),
/* harmony export */   PythonMixpyPinsBlocks: () => (/* reexport module object */ _blocks_pins__WEBPACK_IMPORTED_MODULE_10__),
/* harmony export */   PythonMixpyPinsGenerators: () => (/* reexport module object */ _generators_pins__WEBPACK_IMPORTED_MODULE_25__),
/* harmony export */   PythonMixpySKLearnBlocks: () => (/* reexport module object */ _blocks_sklearn__WEBPACK_IMPORTED_MODULE_12__),
/* harmony export */   PythonMixpySKLearnGenerators: () => (/* reexport module object */ _generators_sklearn__WEBPACK_IMPORTED_MODULE_27__),
/* harmony export */   PythonMixpySerialBlocks: () => (/* reexport module object */ _blocks_serial__WEBPACK_IMPORTED_MODULE_11__),
/* harmony export */   PythonMixpySerialGenerators: () => (/* reexport module object */ _generators_serial__WEBPACK_IMPORTED_MODULE_26__),
/* harmony export */   PythonMixpySystemBlocks: () => (/* reexport module object */ _blocks_system__WEBPACK_IMPORTED_MODULE_13__),
/* harmony export */   PythonMixpySystemGenerators: () => (/* reexport module object */ _generators_system__WEBPACK_IMPORTED_MODULE_28__),
/* harmony export */   PythonMixpyTurtleBlocks: () => (/* reexport module object */ _blocks_turtle__WEBPACK_IMPORTED_MODULE_14__),
/* harmony export */   PythonMixpyTurtleGenerators: () => (/* reexport module object */ _generators_turtle__WEBPACK_IMPORTED_MODULE_29__)
/* harmony export */ });
/* harmony import */ var _blocks_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blocks/ai */ "../python_mixpy/blocks/ai.js");
/* harmony import */ var _blocks_algorithm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blocks/algorithm */ "../python_mixpy/blocks/algorithm.js");
/* harmony import */ var _blocks_communicate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blocks/communicate */ "../python_mixpy/blocks/communicate.js");
/* harmony import */ var _blocks_cv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./blocks/cv */ "../python_mixpy/blocks/cv.js");
/* harmony import */ var _blocks_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./blocks/data */ "../python_mixpy/blocks/data.js");
/* harmony import */ var _blocks_datastructure__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./blocks/datastructure */ "../python_mixpy/blocks/datastructure.js");
/* harmony import */ var _blocks_factory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./blocks/factory */ "../python_mixpy/blocks/factory.js");
/* harmony import */ var _blocks_hardware__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./blocks/hardware */ "../python_mixpy/blocks/hardware.js");
/* harmony import */ var _blocks_inout__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./blocks/inout */ "../python_mixpy/blocks/inout.js");
/* harmony import */ var _blocks_iot__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./blocks/iot */ "../python_mixpy/blocks/iot.js");
/* harmony import */ var _blocks_pins__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./blocks/pins */ "../python_mixpy/blocks/pins.js");
/* harmony import */ var _blocks_serial__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./blocks/serial */ "../python_mixpy/blocks/serial.js");
/* harmony import */ var _blocks_sklearn__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./blocks/sklearn */ "../python_mixpy/blocks/sklearn.js");
/* harmony import */ var _blocks_system__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./blocks/system */ "../python_mixpy/blocks/system.js");
/* harmony import */ var _blocks_turtle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./blocks/turtle */ "../python_mixpy/blocks/turtle.js");
/* harmony import */ var _generators_ai__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./generators/ai */ "../python_mixpy/generators/ai.js");
/* harmony import */ var _generators_algorithm__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./generators/algorithm */ "../python_mixpy/generators/algorithm.js");
/* harmony import */ var _generators_communicate__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./generators/communicate */ "../python_mixpy/generators/communicate.js");
/* harmony import */ var _generators_cv__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./generators/cv */ "../python_mixpy/generators/cv.js");
/* harmony import */ var _generators_data__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./generators/data */ "../python_mixpy/generators/data.js");
/* harmony import */ var _generators_datastructure__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./generators/datastructure */ "../python_mixpy/generators/datastructure.js");
/* harmony import */ var _generators_factory__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./generators/factory */ "../python_mixpy/generators/factory.js");
/* harmony import */ var _generators_hardware__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./generators/hardware */ "../python_mixpy/generators/hardware.js");
/* harmony import */ var _generators_inout__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./generators/inout */ "../python_mixpy/generators/inout.js");
/* harmony import */ var _generators_iot__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./generators/iot */ "../python_mixpy/generators/iot.js");
/* harmony import */ var _generators_pins__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./generators/pins */ "../python_mixpy/generators/pins.js");
/* harmony import */ var _generators_serial__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./generators/serial */ "../python_mixpy/generators/serial.js");
/* harmony import */ var _generators_sklearn__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./generators/sklearn */ "../python_mixpy/generators/sklearn.js");
/* harmony import */ var _generators_system__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./generators/system */ "../python_mixpy/generators/system.js");
/* harmony import */ var _generators_turtle__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./generators/turtle */ "../python_mixpy/generators/turtle.js");


































/***/ }),

/***/ "../python_mixpy/generators/ai.js":
/*!****************************************!*\
  !*** ../python_mixpy/generators/ai.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AI_ChooseAndGet: () => (/* binding */ AI_ChooseAndGet),
/* harmony export */   AI_Face_match: () => (/* binding */ AI_Face_match),
/* harmony export */   AI_ImageClassify: () => (/* binding */ AI_ImageClassify),
/* harmony export */   AI_ImageClassify_Func: () => (/* binding */ AI_ImageClassify_Func),
/* harmony export */   AI_Nlp: () => (/* binding */ AI_Nlp),
/* harmony export */   AI_Nlp_Func: () => (/* binding */ AI_Nlp_Func),
/* harmony export */   AI_Nlp_Func_sim: () => (/* binding */ AI_Nlp_Func_sim),
/* harmony export */   AI_Nlp_Sim: () => (/* binding */ AI_Nlp_Sim),
/* harmony export */   AI_Nlp_Topic: () => (/* binding */ AI_Nlp_Topic),
/* harmony export */   AI_Nlp_newsSummary: () => (/* binding */ AI_Nlp_newsSummary),
/* harmony export */   AI_Ocr: () => (/* binding */ AI_Ocr),
/* harmony export */   AI_Ocr_Func: () => (/* binding */ AI_Ocr_Func),
/* harmony export */   AI_Speech_asr: () => (/* binding */ AI_Speech_asr),
/* harmony export */   AI_Speech_synthesis: () => (/* binding */ AI_Speech_synthesis),
/* harmony export */   AI_audio: () => (/* binding */ AI_audio),
/* harmony export */   AI_client: () => (/* binding */ AI_client),
/* harmony export */   AI_photo: () => (/* binding */ AI_photo),
/* harmony export */   AI_result: () => (/* binding */ AI_result)
/* harmony export */ });
const AI_ChooseAndGet = function (_, generator) {
    var type = this.getFieldValue('TYPE');
    generator.definitions_['import_FileDialog'] = 'import FileDialog';
    var code = 'FileDialog.' + type + '()';
    return [code, generator.ORDER_ATOMIC];
}

const AI_client = function (_, generator) {
    var ctype = this.getFieldValue('CTYPE');
    generator.definitions_['import_aip'] = 'import aip';
    //generator.definitions_['import_aip_' + ctype] = 'from aip import '+ ctype;
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var api_key = generator.valueToCode(this, 'API_KEY', generator.ORDER_ATOMIC);
    var secret_key = generator.valueToCode(this, 'SECRET_KEY', generator.ORDER_ATOMIC);
    var code = v + ' = ' + 'aip.' + ctype + '(' + api_key + ', ' + secret_key + ')\n';
    return code;
}

const AI_Speech_synthesis = function (_, generator) {
    generator.definitions_['import_aip'] = 'import aip';
    //generator.definitions_['import_aip_AipSpeech'] = 'from aip import AipSpeech';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var s = generator.valueToCode(this, 'STR', generator.ORDER_ATOMIC);
    var attr = generator.valueToCode(this, 'ATTR', generator.ORDER_ATOMIC) || '{}';
    var code = v + '.synthesis(' + s + ', options=' + attr + ')';
    return [code, generator.ORDER_ATOMIC];
}

const AI_Speech_asr = function (_, generator) {
    generator.definitions_['import_aip'] = 'import aip';
    //generator.definitions_['import_aip_AipSpeech'] = 'from aip import AipSpeech';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    //var f = generator.valueToCode(this, 'FUNC', generator.ORDER_ATOMIC);
    var fn = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC) || '""';
    var attr = generator.valueToCode(this, 'ATTR', generator.ORDER_ATOMIC) || '{}';
    //var code = v + '.'+ f +'(' + fn + ', options=' + attr + ')';
    var code = v + '.asr(' + fn + ', options=' + attr + ')';
    return [code, generator.ORDER_ATOMIC];
}

const AI_ImageClassify = function (_, generator) {
    generator.definitions_['import_aip'] = 'import aip';
    //generator.definitions_['import_aip_AipImageClassify'] = 'from aip import AipImageClassify';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var addr = generator.valueToCode(this, 'ADDR', generator.ORDER_ATOMIC);
    var f = generator.valueToCode(this, 'FUNC', generator.ORDER_ATOMIC);
    var attr = generator.valueToCode(this, 'ATTR', generator.ORDER_ATOMIC) || '{}';
    var code = v + '.' + f + '(' + addr + ', options=' + attr + ')';
    return [code, generator.ORDER_ATOMIC];
}

const AI_Face_match = function (_, generator) {
    generator.definitions_['import_aip'] = 'import aip';
    //generator.definitions_['import_aip_AipSpeech'] = 'from aip import AipSpeech';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var s = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var s2 = generator.valueToCode(this, 'VAR2', generator.ORDER_ATOMIC);
    var attr = generator.valueToCode(this, 'ATTR', generator.ORDER_ATOMIC) || '{}';
    var code = v + '.match(' + s + ',' + s2 + ', options=' + attr + ')';
    return [code, generator.ORDER_ATOMIC];
}

const AI_Ocr = function (_, generator) {
    generator.definitions_['import_aip'] = 'import aip';
    //generator.definitions_['import_aip_Ocr'] = 'from aip import Ocr';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var addr = generator.valueToCode(this, 'ADDR', generator.ORDER_ATOMIC);
    var f = generator.valueToCode(this, 'FUNC', generator.ORDER_ATOMIC);
    var attr = generator.valueToCode(this, 'ATTR', generator.ORDER_ATOMIC) || '{}';
    var code = v + '.' + f + '(' + addr + ', options=' + attr + ')';
    return [code, generator.ORDER_ATOMIC];
}

const AI_Nlp = function (_, generator) {
    generator.definitions_['import_aip'] = 'import aip';
    //generator.definitions_['import_aip_Nlp'] = 'from aip import Nlp';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var s = generator.valueToCode(this, 'STR', generator.ORDER_ATOMIC);
    var f = generator.valueToCode(this, 'FUNC', generator.ORDER_ATOMIC);
    var attr = generator.valueToCode(this, 'ATTR', generator.ORDER_ATOMIC) || '{}';
    var code = v + '.' + f + '(' + s + ', options=' + attr + ')';
    return [code, generator.ORDER_ATOMIC];
}

const AI_Nlp_Sim = function (_, generator) {
    generator.definitions_['import_aip'] = 'import aip';
    //generator.definitions_['import_aip_Nlp'] = 'from aip import Nlp';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var s1 = generator.valueToCode(this, 'STR1', generator.ORDER_ATOMIC);
    var s2 = generator.valueToCode(this, 'STR2', generator.ORDER_ATOMIC);
    var f = generator.valueToCode(this, 'FUNC', generator.ORDER_ATOMIC);
    var attr = generator.valueToCode(this, 'ATTR', generator.ORDER_ATOMIC) || '{}';
    var code = v + '.' + f + '(' + s1 + ',' + s2 + ', options=' + attr + ')';
    return [code, generator.ORDER_ATOMIC];
}

const AI_Nlp_Topic = function (_, generator) {
    generator.definitions_['import_aip'] = 'import aip';
    //generator.definitions_['import_aip_Nlp'] = 'from aip import Nlp';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var s1 = generator.valueToCode(this, 'STR1', generator.ORDER_ATOMIC);
    var s2 = generator.valueToCode(this, 'STR2', generator.ORDER_ATOMIC);
    var code = v + '.topic(' + s1 + ',' + s2 + ')';
    return [code, generator.ORDER_ATOMIC];
}

const AI_Nlp_newsSummary = function (_, generator) {
    generator.definitions_['import_aip'] = 'import aip';
    //generator.definitions_['import_aip_Nlp'] = 'from aip import Nlp';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var s = generator.valueToCode(this, 'STR', generator.ORDER_ATOMIC);
    var n = generator.valueToCode(this, 'LEN', generator.ORDER_ATOMIC);
    var attr = generator.valueToCode(this, 'ATTR', generator.ORDER_ATOMIC) || '{}';
    var code = v + '.newsSummary(' + s + ',' + n + ', options=' + attr + ')';
    return [code, generator.ORDER_ATOMIC];
}

const AI_ImageClassify_Func = function (_, generator) {
    var code = this.getFieldValue('TYPE');
    return [code, generator.ORDER_ATOMIC];
}

const AI_Ocr_Func = function (_, generator) {
    var code = this.getFieldValue('TYPE');
    return [code, generator.ORDER_ATOMIC];
}

const AI_Nlp_Func = function (_, generator) {
    var code = this.getFieldValue('TYPE');
    return [code, generator.ORDER_ATOMIC];
}

const AI_Nlp_Func_sim = function (_, generator) {
    var code = this.getFieldValue('TYPE');
    return [code, generator.ORDER_ATOMIC];
}

const AI_audio = function (_, generator) {
    generator.definitions_['import_audio'] = 'import audio';
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var num = generator.valueToCode(this, 'TIME', generator.ORDER_ATOMIC) || '0';
    var code = "audio.audio_record(" + str + ',' + num + ")\n";
    return code;
}

const AI_photo = function (_, generator) {
    generator.definitions_['import_audio'] = 'import cam';
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var button = generator.valueToCode(this, 'BUT', generator.ORDER_ATOMIC) || '""';
    var code = "cam.photo_capture(" + str + ',' + button + ")\n";
    return code;
}

const AI_result = function (_, generator) {
    var varName = generator.valueToCode(this, 'AI', generator.ORDER_ASSIGNMENT) || '0';
    var ctype = this.getFieldValue('CTYPE');
    if (ctype == 'Image') { var code = varName + '["result"][0]["keyword"]' }
    if (ctype == 'Speech') { var code = varName + '["result"][0]' }
    if (ctype == 'Face' || ctype == 'OcrSimilarity') { var code = varName + '["score"]' }
    if (ctype == 'Ocr') { var code = varName + '["words_result"]' }

    return [code, generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python_mixpy/generators/algorithm.js":
/*!***********************************************!*\
  !*** ../python_mixpy/generators/algorithm.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   algorithm_add_path: () => (/* binding */ algorithm_add_path),
/* harmony export */   algorithm_add_school: () => (/* binding */ algorithm_add_school),
/* harmony export */   algorithm_all_books: () => (/* binding */ algorithm_all_books),
/* harmony export */   algorithm_all_books_sequence: () => (/* binding */ algorithm_all_books_sequence),
/* harmony export */   algorithm_book_scale: () => (/* binding */ algorithm_book_scale),
/* harmony export */   algorithm_check_feet: () => (/* binding */ algorithm_check_feet),
/* harmony export */   algorithm_chick_calculate: () => (/* binding */ algorithm_chick_calculate),
/* harmony export */   algorithm_color_seclet: () => (/* binding */ algorithm_color_seclet),
/* harmony export */   algorithm_current_school: () => (/* binding */ algorithm_current_school),
/* harmony export */   algorithm_del_path: () => (/* binding */ algorithm_del_path),
/* harmony export */   algorithm_delete_book: () => (/* binding */ algorithm_delete_book),
/* harmony export */   algorithm_divide_books: () => (/* binding */ algorithm_divide_books),
/* harmony export */   algorithm_find_path: () => (/* binding */ algorithm_find_path),
/* harmony export */   algorithm_first_book: () => (/* binding */ algorithm_first_book),
/* harmony export */   algorithm_fz_calc: () => (/* binding */ algorithm_fz_calc),
/* harmony export */   algorithm_fz_compare: () => (/* binding */ algorithm_fz_compare),
/* harmony export */   algorithm_fz_move: () => (/* binding */ algorithm_fz_move),
/* harmony export */   algorithm_fz_set_min: () => (/* binding */ algorithm_fz_set_min),
/* harmony export */   algorithm_get_current_location: () => (/* binding */ algorithm_get_current_location),
/* harmony export */   algorithm_get_half_books: () => (/* binding */ algorithm_get_half_books),
/* harmony export */   algorithm_hxdb_add: () => (/* binding */ algorithm_hxdb_add),
/* harmony export */   algorithm_hxdb_init_soldier: () => (/* binding */ algorithm_hxdb_init_soldier),
/* harmony export */   algorithm_hxdb_last_line: () => (/* binding */ algorithm_hxdb_last_line),
/* harmony export */   algorithm_hxdb_result: () => (/* binding */ algorithm_hxdb_result),
/* harmony export */   algorithm_hxdb_stand_in_line: () => (/* binding */ algorithm_hxdb_stand_in_line),
/* harmony export */   algorithm_init_fzsf: () => (/* binding */ algorithm_init_fzsf),
/* harmony export */   algorithm_init_hxdb: () => (/* binding */ algorithm_init_hxdb),
/* harmony export */   algorithm_init_jttl: () => (/* binding */ algorithm_init_jttl),
/* harmony export */   algorithm_move_recent: () => (/* binding */ algorithm_move_recent),
/* harmony export */   algorithm_new_path: () => (/* binding */ algorithm_new_path),
/* harmony export */   algorithm_next_book: () => (/* binding */ algorithm_next_book),
/* harmony export */   algorithm_no_left: () => (/* binding */ algorithm_no_left),
/* harmony export */   algorithm_no_path: () => (/* binding */ algorithm_no_path),
/* harmony export */   algorithm_no_ring2: () => (/* binding */ algorithm_no_ring2),
/* harmony export */   algorithm_not_home: () => (/* binding */ algorithm_not_home),
/* harmony export */   algorithm_not_school: () => (/* binding */ algorithm_not_school),
/* harmony export */   algorithm_number_add: () => (/* binding */ algorithm_number_add),
/* harmony export */   algorithm_number_zero: () => (/* binding */ algorithm_number_zero),
/* harmony export */   algorithm_prepare: () => (/* binding */ algorithm_prepare),
/* harmony export */   algorithm_prepare2: () => (/* binding */ algorithm_prepare2),
/* harmony export */   algorithm_prepare_2_1: () => (/* binding */ algorithm_prepare_2_1),
/* harmony export */   algorithm_prepare_2_2: () => (/* binding */ algorithm_prepare_2_2),
/* harmony export */   algorithm_print_book2: () => (/* binding */ algorithm_print_book2),
/* harmony export */   algorithm_print_jttl_answer: () => (/* binding */ algorithm_print_jttl_answer),
/* harmony export */   algorithm_print_number: () => (/* binding */ algorithm_print_number),
/* harmony export */   algorithm_print_path: () => (/* binding */ algorithm_print_path),
/* harmony export */   algorithm_print_path2: () => (/* binding */ algorithm_print_path2),
/* harmony export */   algorithm_rabbit_add: () => (/* binding */ algorithm_rabbit_add),
/* harmony export */   algorithm_rabbit_number_in_range: () => (/* binding */ algorithm_rabbit_number_in_range),
/* harmony export */   algorithm_rabbit_zero: () => (/* binding */ algorithm_rabbit_zero),
/* harmony export */   algorithm_return_path: () => (/* binding */ algorithm_return_path),
/* harmony export */   algorithm_set_path: () => (/* binding */ algorithm_set_path),
/* harmony export */   algorithm_two_left: () => (/* binding */ algorithm_two_left),
/* harmony export */   algorithm_void_path: () => (/* binding */ algorithm_void_path),
/* harmony export */   algorithm_yes_ring2: () => (/* binding */ algorithm_yes_ring2),
/* harmony export */   hanoi_init: () => (/* binding */ hanoi_init),
/* harmony export */   hanoi_init_offline: () => (/* binding */ hanoi_init_offline),
/* harmony export */   hanoi_move: () => (/* binding */ hanoi_move)
/* harmony export */ });
// sub_algorithm_1
const algorithm_prepare = function (_, generator) {
    generator.definitions_.import_sprite = "import sprite";
    var line1 = 'g = [[0,0,0,0,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,1,0,0,0], [0,1,1,0,1,1,0,0,0,0], [0,0,0,1,0,0,0,1,0,0], [0,0,0,1,0,0,1,1,0,0], [0,0,1,0,0,1,0,1,0,0], [0,0,0,0,1,1,1,0,0,0]]\n';
    var line2 = 'mark = [[0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0]]\n';
    var code = line1 + line2 + "vis = [0,1,0,0,0,0,0,0,0]\n";
    code += `position = [[0, 0], [200, 200], [250, 60], [320, 200], [280, 380], [470, 250], [670, 90], [650, 340]]
sprite.clearAllSprites()
sprite.createBackground('map_xuexiao')

house = [ sprite.Sprite('mark', 150, 380),
    sprite.Sprite('School', 115, 195),
    sprite.Sprite('House25', 264, 67),
    sprite.Sprite('House36', 320, 200),
    sprite.Sprite('House47', 290, 371),
    sprite.Sprite('House25', 479, 233),
    sprite.Sprite('House36', 674, 96),
    sprite.Sprite('House47', 642, 318)
]
for i in house:
    i.hide()\n`;
    return code;
}

const algorithm_add_school = function () {
    // var code = "path = [1]\n"
    //          + "list1 = [0,1,2,3,4,5,6]\n"
    //          + "list2 = [3,1,0,4,5,6,2]\n";
    var code = "path = [1]\n"
        + "car = sprite.Sprite('car', position[1][0], position[1][1])\nhouse[1].show()\n"
        + `car.nowPos = 1
def drive(n):
    if g[car.nowPos][n]==1:
        car.slideTo(position[n][0], position[n][1], 1)
        car.nowPos = n
    else:
        print('移动失败！程序有误！')
        exit()\n`;
    return code;
}

const algorithm_find_path = function (_, generator) {
    generator.definitions_.import_random = "import random";
    // var line1 = 'if random.choice([0,1]) == 0:\n'
    //           + '    list = list1\n'
    //           + 'else:\n'
    //           + '    list = list2\n'
    //           + 'f = path[(len(path) - 1)]\n'
    //           + 'flag = 0\n'
    //           + 'for _my_variable in range(7):\n'
    //           + '    if vis[_my_variable+1] == 0 and g[f][_my_variable+1] == 1:\n'
    //           + '        if mark[f][_my_variable+1] == 0:\n'
    //           + '            flag = 1\n'
    //           + '            break\n';
    var line1 = 'f = path[(len(path) - 1)]\n'
        + 'flag = 0\n'
        + 'for _my_variable in [6,5,4,3,2,1,0]:\n'
        + '    if vis[_my_variable+1] == 0 and g[f][_my_variable+1] == 1:\n'
        + '        if mark[f][_my_variable+1] == 0:\n'
        + '            flag = 1\n'
        + '            break\n';
    var code = line1;
    return code;
}

const algorithm_new_path = function (_, generator) {
    var code = "flag == 1";
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_set_path = function () {
    var code = "mark[f][_my_variable+1] = 1\nvis[_my_variable+1] = 1\n";
    return code;
}

const algorithm_add_path = function () {
    var code = "path.append(_my_variable+1)\n";
    code += `drive(path[len(path) - 1])\nhouse[_my_variable+1].show()\n`;
    return code;
}

const algorithm_del_path = function (_, generator) {
    generator.definitions_.import_time = "import time";
    var code = "del path[len(path) - 1]\n";
    code += `house[0].show()\ntime.sleep(0.5)\nhouse[0].hide()\n`;
    return code;
}

const algorithm_return_path = function () {
    var code = 'for i in range(7):\n' + '    mark[f][i+1] = 0\n' + '    vis[f] = 0\n';
    code = `house[f].hide()\ndrive(path[len(path) - 1])\n` + code;
    return code;
}

const algorithm_no_left = function (_, generator) {
    var code = "len(path) == 7";
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_print_path = function () {
    var code = 'name = ["","学校","小智家","小欣家","小思家","小科家","贝贝家","乐乐家"]\nres = ""\nfor i in path:\n    res = res + name[i] + "-"\nprint(res[:-1])\n';
    return code;
}

// sub_algorithm_2

const algorithm_prepare2 = function (_, generator) {
    generator.definitions_.import_sprite = "import sprite";
    var line1 = 'g = [[0,0,0,0,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,1,0,0,0], [0,1,1,0,1,0,0,0,0,0], [0,0,0,1,0,0,0,1,0,0], [0,0,0,1,0,0,0,1,0,0], [0,0,1,0,0,0,0,1,0,0], [0,0,0,0,1,1,1,0,0,0]]\n';
    var line2 = 'mark = [[0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0]]\n';
    var code = line1 + line2 + "vis = [0,1,0,0,0,0,0,0,0]\n";
    code += `position = [[0, 0], [200, 200], [250, 60], [320, 200], [280, 380], [470, 250], [670, 90], [650, 340]]
sprite.clearAllSprites()
sprite.createBackground('map_xuexiao')

house = [ sprite.Sprite('mark', 150, 380),
    sprite.Sprite('School', 115, 195),
    sprite.Sprite('House25', 264, 67),
    sprite.Sprite('House36', 320, 200),
    sprite.Sprite('House47', 290, 371),
    sprite.Sprite('House25', 479, 233),
    sprite.Sprite('House36', 674, 96),
    sprite.Sprite('House47', 642, 318)
]
barricade = sprite.Sprite('barricade', 570, 170)
barricade.enlargeTo(100)
for i in house:
    i.hide()\n`;
    return code;
}

const algorithm_current_school = function (_, generator) {
    var code = "f == 1";
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_no_path = function () {
    var code = "print('没有符合条件的路线')\n";
    return code;
}

// sub_algorithm_3

const algorithm_prepare_2_1 = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var line1 = 'g = [[10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000],[10000,10000,500,300,10000,10000,10000,10000,10000,10000,10000],[10000,500,10000,10000,100,10000,10000,10000,10000,10000,10000],[10000,300,10000,10000,400,300,10000,10000,10000,10000,10000],[10000,10000,100,400,10000,10000,200,10000,10000,10000,10000],[10000,10000,10000,300,10000,10000,100,200,10000,10000,10000],[10000,10000,10000,10000,200,100,10000,10000,100,10000,10000],[10000,10000,10000,10000,10000,200,10000,10000,100,10000,10000],[10000,10000,10000,10000,10000,10000,100,100,10000,10000,10000]]\n';
    var line2 = 'now=1\n';
    var code = line1 + line2 + "last=1\npath=[]\npath.append(1)\n";
    code += `name = ["","小思家","银行","邮局","餐厅","书店","医院","超市","小科家"]
position = [[0, 0], [60, 320], [510, 390], [240, 200], [750, 330], [410, 90], [540, 190], [550, 30], [720, 120]]
sprite.clearAllSprites()
sprite.createBackground('map_si_ke')
stu = sprite.Sprite('girl', 60, 320)
stu.enlargeTo(100)
time.sleep(1)\n
`
    return code;
}

const algorithm_prepare_2_2 = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var line1 = 'g =[[10000,10000,10000,10000,10000,10000,10000],[10000,10000,300,500,10000,10000,10000],[10000,300,10000,10000,300,700,10000],[10000,500,10000,10000,10000,100,10000],[10000,10000,300,10000,10000,10000,200],[10000,10000,700,100,10000,10000,100],[10000,10000,10000,10000,200,100,10000]]\n';
    var line2 = 'now=1\n';
    var code = line1 + line2 + "last=1\npath=[]\npath.append(1)\n";
    code += `name = ["","小智家","邮局","银行","书店","餐厅","学校"]
position = [[0, 0], [70, 340], [70, 90], [550, 310], [420, 70], [730, 250], [650, 130]]
sprite.clearAllSprites()
sprite.createBackground('map_zhi_xue')
stu = sprite.Sprite('boy', 70, 340)
stu.enlargeTo(100)
time.sleep(1)\n
`
    return code;
}

const algorithm_move_recent = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var line1 = 'tmp=10000\nfor i in range(0, len(g), 1):\n' + '    if g[now][i]<tmp and i!=last:\n' + '        next=i\n' + '        tmp=g[now][i]\n'
        + 'stu.slideTo(position[next][0], position[next][1], 1)\ntime.sleep(0.5)\n'
        + 'path.append(next)\n' + 'last=now\n' + 'now=next\n'
        + 'if len(path)>6:\n    print("路线错乱！程序有误！")\n    exit()\n';
    var code = line1;
    return code;
}

const algorithm_not_home = function (_, generator) {
    var code = "name[now] != '小科家'";
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_not_school = function (_, generator) {
    var code = "name[now] != '学校'";
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_print_path2 = function () {
    var code = `res = ""
for i in path:
    res = res + name[i] + "→"
print(res[:-1])\n`;

    return code;
}

// sub_algorithm_4 hanoi

const hanoi_init = function (_, generator) {
    //   generator.definitions_.import_turtle = "import turtle";
    //   generator.definitions_.import_time = "import time";
    //   generator.definitions_.import_math = "import math";
    //   function randomHexColor() {
    //     //随机生成十六进制颜色
    //     var hex = Math.floor(Math.random() * 16777216).toString(16);
    //     //生成ffffff以内16进制数
    //     while (hex.length < 6) {
    //       //while循环判断hex位数，少于6位前面加0凑够6位
    //       hex = '0' + hex;
    //     }
    //     return '#' + hex;  //返回‘#'开头16进制颜色
    //   }
    //   var num = this.getFieldValue('NUM');
    //   let colorList = [];
    //   let i = 0;
    //   while (i < num) {
    //     i++;
    //     colorList.push('"' + randomHexColor() + '"');
    //   }
    //   generator.setups_['init_Hanoi'] = `
    // def init_Hanoi():
    //     pen = turtle.Turtle()
    //     pen.hideturtle()
    //     pen.speed(0)
    //     for i in range(0, 3, 1):
    //         pen.penup()
    //         pen.setheading(0)
    //         pen.goto(150 * i - 200,-100)
    //         pen.pendown()
    //         pen.pensize(5)
    //         pen.forward(100)
    //         pen.goto(150 * i - 150,-100)
    //         pen.setheading(90)
    //         pen.forward(200)`;
    //   generator.setups_['begin'] = `
    // def begin():
    //     s = turtle.Turtle()
    //     s.hideturtle()
    //     s.penup()
    //     s.speed(0)
    //     s.goto(0,-150)
    //     s.write('3')
    //     time.sleep(1)
    //     s.clear()
    //     s.write('2')
    //     time.sleep(1)
    //     s.clear()
    //     s.write('1')
    //     time.sleep(1)
    //     s.clear()
    //     s.write('Start!')
    //     time.sleep(1)
    //     s.clear()\n`;
    //     generator.setups_['move'] = `
    // def move(x, y):
    //     try:
    //         t = tower[x].pop(-1)
    //         a = tower_num[x].pop(-1)
    //         if tower_num[y]!=[]:
    //             b = tower_num[y][-1]
    //             if a<b:
    //                 print('非法移动，不能将大盘放置在小盘上')
    //                 exit()
    //         t.goto(150 * y - 150,20 * len(tower[y]) - 90)
    //         tower[y].append(t)
    //         tower_num[y].append(a)
    //     except IndexError:
    //         print('非法移动，未找到可移动的圆盘')
    //         exit()\n`;
    //   var code = `num = ${num}
    // tower = [[], [], []]
    // tower_num = [[], [], []]
    // A,B,C=0,1,2
    // total_num=[0]
    // color= (${colorList.join(', ')})
    // init_Hanoi()
    // for i in range(0, num, 1):
    //     tina = turtle.Turtle()
    //     tina.penup()
    //     tina.shape('square')
    //     tina.color("#000000",color[i])
    //     tina.goto(-150,20 * i - 90)
    //     tower[0].append(tina)
    //     tower_num[0].append(i)
    // count_turtle=turtle.Turtle()
    // count_turtle.hideturtle()
    // count_turtle.penup()
    // count_turtle.goto(0,150)
    // count_turtle.write('总步数：0')
    // begin()\n`;
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var num = this.getFieldValue('NUM');
    if (num >= 7) var code = `print('层数过高！不得高于6层！')\nexit()\n`;
    else {
        var code = `sprite.clearAllSprites()
_Hanoicolor = ['blue', 'red', 'yellow', 'green', 'purple', 'black']
_Hanoi = [[], [], []]
A = 0
B = 1
C = 2
_n = `+ num + `
_HanoiColumn = [
    sprite.Sprite('HanoiColumn', 200, 320),
    sprite.Sprite('HanoiColumn', 400, 320),
    sprite.Sprite('HanoiColumn', 600, 320)
]
_HanoiColumnNumber = [
    sprite.Text('A', 190, 120),
    sprite.Text('B', 390, 120),
    sprite.Text('C', 590, 120)
]
_HanoiBlock = []
for i in range(0, _n, 1):
    _HanoiBlock.append(sprite.Sprite(_Hanoicolor[i], 200, 400-(_n-i-1)*27))
    _HanoiBlock[i].setScale(25, 30*i+30)
    _Hanoi[0].insert(0, _HanoiBlock[i])
_steptext = sprite.Text('步数：0', 30, 30)
_steps = {'steps' : 0}
time.sleep(1)\n`
    }
    return code;
}

const hanoi_move = function (_, generator) {
    var fromNum = generator.valueToCode(this, 'FROM_NUM', generator.ORDER_ATOMIC) || '0';
    var toNum = generator.valueToCode(this, 'TO_NUM', generator.ORDER_ATOMIC) || '0';
    // var code = `move(${fromNum}, ${toNum})\ntotal_num[0]+=1\ncount_turtle.clear()\ncount_turtle.write('总步数：'+str(total_num[0]))\n`;
    var code = `if len(_Hanoi[${fromNum}])>0 :
    _HanoiBlockMoved = _Hanoi[${fromNum}].pop()
    if len(_Hanoi[${toNum}]) > 0 :
        _HanoiBlockSuppressed = _Hanoi[${toNum}].pop()
        if _HanoiBlock.index(_HanoiBlockMoved) > _HanoiBlock.index(_HanoiBlockSuppressed):
            print('非法移动！程序有误！')
            exit()
        else:
            _Hanoi[${toNum}].append(_HanoiBlockSuppressed)
    _HanoiBlockMoved.slideTo(${fromNum}*200+200, 180, 0.2)
    _HanoiBlockMoved.slideTo(${toNum}*200+200, 180, 0.5)
    _HanoiBlockMoved.slideTo(${toNum}*200+200, 400-len(_Hanoi[${toNum}])*27, 0.2)
    _Hanoi[${toNum}].append(_HanoiBlockMoved)
    _steps['steps'] += 1
    _steptext.changeText('步数：'+str(_steps['steps']))
else :
    print('非法移动！程序有误！')
    exit()
`
    return code;
}

// sub_algorithm_5

const algorithm_all_books_sequence = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `if 'mode' not in globals() or mode == 0:
    sprite.clearAllSprites()
    ring=[0,0,0,0,0,0,0,0,0,0]
    mode=1
    n=5
    ring[5]=1
    name=['小王子','海底两万里','荷花镇的早市','孔子的故事','夏洛的网','草房子','月下看猫头鹰','会唱歌的咖啡磨','父与子','城南旧事']
    Books = []
    for i in range(1, 11, 1):
        Books.append(sprite.Sprite('books/book'+str(i), (130*i-650) if i>5 else 130*i, 320 if i>5 else 120))
else:
    mode=2
    n=len(ring)-1\nring[n]=1
time.sleep(1)\n`;
    return code;
}

const algorithm_all_books = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `if 'mode' not in globals() or mode == 0:
    sprite.clearAllSprites()
    ring=[0,0,0,0,0,0,0,0,0,0]
    mode=2
    n=5
    name=['小王子','海底两万里','荷花镇的早市','孔子的故事','夏洛的网','草房子','月下看猫头鹰','会唱歌的咖啡磨','父与子','城南旧事']
    Books = []
    for i in range(1, 11, 1):
        Books.append(sprite.Sprite('books/book'+str(i), (130*i-650) if i>5 else 130*i, 320 if i>5 else 120))
else:
    mode=1
    n=len(ring)-1
ring[n]=n
list=ring
temp=Books
time.sleep(1)\n`;
    return code;
}

const algorithm_first_book = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var line1 = 'res=0\n';
    var code = line1 + "flag=ring[res]\n";
    code += `Books[res].filterBrighter()\ntime.sleep(0.1)\nBooks[res].filterOrigin()\n`;
    return code;
}

// export const algorithm_no_ring = function() {
//   var code = "ring[i]==0";
//   return [code, generator.ORDER_ATOMIC];
// };

const algorithm_no_ring2 = function (_, generator) {
    var code = "(('mode' not in globals())or(mode==1 and flag==0)or(mode==2 and not any(value > 0 for value in qian))or(mode==0))";
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_yes_ring2 = function (_, generator) {
    var code = "(('mode' in globals())and((mode==1 and flag!=0)or(mode==2 and any(value > 0 for value in qian))))";
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_next_book = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = "res+=1\nflag=ring[res]\n";
    code += `Books[res].filterBrighter()\ntime.sleep(0.1)\nBooks[res].filterOrigin()\n`;
    code = `Books[res].filterGray()\ntime.sleep(0.3)\n` + code;
    return code;
}

const algorithm_two_left = function (_, generator) {
    var code = "len(list)>=2";
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_divide_books = function () {
    var code = `mid = int(len(list)/2)
qian = list[0:mid]
hou = list[mid:]
qiantemp = temp[0:mid]
houtemp = temp[mid:]\n`;
    return code;
}

const algorithm_get_half_books = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `quchu = qian
list = hou
quchutemp = qiantemp
temp = houtemp
for i in qiantemp:
    i.filterBrighter()
time.sleep(0.5)
for i in qiantemp:
    i.filterGray()
time.sleep(0.5)\n`;
    return code;
}

// export const algorithm_check_half_books = function() {
//   var code = "while ring[i]==0:\n    if i==mid:\n        flag=0\n        break\n    i+=1\n";
//   return code;
// };

const algorithm_delete_book = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `list = quchu
temp = quchutemp
for i in qiantemp:
    i.filterBrighter()
time.sleep(0.5)
for i in qiantemp:
    i.filterOrigin()
for i in houtemp:
	i.filterBrighter()
time.sleep(0.5)
for i in houtemp:
    i.filterGray()
time.sleep(0.5)\n`;
    return code;
}

// export const algorithm_print_book = function() {
//   var code = "print(i)\n";
//   return code;
// };

const algorithm_print_book2 = function () {
    var code = `if 'list' in globals():
    res = list[0]
Books[res].filterBrighter()
print('未消磁的书籍是第'+str(res+1)+'本《'+name[res%10]+'》。')
if res!=n:
    print('答案错误！请检查程序！')
mode=0\n`;
    return code;
}

// sub_algorithm_6

const algorithm_book_scale = function (_, generator) {
    var FIELD_NUM = this.getFieldValue("NUM");
    const pos = {
        5: '130*i, 120',
        10: '(130*i-650) if i>5 else 130*i, 320 if i>5 else 120',
        20: '(65*i-650)+30 if i>10 else 65*i+30, 320 if i>10 else 120',
        50: '(26*i-650)+50 if i>25 else 26*i+50, 320 if i>25 else 120'
    }
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `sprite.clearAllSprites()
ring = []
name = ['小王子','海底两万里','荷花镇的早市','孔子的故事','夏洛的网','草房子','月下看猫头鹰','会唱歌的咖啡磨','父与子','城南旧事']
Books = []
for i in range(${FIELD_NUM}):
    ring.append(0)
for i in range(1, ${FIELD_NUM}+1, 1):
    Books.append(sprite.Sprite('books/book'+str(i%10 if i%10!=0 else 10), ${pos[FIELD_NUM]}))
time.sleep(1)
mode=3
`
    return code;
}

const algorithm_number_zero = function (_, generator) {
    generator.definitions_.import_sprite = "import sprite";
    var code = "cnt=0\n";
    code += `cntText = sprite.Text('计数器：0', 30, 200)\n`
    return code;
}

const algorithm_number_add = function (_, generator) {
    generator.definitions_.import_sprite = "import sprite";
    var code = "cnt+=1\n";
    code += `cntText.changeText('计数器：'+str(cnt))\n`
    return code;
}

const algorithm_print_number = function (_, generator) {
    generator.definitions_.import_sprite = "import sprite";
    var code = "print('计数器大小：'+str(cnt))\n";
    return code;
}

// export const algorithm_get_book_num = function() {
//   var code = 'n='+this.getFieldValue('NUM')+'\n';
//   return code;
// };

// export const algorithm_print_sequence = function() {
//   var code = 'print("顺序法查找次数为：",cnt)';
//   return code;
// };

// export const algorithm_print_divide = function() {
//   var code = 'print("二分法查找次数为：",cnt)';
//   return code;
// };

// sub_algorithm_7

const algorithm_init_jttl = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `sprite.clearAllSprites()
_head = 10
_foot = 32
_footText = sprite.Text('脚的数量：', 20, 10)
_sprite = []\n`;
    return code;
}

const algorithm_rabbit_zero = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `_rabbit = 0\n`;
    // code += `_sprite.append(sprite.Sprite('jttl/rabbit', len(_sprite)*130+130 if len(_sprite)<5 else len(_sprite)*130+130-650, 120 if len(_sprite)<5 else 320))\n`;
    code += `time.sleep(1)\n`;
    return code;
}

const algorithm_rabbit_number_in_range = function (_, generator) {
    var code = `_rabbit < _head`;
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_chick_calculate = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `_chick = _head - _rabbit\n`;
    code += `for i in range(0, _chick, 1):
    _sprite.append(sprite.Sprite('jttl/chick', len(_sprite)*130+130 if len(_sprite)<5 else len(_sprite)*130+130-650, 120 if len(_sprite)<5 else 320))\n
time.sleep(0.5)
_footText.changeText('脚的数量：'+str(_rabbit*4 + _chick*2))
time.sleep(1)\n`
    return code;
}

const algorithm_check_feet = function (_, generator) {
    var code = `_rabbit*4 + _chick*2 == _foot`;
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_print_jttl_answer = function (_, generator) {
    generator.definitions_.import_sprite = "import sprite";
    var code = `print('鸡的数量：'+str(_chick)+'只；\\n兔的数量：'+str(_rabbit)+'只。')\n`;
    return code;
}

const algorithm_rabbit_add = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `_rabbit += 1\n`;
    code += `sprite.clearAllSprites()
_sprite = []
_footText = sprite.Text('脚的数量：', 20, 10)
for i in range(0, _rabbit, 1):
    _sprite.append(sprite.Sprite('jttl/rabbit', len(_sprite)*130+130 if len(_sprite)<5 else len(_sprite)*130+130-650, 120 if len(_sprite)<5 else 320))\n`
    code += `time.sleep(0.5)\n`;
    return code;
}

// sub_algorithm_8

const algorithm_init_fzsf = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = ``;
    code += `sprite.clearAllSprites()
sprite.createBackground('/fzsf/map_ck_xxjsjs')
_S1 = sprite.Sprite('/fzsf/S1',400,225,'S1')
_S2 = sprite.Sprite('/fzsf/S2',400,225,'S2')
_S3 = sprite.Sprite('/fzsf/S3',400,225,'S3')
_S4 = sprite.Sprite('/fzsf/S4',400,225,'S4')
_S1.hide()
_S2.hide()
_S3.hide()
_S4.hide()
_text_1 = sprite.Text('S1：',0,0,'text')
_text_2 = sprite.Text('S2：',0,30,'text2')
_text_3 = sprite.Text('S3：',0,60,'text3')
_text_4 = sprite.Text('S4：',0,90,'text4')
_position = [[60, 270], [240, 50], [260, 380], [440, 190], [730, 60], [700, 400]]
_Llen = [0, 170, 230, 100, 150, 10, 30, 50]
_Slen = [0, 0, 0, 0, 0]
_tag = [0, [0, 1, 3], [0, 2, 3], [3, 4, 5], [3, 5]]
bear = sprite.Sprite('mixbear',60,270,'bear')
bear.enlargeTo(80)
_pos = 0
time.sleep(1)\n`;
    return code;
}

const algorithm_fz_calc = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var FIELD_PATHNAME = this.getFieldValue("PATHNAME");
    const calc = [0, [1, 3], [2, 4], [5, 7], [6]]
    var code = ``;
    code += `_S${FIELD_PATHNAME}.show()
time.sleep(1)\n`;
    if (FIELD_PATHNAME != 4) {
        code += `_Slen[${FIELD_PATHNAME}] = _Llen[${calc[FIELD_PATHNAME][0]}] + _Llen[${calc[FIELD_PATHNAME][1]}]
_text_${FIELD_PATHNAME}.changeText('S${FIELD_PATHNAME}：'+str(_Slen[${FIELD_PATHNAME}])+'m')
time.sleep(1)
_S${FIELD_PATHNAME}.hide()
time.sleep(1)\n`;
    } else {
        code += `_Slen[4] = _Llen[6]
_text_4.changeText('S4：'+str(_Slen[4])+'m')
time.sleep(1)
_S4.hide()
time.sleep(1)\n`;
    }
    return code;
}

const algorithm_fz_compare = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var FIELD_PATHNAME = this.getFieldValue("PATHNAME");
    var FIELD_PATHNAME2 = this.getFieldValue("PATHNAME2");
    var code = ``;
    code += `_Slen[${FIELD_PATHNAME}] < _Slen[${FIELD_PATHNAME2}]`;
    return [code, generator.ORDER_ATOMIC];
    // `if(_Slen[${FIELD_PATHNAME}]==0 or _Slen[${FIELD_PATHNAME2}]==0):
    //     print('请先计算出长度再比较！程序有误！')
    //     exit()
    // _S${FIELD_PATHNAME}.show()
    // time.sleep(0.5)
    // _S${FIELD_PATHNAME}.hide()
    // time.sleep(0.5)
    // _S${FIELD_PATHNAME}.show()
    // time.sleep(0.5)
    // _S${FIELD_PATHNAME2}.show()
    // time.sleep(0.5)
    // _S${FIELD_PATHNAME2}.hide()
    // time.sleep(0.5)
    // _S${FIELD_PATHNAME2}.show()
    // time.sleep(0.5)
    // if(_Slen[${FIELD_PATHNAME}] < _Slen[${FIELD_PATHNAME2}]):
    //     _S${FIELD_PATHNAME2}.hide()
    //     _S${FIELD_PATHNAME}.show()
    // else :
    //     _S${FIELD_PATHNAME}.hide()
    //     _S${FIELD_PATHNAME2}.show()
    // time.sleep(1)
    // _S${FIELD_PATHNAME}.hide()
    // _S${FIELD_PATHNAME2}.hide()\n`;
    // return code;
}

const algorithm_fz_set_min = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var FIELD_PATHNAME = this.getFieldValue("PATHNAME");
    var code = ``;
    code += `
_S1.hide()
_S2.hide()
_S3.hide()
_S4.hide()
_Smin = ${FIELD_PATHNAME}
_S${FIELD_PATHNAME}.show()
time.sleep(0.5)
_S${FIELD_PATHNAME}.hide()
time.sleep(0.5)
_S${FIELD_PATHNAME}.show()
time.sleep(1)\n`;
    return code;
}

const algorithm_fz_move = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = ``;
    code += `if(_pos == _tag[_Smin][0]):
    for i in range(1, len(_tag[_Smin]), 1):
        bear.slideTo(_position[_tag[_Smin][i]][0], _position[_tag[_Smin][i]][1], 1)
    _pos = _tag[_Smin][len(_tag[_Smin])-1]
else:
    print('移动错误！程序有误！')
    exit()
_S1.hide()
_S2.hide()
_S3.hide()
_S4.hide()
if(_pos == 5):
    print('成功抵达信息科技教室！')\n`;
    return code;
}

// sub_algorithm_9

const algorithm_init_hxdb = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = ``;
    code += `sprite.clearAllSprites()
sprite.createBackground('/hxdb/hxdbbg')
_soldier = []
_num = sprite.Text('目前士兵数量：0',0,0,'num')
_last = sprite.Text('剩余：0',500,0,'last')
_line = 3\n`;
    return code;
}

const algorithm_hxdb_init_soldier = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var FIELD_NUM = this.getFieldValue("NUM");
    var code = ``;
    code += `for i in range(0, ${FIELD_NUM}, 1):
    _soldier.append(sprite.Sprite('/hxdb/soldier', 30 + (len(_soldier)%_line)*50 + (len(_soldier)//(4*_line))*(_line+1)*50 +(len(_soldier)%3-2), 80+(len(_soldier)//_line)*100-(len(_soldier)//(4*_line))*4*100+(len(_soldier)%2)))
_num.changeText('目前士兵数量：'+str(len(_soldier)))\n`;
    return code;
}

const algorithm_hxdb_stand_in_line = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var FIELD_NAME = this.getFieldValue("NUM");
    var code = `for i in range(0, len(_soldier), 1):
    _soldier[i].slideTo(30 + (i%${FIELD_NAME})*50 + (i//(4*${FIELD_NAME}))*(${FIELD_NAME}+1)*50 +(i%3-2), 80+(i//${FIELD_NAME})*100-(i//(4*${FIELD_NAME}))*4*100+(i%2), 0.05)
_line = ${FIELD_NAME}
_last.changeText('剩余：'+str(len(_soldier)%_line))
time.sleep(2)\n`;
    return code;
}

const algorithm_hxdb_last_line = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var FIELD_NAME = this.getFieldValue("NUM");
    var code = `len(_soldier)%_line == ${FIELD_NAME}`;
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_hxdb_add = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `_num.changeText('目前士兵数量：'+str(len(_soldier)+1))
_last.changeText('剩余：')
time.sleep(0.5)
_soldier.append(sprite.Sprite('/hxdb/soldier', 30 + (len(_soldier)%_line)*50 + (len(_soldier)//(4*_line))*(_line+1)*50 +(len(_soldier)%3-2), 80+(len(_soldier)//_line)*100-(len(_soldier)//(4*_line))*4*100+(len(_soldier)%2)))
time.sleep(1)\n`;
    return code;
}

const algorithm_hxdb_result = function (_, generator) {
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_sprite = "import sprite";
    var code = `print('符合要求的士兵数量为：'+str(len(_soldier)))\n`;
    return code;
}

// others

const hanoi_init_offline = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    generator.definitions_.import_time = "import time";
    generator.definitions_.import_math = "import math";
    var color = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var num = this.getFieldValue('NUM');
    generator.setups_['init_Hanoi'] = `
def init_Hanoi():
    pen = turtle.Turtle()
    pen.hideturtle()
    pen.speed(0)
    for i in range(0, 3, 1):
        pen.penup()
        pen.setheading(0)
        pen.goto(150 * i - 200,-100)
        pen.pendown()
        pen.pensize(5)
        pen.forward(100)
        pen.goto(150 * i - 150,-100)
        pen.setheading(90)
        pen.forward(200)`;
    generator.setups_['begin'] = `
def begin():    
    s = turtle.Turtle()
    s.hideturtle()
    s.penup()
    s.speed(0)
    s.goto(0,-150)
    s.write('3')
    time.sleep(1)
    s.clear()
    s.write('2')
    time.sleep(1)
    s.clear()
    s.write('1')
    time.sleep(1)
    s.clear()
    s.write('Start!')
    time.sleep(1)
    s.clear()\n`;
    generator.setups_['move'] = `
def move(x, y):
    try:
        t = tower[x].pop(-1)
        a = tower_num[x].pop(-1)
        if tower_num[y]!=[]:
            b = tower_num[y][-1]
            if a<b:
                print('非法移动，不能将大盘放置在小盘上')
                exit()        
        t.goto(150 * y - 150,20 * len(tower[y]) - 90)
        tower[y].append(t)
        tower_num[y].append(a)
    except IndexError:
        print('非法移动，未找到可移动的圆盘')
        exit()\n`;
    var code = `num = ${num}
tower = [[], [], []]
tower_num = [[], [], []]
A,B,C=0,1,2
total_num=[0]
color= (${color})
init_Hanoi()
for i in range(0, num, 1):
    tina = turtle.Turtle()
    tina.penup()
    tina.shape('square')
    if num == 1:
        tina.shapesize(1,7,1)
    else:
        tina.shapesize(1,7 - (6 / (num - 1)) * i,1)
    tina.color("#000000",color)
    tina.speed(3)
    tina.goto(-150,20 * i - 90)
    tower[0].append(tina)
    tower_num[0].append(i)
count_turtle=turtle.Turtle()
count_turtle.hideturtle()
count_turtle.penup()
count_turtle.goto(0,150)
count_turtle.write('总步数：0')    
begin()\n`;
    return code;
}

const algorithm_get_current_location = function () {
    var line1 = 'f = path[(len(path) - 1)]\n';
    var code = line1;
    return code;
}

const algorithm_void_path = function (_, generator) {
    var code = "len(path)==0";
    return [code, generator.ORDER_ATOMIC];
}

const algorithm_color_seclet = function (_, generator) {
    var colour = this.getFieldValue('COLOR');
    var code = '"' + colour + '"'
    return [code, generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python_mixpy/generators/communicate.js":
/*!*************************************************!*\
  !*** ../python_mixpy/generators/communicate.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   requests_attribute: () => (/* binding */ requests_attribute),
/* harmony export */   requests_get: () => (/* binding */ requests_get),
/* harmony export */   requests_get_old: () => (/* binding */ requests_get_old),
/* harmony export */   requests_method: () => (/* binding */ requests_method),
/* harmony export */   requests_post: () => (/* binding */ requests_post)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const requests_get_old = function (_, generator) {
    generator.definitions_.import_requests = "import requests";
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var str = generator.valueToCode(this, 'DOMAIN', generator.ORDER_ATOMIC);
    var code = varName + '= ' + 'requests.get(' + str + ')\n';
    return code;
}

const requests_get = function (_, generator) {
    generator.definitions_.import_requests = "import requests";
    var dropdown_type = this.getFieldValue('TYPE');
    var str = generator.valueToCode(this, 'URL', generator.ORDER_ATOMIC);
    var code = 'requests.' + dropdown_type + '(' + str + ')';
    return [code, generator.ORDER_ATOMIC];
}

const requests_post = function (_, generator) {
    generator.definitions_.import_requests = "import requests";
    var dropdown_type = this.getFieldValue('TYPE');
    var str = generator.valueToCode(this, 'URL', generator.ORDER_ATOMIC);
    var data = generator.valueToCode(this, 'data', generator.ORDER_ATOMIC);
    var code = 'requests.' + dropdown_type + '(' + str + ',data=' + data + ')';
    return [code, generator.ORDER_ATOMIC];
}

const requests_attribute = function (_, generator) {
    generator.definitions_.import_requests = "import requests";
    var varName = generator.valueToCode(this, 'VAL', generator.ORDER_ASSIGNMENT) || '0';
    var attr = this.getFieldValue('ATTR');
    var code = varName + "." + attr;
    return [code, generator.ORDER_ATOMIC];
}

const requests_method = function (_, generator) {
    generator.definitions_.import_requests = "import requests";
    var method = this.getFieldValue('DIR');
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = "requests." + method + "(" + str + ')\n';
    return code;
}

/***/ }),

/***/ "../python_mixpy/generators/cv.js":
/*!****************************************!*\
  !*** ../python_mixpy/generators/cv.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cv_destroy_all: () => (/* binding */ cv_destroy_all),
/* harmony export */   cv_face_classifier: () => (/* binding */ cv_face_classifier),
/* harmony export */   cv_face_detect: () => (/* binding */ cv_face_detect),
/* harmony export */   cv_face_detect_all: () => (/* binding */ cv_face_detect_all),
/* harmony export */   cv_line_rect: () => (/* binding */ cv_line_rect),
/* harmony export */   cv_read_image: () => (/* binding */ cv_read_image),
/* harmony export */   cv_show_image: () => (/* binding */ cv_show_image),
/* harmony export */   cv_text: () => (/* binding */ cv_text),
/* harmony export */   cv_waitkey: () => (/* binding */ cv_waitkey),
/* harmony export */   cv_write_image: () => (/* binding */ cv_write_image)
/* harmony export */ });
const cv_read_image = function (_, generator) {
    generator.definitions_['import_cv2'] = 'import cv2';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = "cv2.imread(" + file + ")";
    return [code, generator.ORDER_ATOMIC];
}

const cv_show_image = function (_, generator) {
    generator.definitions_['import_cv2'] = 'import cv2';
    var data = generator.valueToCode(this, 'data', generator.ORDER_ATOMIC);
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = "cv2.imshow(" + data + ',' + file + ")\n";
    return code;
}

const cv_write_image = function (_, generator) {
    generator.definitions_['import_cv2'] = 'import cv2';
    var data = generator.valueToCode(this, 'data', generator.ORDER_ATOMIC);
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = "cv2.imwrite(" + data + ',' + file + ")\n";
    return code;
}

const cv_waitkey = function (_, generator) {
    generator.definitions_['import_cv2'] = 'import cv2';
    var data = generator.valueToCode(this, 'data', generator.ORDER_ATOMIC);
    var code = "cv2.waitKey(" + data + ")\n";
    return code;
}

const cv_destroy_all = function (_, generator) {
    generator.definitions_['import_cv2'] = 'import cv2';
    var code = "cv2.destroyAllWindows()\n";
    return code;
}

const cv_line_rect = function (_, generator) {
    generator.definitions_['import_cv2'] = 'import cv2';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var x1 = generator.valueToCode(this, 'x1', generator.ORDER_ATOMIC);
    var y1 = generator.valueToCode(this, 'y1', generator.ORDER_ATOMIC);
    var x2 = generator.valueToCode(this, 'x2', generator.ORDER_ATOMIC);
    var y2 = generator.valueToCode(this, 'y2', generator.ORDER_ATOMIC);
    var thick = generator.valueToCode(this, 'thick', generator.ORDER_ATOMIC);
    var color = this.getFieldValue('FIELDNAME');
    var color1 = eval('0x' + color[1] + color[2])
    var color2 = eval('0x' + color[3] + color[4])
    var color3 = eval('0x' + color[5] + color[6])
    var direction = this.getFieldValue('DIR');
    var code = "cv2." + direction + "(" + file + ',(' + x1 + ',' + y1 + '),(' + x2 + ',' + y2 + '),(' + color3 + ',' + color2 + ',' + color1 + '),' + thick + ")\n";
    return code;
}

const cv_text = function (_, generator) {
    generator.definitions_['import_cv2'] = 'import cv2';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var x1 = generator.valueToCode(this, 'x1', generator.ORDER_ATOMIC);
    var y1 = generator.valueToCode(this, 'y1', generator.ORDER_ATOMIC);
    var data = generator.valueToCode(this, 'data', generator.ORDER_ATOMIC);
    var size = generator.valueToCode(this, 'size', generator.ORDER_ATOMIC);
    var thick = generator.valueToCode(this, 'thick', generator.ORDER_ATOMIC);
    var color = this.getFieldValue('FIELDNAME');
    var color1 = eval('0x' + color[1] + color[2])
    var color2 = eval('0x' + color[3] + color[4])
    var color3 = eval('0x' + color[5] + color[6])
    var font = this.getFieldValue('font');
    var code = "cv2.putText(" + file + ',' + data + ',(' + x1 + ',' + y1 + '),cv2.FONT_HERSHEY_' + font + ',' + size + ',(' + color3 + ',' + color2 + ',' + color1 + '),' + thick + ")\n";
    return code;
}

const cv_face_classifier = function (_, generator) {
    generator.definitions_['import_cv2'] = 'import cv2';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = "cv2.CascadeClassifier(" + file + ")";
    return [code, generator.ORDER_ATOMIC];
}

const cv_face_detect = function (_, generator) {
    generator.definitions_['import_cv2'] = 'import cv2';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var face = generator.valueToCode(this, 'FACE', generator.ORDER_ATOMIC);
    var scale = generator.valueToCode(this, 'SCALE', generator.ORDER_ATOMIC);
    var neighbor = generator.valueToCode(this, 'NEIGHBOR', generator.ORDER_ATOMIC);
    var code = face + ".detectMultiScale(" + file + ',scaleFactor=' + scale + ',minNeighbors=' + neighbor + ")";
    return [code, generator.ORDER_ATOMIC];
}

const cv_face_detect_all = function (_, generator) {
    generator.definitions_['import_cv2'] = 'import cv2';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var face = generator.valueToCode(this, 'FACE', generator.ORDER_ATOMIC);
    var scale = generator.valueToCode(this, 'SCALE', generator.ORDER_ATOMIC);
    var neighbor = generator.valueToCode(this, 'NEIGHBOR', generator.ORDER_ATOMIC);
    var x1 = generator.valueToCode(this, 'x1', generator.ORDER_ATOMIC);
    var y1 = generator.valueToCode(this, 'y1', generator.ORDER_ATOMIC);
    var x2 = generator.valueToCode(this, 'x2', generator.ORDER_ATOMIC);
    var y2 = generator.valueToCode(this, 'y2', generator.ORDER_ATOMIC);
    var code = face + ".detectMultiScale(" + file + ',scaleFactor=' + scale + ',minNeighbors=' + neighbor + ',minSize=(' + x1 + ',' + y1 + '),maxSize=(' + x2 + ',' + y2 + "))";
    return [code, generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python_mixpy/generators/data.js":
/*!******************************************!*\
  !*** ../python_mixpy/generators/data.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   array_create: () => (/* binding */ array_create),
/* harmony export */   array_toarray: () => (/* binding */ array_toarray),
/* harmony export */   dataframe_aggregate_func: () => (/* binding */ dataframe_aggregate_func),
/* harmony export */   dataframe_create: () => (/* binding */ dataframe_create),
/* harmony export */   dataframe_create_from_index: () => (/* binding */ dataframe_create_from_index),
/* harmony export */   dataframe_create_from_one_index: () => (/* binding */ dataframe_create_from_one_index),
/* harmony export */   dataframe_fillna: () => (/* binding */ dataframe_fillna),
/* harmony export */   dataframe_get: () => (/* binding */ dataframe_get),
/* harmony export */   dataframe_groupby: () => (/* binding */ dataframe_groupby),
/* harmony export */   dataframe_head_tail: () => (/* binding */ dataframe_head_tail),
/* harmony export */   dataframe_info: () => (/* binding */ dataframe_info),
/* harmony export */   dataframe_median: () => (/* binding */ dataframe_median),
/* harmony export */   dataframe_select: () => (/* binding */ dataframe_select),
/* harmony export */   dataframe_sort_values: () => (/* binding */ dataframe_sort_values),
/* harmony export */   matrix_multiplication: () => (/* binding */ matrix_multiplication),
/* harmony export */   matrix_transpose: () => (/* binding */ matrix_transpose),
/* harmony export */   numpy_argmin_template_match: () => (/* binding */ numpy_argmin_template_match),
/* harmony export */   numpy_astype: () => (/* binding */ numpy_astype),
/* harmony export */   numpy_c_: () => (/* binding */ numpy_c_),
/* harmony export */   numpy_dot: () => (/* binding */ numpy_dot),
/* harmony export */   numpy_linalg_det: () => (/* binding */ numpy_linalg_det),
/* harmony export */   numpy_linalg_inv: () => (/* binding */ numpy_linalg_inv),
/* harmony export */   numpy_max: () => (/* binding */ numpy_max),
/* harmony export */   numpy_mean: () => (/* binding */ numpy_mean),
/* harmony export */   numpy_mean_digit: () => (/* binding */ numpy_mean_digit),
/* harmony export */   numpy_min: () => (/* binding */ numpy_min),
/* harmony export */   numpy_ones: () => (/* binding */ numpy_ones),
/* harmony export */   numpy_random_random: () => (/* binding */ numpy_random_random),
/* harmony export */   numpy_reshape: () => (/* binding */ numpy_reshape),
/* harmony export */   numpy_shape: () => (/* binding */ numpy_shape),
/* harmony export */   numpy_size: () => (/* binding */ numpy_size),
/* harmony export */   numpy_square: () => (/* binding */ numpy_square),
/* harmony export */   numpy_std: () => (/* binding */ numpy_std),
/* harmony export */   numpy_sum: () => (/* binding */ numpy_sum),
/* harmony export */   numpy_trig: () => (/* binding */ numpy_trig),
/* harmony export */   pandas_drop_columns: () => (/* binding */ pandas_drop_columns),
/* harmony export */   pandas_dropna: () => (/* binding */ pandas_dropna),
/* harmony export */   pandas_readcsv: () => (/* binding */ pandas_readcsv),
/* harmony export */   pl_axes: () => (/* binding */ pl_axes),
/* harmony export */   pl_bar: () => (/* binding */ pl_bar),
/* harmony export */   pl_hist: () => (/* binding */ pl_hist),
/* harmony export */   pl_label: () => (/* binding */ pl_label),
/* harmony export */   pl_legend: () => (/* binding */ pl_legend),
/* harmony export */   pl_pie: () => (/* binding */ pl_pie),
/* harmony export */   pl_plot: () => (/* binding */ pl_plot),
/* harmony export */   pl_plot_bar: () => (/* binding */ pl_plot_bar),
/* harmony export */   pl_plot_easy: () => (/* binding */ pl_plot_easy),
/* harmony export */   pl_plot_scatter: () => (/* binding */ pl_plot_scatter),
/* harmony export */   pl_plot_xy: () => (/* binding */ pl_plot_xy),
/* harmony export */   pl_savefig: () => (/* binding */ pl_savefig),
/* harmony export */   pl_show: () => (/* binding */ pl_show),
/* harmony export */   pl_subplot: () => (/* binding */ pl_subplot),
/* harmony export */   pl_text: () => (/* binding */ pl_text),
/* harmony export */   pl_ticks: () => (/* binding */ pl_ticks),
/* harmony export */   pl_title: () => (/* binding */ pl_title),
/* harmony export */   plot_axes: () => (/* binding */ plot_axes),
/* harmony export */   plot_bar: () => (/* binding */ plot_bar),
/* harmony export */   plot_cla: () => (/* binding */ plot_cla),
/* harmony export */   plot_hist: () => (/* binding */ plot_hist),
/* harmony export */   plot_label: () => (/* binding */ plot_label),
/* harmony export */   plot_legend: () => (/* binding */ plot_legend),
/* harmony export */   plot_pie: () => (/* binding */ plot_pie),
/* harmony export */   plot_plot: () => (/* binding */ plot_plot),
/* harmony export */   plot_plot_bar: () => (/* binding */ plot_plot_bar),
/* harmony export */   plot_plot_easy: () => (/* binding */ plot_plot_easy),
/* harmony export */   plot_plot_scatter: () => (/* binding */ plot_plot_scatter),
/* harmony export */   plot_plot_xy: () => (/* binding */ plot_plot_xy),
/* harmony export */   plot_savefig: () => (/* binding */ plot_savefig),
/* harmony export */   plot_show: () => (/* binding */ plot_show),
/* harmony export */   plot_subplot: () => (/* binding */ plot_subplot),
/* harmony export */   plot_text: () => (/* binding */ plot_text),
/* harmony export */   plot_ticks: () => (/* binding */ plot_ticks),
/* harmony export */   plot_title: () => (/* binding */ plot_title),
/* harmony export */   py_sum: () => (/* binding */ py_sum),
/* harmony export */   pylab_imshow: () => (/* binding */ pylab_imshow),
/* harmony export */   series_create: () => (/* binding */ series_create),
/* harmony export */   series_create_from_index: () => (/* binding */ series_create_from_index),
/* harmony export */   series_create_from_text: () => (/* binding */ series_create_from_text),
/* harmony export */   series_get_num: () => (/* binding */ series_get_num),
/* harmony export */   series_index_value: () => (/* binding */ series_index_value)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const series_create = function (_, generator) {
    generator.definitions_.import_pandas = "import pandas";
    var varName1 = generator.valueToCode(this, 'SER', generator.ORDER_ASSIGNMENT) || '0';
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var code = varName + ' = ' + 'pandas.Series(' + varName1 + ')\n';
    return code;
}

const series_create_from_index = function (_, generator) {
    generator.definitions_.import_pandas = "import pandas";
    var varName1 = generator.valueToCode(this, 'SER', generator.ORDER_ASSIGNMENT) || '0';
    var varName2 = generator.valueToCode(this, 'INDEX', generator.ORDER_ATOMIC) || '\'\'';
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var code = varName + ' = ' + 'pandas.Series(' + varName1 + ',' + 'index=' + varName2 + ')\n';
    return code;
}

const dataframe_create = function (_, generator) {
    generator.definitions_.import_pandas = "import pandas";
    var varName1 = generator.valueToCode(this, 'SER', generator.ORDER_ASSIGNMENT) || '0';
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var code = varName + ' = ' + 'pandas.DataFrame(' + varName1 + ')\n';
    return code;
}

const dataframe_create_from_index = function (_, generator) {
    generator.definitions_.import_pandas = "import pandas";
    var varName1 = generator.valueToCode(this, 'SER', generator.ORDER_ASSIGNMENT) || '0';
    var varName2 = generator.valueToCode(this, 'INDEX_COLUMN', generator.ORDER_ATOMIC) || '\'\'';
    var varName3 = generator.valueToCode(this, 'INDEX_RAW', generator.ORDER_ATOMIC) || '\'\'';
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var code = varName + ' = ' + 'pandas.DataFrame(' + varName1 + ',' + 'columns=' + varName2 + ',index=' + varName3 + ')\n';
    return code;
}

const dataframe_create_from_one_index = function (_, generator) {
    generator.definitions_.import_pandas = "import pandas";
    var name = this.getFieldValue('COLUMN_RAW');
    var varName1 = generator.valueToCode(this, 'SER', generator.ORDER_ASSIGNMENT) || '0';
    var varName2 = generator.valueToCode(this, 'INDEX', generator.ORDER_ATOMIC) || '\'\'';
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var code = varName + ' = ' + 'pandas.DataFrame(' + varName1 + ',' + name + '=' + varName2 + ')\n';
    return code;
}

const series_create_from_text = function (_, generator) {
    generator.definitions_.import_pandas = "import pandas";
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);

    var text = this.getFieldValue('TEXT');
    var code = varName + ' = ' + 'pandas.Series([' + text + '])\n';
    return code;
}

const series_index_value = function (_, generator) {
    generator.definitions_.import_pandas = "import pandas";
    var varName = generator.valueToCode(this, 'SERIES', generator.ORDER_ASSIGNMENT) || '0';
    var name = this.getFieldValue('INDEX_VALUE');
    var code = varName + '.' + name;
    return [code, generator.ORDER_ATOMIC];
}

const series_get_num = function (_, generator) {
    // Indexing into a list is the same as indexing into a string.
    var varName = generator.valueToCode(this, 'SER', generator.ORDER_ASSIGNMENT) || '0';
    var argument0 = generator.valueToCode(this, 'AT',
        generator.ORDER_ADDITIVE) || '1';

    var code = varName + '[' + argument0 + ']';
    return [code, generator.ORDER_ATOMIC];
}

const pl_show = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var code = 'pylab.show()\n';
    return code;
}

const pl_axes = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var code = 'pylab.axes(aspect=1)\n';
    return code;
}

const pl_plot_easy = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var varName = generator.valueToCode(this, 'SER', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'pylab.plot(' + varName + ")\n";
    return code;
}

const pl_plot = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var line = this.getFieldValue('LINE');
    var color = this.getFieldValue('COLOR');
    var dot = this.getFieldValue('DOT');
    var varName = generator.valueToCode(this, 'SER', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'pylab.plot(' + varName + ",'" + dot + line + color + "')\n";
    return code;
}

const pl_legend = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    generator.definitions_.import_matplotlib_font_manager = "import matplotlib.font_manager";
    var code = 'pylab.legend(' + 'prop=matplotlib.font_manager.FontProperties("' + "STSong" + '")' + ')\n';
    return code;
}

const pl_title = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var a = generator.valueToCode(this, 'TITLE', generator.ORDER_ATOMIC);
    var code = 'pylab.title(' + a + ', fontproperties = "' + "STSong" + '")\n';
    return code;
}

const pl_label = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var direction = this.getFieldValue('DIR');
    var a = generator.valueToCode(this, 'LABEL', generator.ORDER_ATOMIC);
    var code = 'pylab.' + direction + 'label(' + a + ', fontproperties = "' + "STSong" + '")\n';
    return code;
}

const array_create = function (_, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var from = generator.valueToCode(this, "FROM", generator.ORDER_NONE) || "0";
    var end = generator.valueToCode(this, "TO", generator.ORDER_NONE) || "0";
    var step = generator.valueToCode(this, "STEP", generator.ORDER_NONE) || "1";
    var code = "numpy.arange(" + from + ", " + end + ", " + step + ")";
    return [code, generator.ORDER_ATOMIC];
}

const pl_plot_bar = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var direction = this.getFieldValue('DIR');
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var code = 'pylab.' + direction + '(' + a + ',' + b + ")\n";
    return code;
}

const pl_plot_scatter = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var s = generator.valueToCode(this, 'S', generator.ORDER_ATOMIC) || '\'\'';
    var color = this.getFieldValue('COLOR');
    var dot = this.getFieldValue('DOT');
    var tag = generator.valueToCode(this, 'TAG', generator.ORDER_ATOMIC) || '\'\'';
    var code = 'pylab.scatter(' + a + ',' + b + ",s=" + s + ",c='" + color + "',marker='" + dot + "',label=" + tag + ")\n";
    return code;
}

const pl_plot_xy = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var line = this.getFieldValue('LINE');
    var color = this.getFieldValue('COLOR');
    var dot = this.getFieldValue('DOT');
    var tag = generator.valueToCode(this, 'TAG', generator.ORDER_ATOMIC) || '\'\'';
    var code = 'pylab.plot(' + a + ',' + b + ",'" + dot + line + color + "'" + ',label=' + tag + ")\n";
    return code;
}

const pl_bar = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var tag = generator.valueToCode(this, 'TAG', generator.ORDER_ATOMIC) || '\'\'';
    var width = generator.valueToCode(this, 'WIDTH', generator.ORDER_RELATIONAL) || '0';
    var color = this.getFieldValue('COLOR')
    var align = this.getFieldValue('ALIGN');
    var code = 'pylab.bar(' + a + ',' + b + ',align="' + align + '",color="' + color + '",width=' + width + ',label=' + tag + ")\n";
    return code;
}

const pl_pie = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var explode = generator.valueToCode(this, 'EXPLODE', generator.ORDER_ATOMIC) || '\'\'';
    var shadow = this.getFieldValue('SHADOW');
    var autopct = this.getFieldValue('autopct');
    if (autopct != 'None') { autopct = "'" + autopct + "'" }
    var code = 'pylab.pie(' + a + ',explode=' + explode + ',labels=' + b + ',autopct=' + autopct + ',shadow=' + shadow + ")\n";
    return code;
}

const pl_hist = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var code = 'pylab.hist(' + a + ',' + b + ")\n";
    return code;
}

const pl_ticks = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var direction = this.getFieldValue('DIR');
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var code = 'pylab.' + direction + 'ticks(' + a + ',' + b + ",fontproperties = '" + "STSong" + "')\n";
    return code;
}

const numpy_trig = function (_, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var argument0 = generator.valueToCode(this, 'NUM', generator.ORDER_NONE) || '0';
    var operator = this.getFieldValue('OP');
    var code = "";

    code = "numpy." + operator + '(' + argument0 + ')';
    return [code, generator.ORDER_ATOMIC];
}

const pl_subplot = function (_, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var from = generator.valueToCode(this, "VET", generator.ORDER_NONE) || "0";
    var end = generator.valueToCode(this, "HOR", generator.ORDER_NONE) || "0";
    var step = generator.valueToCode(this, "NUM", generator.ORDER_NONE) || "0";
    var code = "pylab.subplot(" + from + ", " + end + ", " + step + ")\n";
    return code
}

const pandas_readcsv = function (_, generator) {
    // For each loop.
    generator.definitions_.import_pandas = "import pandas";
    var fn = generator.valueToCode(this, 'FILENAME', generator.ORDER_ATOMIC);
    var mode = this.getFieldValue('MODE');
    var code = 'pandas.read_csv(' + fn + ', header=' + mode + ')';
    return [code, generator.ORDER_ATOMIC];
}

const dataframe_get = function (_, generator) {
    var mode = this.getFieldValue('MODE');
    var varName = generator.valueToCode(this, 'DICT', generator.ORDER_ASSIGNMENT) || '0';
    var text = generator.valueToCode(this, 'KEY', generator.ORDER_ASSIGNMENT);
    if (mode == "column") {
        var code = varName + "[" + text + "]";
    }
    else if (mode == 'raw') {
        var code = varName + ".loc[" + text + "]";
    }
    return [code, generator.ORDER_ATOMIC];
}

const pl_savefig = function (_, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = "pylab.savefig(" + file + ")\n";
    return code;
}

const pl_text = function (_, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var from = generator.valueToCode(this, "VET", generator.ORDER_NONE) || "0";
    var end = generator.valueToCode(this, "HOR", generator.ORDER_NONE) || "0";
    var step = generator.valueToCode(this, "NUM", generator.ORDER_NONE) || "0";
    var halign = this.getFieldValue('HALIGN');
    var valign = this.getFieldValue('VALIGN');
    var fontnum = generator.valueToCode(this, 'FONTNUM', generator.ORDER_ASSIGNMENT) || '0';
    var code = "pylab.text(" + from + ", " + end + ", " + step + ", ha='" + halign + "', va='" + valign + "', fontsize=" + fontnum + ")\n";
    return code
}

const array_toarray = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0';
    generator.definitions_['import_numpy'] = 'import numpy';
    var code = 'numpy.array(' + str + ')';
    return [code, generator.ORDER_ATOMIC];
}

const plot_show = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var code = 'plt.show()\n';
    return code;
}

const plot_axes = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var code = 'plt.axes(aspect=1)\n';
    return code;
}

const plot_plot_easy = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var varName = generator.valueToCode(this, 'SER', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'plt.plot(' + varName + ")\n";
    return code;
}

const plot_plot = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var line = this.getFieldValue('LINE');
    var color = this.getFieldValue('COLOR');
    var dot = this.getFieldValue('DOT');
    var varName = generator.valueToCode(this, 'SER', generator.ORDER_ASSIGNMENT) || '0';
    var code = 'plt.plot(' + varName + ", '" + dot + line + color + "')\n";
    return code;
}

const plot_legend = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    generator.definitions_.import_matplotlib_font_manager = "import matplotlib.font_manager";
    var code = 'plt.legend(' + 'prop=matplotlib.font_manager.FontProperties("' + "STSong" + '")' + ')\n';
    return code;
}

const plot_title = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var a = generator.valueToCode(this, 'TITLE', generator.ORDER_ATOMIC);
    var code = 'plt.title(' + a + ', fontproperties="' + "STSong" + '")\n';
    return code;
}

const plot_label = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var direction = this.getFieldValue('DIR');
    var a = generator.valueToCode(this, 'LABEL', generator.ORDER_ATOMIC);
    var code = 'plt.' + direction + 'label(' + a + ', fontproperties="' + "STSong" + '")\n';
    return code;
}

const plot_plot_bar = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var direction = this.getFieldValue('DIR');
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var code = 'plt.' + direction + '(' + a + ', ' + b + ")\n";
    return code;
}

const plot_plot_scatter = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var s = generator.valueToCode(this, 'S', generator.ORDER_ATOMIC) || '\'\'';
    var color = this.getFieldValue('COLOR');
    var dot = this.getFieldValue('DOT');
    var tag = generator.valueToCode(this, 'TAG', generator.ORDER_ATOMIC) || '\'\'';
    var code = 'plt.scatter(' + a + ', ' + b + ", s=" + s + ", c='" + color + "', marker='" + dot + "', label=" + tag + ")\n";
    return code;
}

const plot_plot_xy = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var line = this.getFieldValue('LINE');
    var color = this.getFieldValue('COLOR');
    var dot = this.getFieldValue('DOT');
    var tag = generator.valueToCode(this, 'TAG', generator.ORDER_ATOMIC) || '\'\'';
    var code = 'plt.plot(' + a + ', ' + b + ", '" + dot + line + color + "'" + ', label=' + tag + ")\n";
    return code;
}

const plot_bar = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var tag = generator.valueToCode(this, 'TAG', generator.ORDER_ATOMIC) || '\'\'';
    var width = generator.valueToCode(this, 'WIDTH', generator.ORDER_RELATIONAL) || '0';
    var color = this.getFieldValue('COLOR')
    var align = this.getFieldValue('ALIGN');
    var code = 'plt.bar(' + a + ', ' + b + ', align="' + align + '", color="' + color + '", width=' + width + ', label=' + tag + ")\n";
    return code;
}

const plot_pie = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var explode = generator.valueToCode(this, 'EXPLODE', generator.ORDER_ATOMIC) || '\'\'';
    var shadow = this.getFieldValue('SHADOW');
    var autopct = this.getFieldValue('autopct');
    if (autopct != 'None') { autopct = "'" + autopct + "'" }
    var code = 'plt.pie(' + a + ', explode=' + explode + ', labels=' + b + ', autopct=' + autopct + ', shadow=' + shadow + ")\n";
    return code;
}

const plot_hist = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var code = 'plt.hist(' + a + ', ' + b + ")\n";
    return code;
}

const plot_ticks = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var direction = this.getFieldValue('DIR');
    var a = generator.valueToCode(this, 'A', generator.ORDER_ATOMIC) || '\'\'';
    var b = generator.valueToCode(this, 'B', generator.ORDER_ATOMIC) || '\'\'';
    var code = 'plt.' + direction + 'ticks(' + a + ', ' + b + ", fontproperties = '" + "STSong" + "')\n";
    return code;
}

const plot_subplot = function (_, generator) {
    generator.definitions_.import_numpy = "import numpy";
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var from = generator.valueToCode(this, "VET", generator.ORDER_NONE) || "0";
    var end = generator.valueToCode(this, "HOR", generator.ORDER_NONE) || "0";
    var step = generator.valueToCode(this, "NUM", generator.ORDER_NONE) || "0";
    var code = "plt.subplot(" + from + ", " + end + ", " + step + ")\n";
    return code
}

const plot_savefig = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var code = "plt.savefig('1.png')\n";
    return code;
}

const plot_text = function (_, generator) {
    generator.definitions_.import_numpy = "import numpy";
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var from = generator.valueToCode(this, "VET", generator.ORDER_NONE) || "0";
    var end = generator.valueToCode(this, "HOR", generator.ORDER_NONE) || "0";
    var step = generator.valueToCode(this, "NUM", generator.ORDER_NONE) || "0";
    var halign = this.getFieldValue('HALIGN');
    var valign = this.getFieldValue('VALIGN');
    var fontnum = generator.valueToCode(this, 'FONTNUM', generator.ORDER_ASSIGNMENT) || '0';
    var code = "plt.text(" + from + ", " + end + ", " + step + ", ha='" + halign + "', va='" + valign + "', fontsize=" + fontnum + ")\n";
    return code
}

const numpy_shape = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var code = 'numpy.shape(' + array + ')';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_reshape = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var dimensions = generator.valueToCode(block, 'DIMENSIONS', generator.ORDER_ATOMIC) || '(1, -1)';
    var code = 'numpy.reshape(' + array + ', ' + dimensions + ')';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_astype = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var dtype = block.getFieldValue('TYPE');
    var code = array + '.astype(' + dtype + ')';
    return [code, generator.ORDER_ATOMIC];
}

const pylab_imshow = function (block, generator) {
    generator.definitions_.import_pylab = "import pylab";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var colormap = block.getFieldValue('COLORMAP') || 'gray';
    var code = 'pylab.imshow(' + array + ', cmap="' + colormap + '")\n';
    return code;
}

const numpy_mean_digit = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var X = generator.valueToCode(block, 'X', generator.ORDER_ATOMIC) || '[]';
    var y = generator.valueToCode(block, 'Y', generator.ORDER_ATOMIC) || '[]';
    var digit = generator.valueToCode(block, 'DIGIT', generator.ORDER_ATOMIC) || '0';
    var code = 'numpy.mean(' + X + '[' + y + ' == ' + digit + '], axis=0)';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_argmin_template_match = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    generator.definitions_.import_cv2 = "import cv2";
    var image = generator.valueToCode(block, 'IMAGE', generator.ORDER_ATOMIC) || '[]';
    var templates = generator.valueToCode(block, 'TEMPLATES', generator.ORDER_ATOMIC) || '[]';
    var code = 'numpy.argmin([numpy.sum(cv2.absdiff(' + image + ', template)) for template in ' + templates + '])';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_mean = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var axis = block.getFieldValue('AXIS');
    if (axis === 'NONE') {
        var code = 'numpy.mean(' + array + ')';
    } else {
        var code = 'numpy.mean(' + array + ', axis=' + axis + ')';
    }
    return [code, generator.ORDER_ATOMIC];
}

const numpy_std = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var axis = block.getFieldValue('AXIS');
    if (axis === 'NONE') {
        var code = 'numpy.std(' + array + ')';
    } else {
        var code = 'numpy.std(' + array + ', axis=' + axis + ')';
    }
    return [code, generator.ORDER_ATOMIC];
}

const pandas_dropna = function (block, generator) {
    generator.definitions_.import_pandas = "import pandas";
    var df = generator.valueToCode(block, 'DF', generator.ORDER_ATOMIC) || 'df';

    var code = df + '.dropna()';

    return [code, generator.ORDER_MEMBER];
}

const pandas_drop_columns = function (block, generator) {
    generator.definitions_.import_pandas = "import pandas";
    var dataframe = generator.valueToCode(block, 'DATAFRAME', generator.ORDER_ATOMIC) || 'df';
    var columns = generator.valueToCode(block, 'COLUMNS', generator.ORDER_ATOMIC) || '[]';
    var axis = block.getFieldValue('AXIS') || '0';
    var code = dataframe + '.drop(columns=' + columns + ', axis=' + axis + ')';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_ones = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var num = generator.valueToCode(block, 'NUM', generator.ORDER_ATOMIC) || '1';
    var code = 'numpy.ones(' + num + ')';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_c_ = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array1 = generator.valueToCode(block, 'ARRAY1', generator.ORDER_ATOMIC) || '[]';
    var array2 = generator.valueToCode(block, 'ARRAY2', generator.ORDER_ATOMIC) || '[]';
    var code = 'numpy.c_[' + array1 + ', ' + array2 + ']';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_linalg_det = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    generator.definitions_.import_linalg = "import numpy.linalg";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var code = 'numpy.linalg.det(' + array + ')';
    return [code, generator.ORDER_ATOMIC];
}

const matrix_transpose = function (block, generator) {
    var matrix = generator.valueToCode(block, 'MATRIX', generator.ORDER_ATOMIC) || '[]';
    var code = matrix + '.T';
    return [code, generator.ORDER_ATOMIC];
}

const matrix_multiplication = function (block, generator) {
    var matrix1 = generator.valueToCode(block, 'MATRIX1', generator.ORDER_ATOMIC) || '[]';
    var matrix2 = generator.valueToCode(block, 'MATRIX2', generator.ORDER_ATOMIC) || '[]';
    var code = matrix1 + ' @ ' + matrix2;
    return [code, generator.ORDER_ATOMIC];
}

const numpy_linalg_inv = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    generator.definitions_.import_linalg = "import numpy.linalg";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var code = 'numpy.linalg.inv(' + array + ')';
    return [code, generator.ORDER_ATOMIC];
}

const dataframe_median = function (block, generator) {
    var dataframe = generator.valueToCode(block, 'DATAFRAME', generator.ORDER_ATOMIC) || 'df';
    var code = dataframe + '.median()';
    return [code, generator.ORDER_ATOMIC];
}

const dataframe_fillna = function (block, generator) {
    var dataframe = generator.valueToCode(block, 'DATAFRAME', generator.ORDER_ATOMIC) || 'df';
    var value = generator.valueToCode(block, 'VALUE', generator.ORDER_ATOMIC) || '0';
    var inplace = block.getFieldValue('INPLACE') || 'False';
    var code = dataframe + '.fillna(value=' + value + ', inplace=' + inplace + ')\n';
    return code;
}

const dataframe_info = function (block, generator) {
    var dataframe = generator.valueToCode(block, 'DATAFRAME', generator.ORDER_ATOMIC) || 'df';
    var code = dataframe + '.info()';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_min = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var axis = block.getFieldValue('AXIS');
    var code = (axis === 'None') ? 'numpy.min(' + array + ')' : 'numpy.min(' + array + ', axis=' + axis + ')';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_max = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var axis = block.getFieldValue('AXIS');
    var code = (axis === 'None') ? 'numpy.max(' + array + ')' : 'numpy.max(' + array + ', axis=' + axis + ')';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_size = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var code = array + '.size';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_dot = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array1 = generator.valueToCode(block, 'ARRAY1', generator.ORDER_ATOMIC) || '[]';
    var array2 = generator.valueToCode(block, 'ARRAY2', generator.ORDER_ATOMIC) || '[]';
    var code = 'numpy.dot(' + array1 + ', ' + array2 + ')';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_square = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var code = 'numpy.square(' + array + ')';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_sum = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var code = 'numpy.sum(' + array + ')';
    return [code, generator.ORDER_ATOMIC];
}

const numpy_random_random = function (block, generator) {
    generator.definitions_.import_numpy = "import numpy";
    var size = generator.valueToCode(block, 'SIZE', generator.ORDER_ATOMIC) || '1';
    var code = 'numpy.random.random(' + size + ')';
    return [code, generator.ORDER_ATOMIC];
}

const py_sum = function (block, generator) {
    var array = generator.valueToCode(block, 'ARRAY', generator.ORDER_ATOMIC) || '[]';
    var code = 'sum(' + array + ')';
    return [code, generator.ORDER_ATOMIC];
}

const dataframe_sort_values = function (block, generator) {
    const dict = generator.valueToCode(block, 'DICT', generator.ORDER_ATOMIC) || 'df';
    const key = generator.valueToCode(block, 'KEY', generator.ORDER_ATOMIC) || '\'tag\'';
    const ascending = block.getFieldValue('AS_CENDING');
    const code = `${dict}.sort_values(by=${key}, ascending=${ascending})`;
    return [code, generator.ORDER_ATOMIC];
}

const dataframe_head_tail = function (block, generator) {
    const dict = generator.valueToCode(block, 'DICT', generator.ORDER_ATOMIC) || 'df';
    const lines = generator.valueToCode(block, 'LINES', generator.ORDER_ATOMIC) || '1';
    const type = block.getFieldValue('TYPE');
    const code = `${dict}.${type}(${lines})`;
    return [code, generator.ORDER_ATOMIC];
}

const dataframe_select = function (block, generator) {
    const dict = generator.valueToCode(block, 'DICT', generator.ORDER_ATOMIC) || 'df';
    const key = generator.valueToCode(block, 'KEY', generator.ORDER_ATOMIC) || 'df[\'tag\'] > 1';
    const code = `${dict}[${key}]`;
    return [code, generator.ORDER_ATOMIC];
}

const dataframe_groupby = function (block, generator) {
    const dict = generator.valueToCode(block, 'DICT', generator.ORDER_ATOMIC) || 'df';
    const key = generator.valueToCode(block, 'KEY', generator.ORDER_ATOMIC) || '\'tag\'';
    const code = `${dict}.groupby(by=${key})`;
    return [code, generator.ORDER_ATOMIC];
}

const dataframe_aggregate_func = function (block, generator) {
    const dict = generator.valueToCode(block, 'DICT', generator.ORDER_ATOMIC) || 'df';
    const type = block.getFieldValue('TYPE');
    const code = `${dict}.${type}()`;
    return [code, generator.ORDER_ATOMIC];
}

const plot_cla = function (_, generator) {
    generator.definitions_.import_matplotlib_pyplot = 'import matplotlib.pyplot as plt';
    var code = 'plt.cla()\n';
    return code;
}

/***/ }),

/***/ "../python_mixpy/generators/datastructure.js":
/*!***************************************************!*\
  !*** ../python_mixpy/generators/datastructure.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ds_add_node_by_attr: () => (/* binding */ ds_add_node_by_attr),
/* harmony export */   ds_add_node_by_name: () => (/* binding */ ds_add_node_by_name),
/* harmony export */   ds_create_linkedlist: () => (/* binding */ ds_create_linkedlist),
/* harmony export */   ds_create_node: () => (/* binding */ ds_create_node),
/* harmony export */   ds_del_node_by_attr: () => (/* binding */ ds_del_node_by_attr),
/* harmony export */   ds_del_node_by_name: () => (/* binding */ ds_del_node_by_name),
/* harmony export */   ds_get_node_attr: () => (/* binding */ ds_get_node_attr),
/* harmony export */   ds_reverse_linkedlist: () => (/* binding */ ds_reverse_linkedlist),
/* harmony export */   ds_set_node_attr: () => (/* binding */ ds_set_node_attr)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const ds_create_linkedlist = function (_, generator) {
    // Create a list with any number of elements of any type.
    //var dropdown_type = this.getFieldValue('TYPE');
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var typeName = generator.variableDB_.getName(this.getFieldValue('TYPE'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    //var size=window.parseFloat(this.getFieldValue('SIZE'));
    var code = 'class ' + typeName + ":\n";
    code += '    def __init__(self):\n';
    var attr = new Array(this.itemCount_);
    var default_value = '0';
    for (var n = 0; n < this.itemCount_; n++) {
        var keyName = this.getFieldValue('KEY' + n);
        attr[n] = '        self.' + keyName + " = " + (generator.valueToCode(this, 'ADD' + n, generator.ORDER_NONE) || default_value);
    }
    code += attr.join('\n') + '\n';
    code += '        self.next = None\n';
    code += varName + ' = ' + typeName + '()\n'
    return code;
}

const ds_create_node = function (_, generator) {
    var varName = generator.valueToCode(this, 'NODE', generator.ORDER_ASSIGNMENT) || '0';
    var typeName = generator.variableDB_.getName(this.getFieldValue('TYPE'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    //var size=window.parseFloat(this.getFieldValue('SIZE'));

    var code = varName + ' = ' + typeName + '()\n';
    return code;
}

const ds_get_node_attr = function (_, generator) {
    var varName = generator.valueToCode(this, 'NODE', generator.ORDER_ASSIGNMENT) || '0';
    var typeName = generator.variableDB_.getName(this.getFieldValue('TYPE'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var code = varName + '.' + typeName;
    return [code, generator.ORDER_ATOMIC];
}

const ds_set_node_attr = function (_, generator) {
    var varName = generator.valueToCode(this, 'NODE', generator.ORDER_ASSIGNMENT) || '0';
    var typeName = generator.variableDB_.getName(this.getFieldValue('TYPE'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var argument = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.' + typeName + ' = ' + argument + '\n';
    return code;
}

const ds_add_node_by_name = function (_, generator) {
    var varName = generator.valueToCode(this, 'NODE', generator.ORDER_ASSIGNMENT) || '0';
    var varName2 = generator.valueToCode(this, 'NODE2', generator.ORDER_ASSIGNMENT) || '0';
    var varName3 = generator.valueToCode(this, 'NODE3', generator.ORDER_ASSIGNMENT) || '0';
    var direction = this.getFieldValue('DIR');
    if (direction == 'after') {
        var code = 'now = ' + varName + '\n';
        code += 'while now != ' + varName2 + ' and now != None:\n';
        code += '    now = now.next\n';
        code += 'if now != None:\n'
        code += '    ' + varName3 + '.next = now.next\n';
        code += '    ' + 'now.next = ' + varName3 + '\n';
        code += '    print("插入节点成功")\n';
        code += 'else:\n'
        code += '    print("插入节点失败，未找到指定名称的节点")\n';
    }
    if (direction == 'before') {
        var code = 'if ' + varName + ' == ' + varName2 + ':\n';
        code += '    ' + varName3 + '.next = ' + varName + '\n';
        code += 'else:\n'
        code += '    now = ' + varName + '\n';
        code += '    while now.next != ' + varName2 + " and now.next != None:\n";
        code += '        now = now.next\n';
        code += '    if now != None:\n'
        code += '        ' + varName3 + '.next = now.next\n';
        code += '        now.next = ' + varName3 + '\n';
        code += '        print("插入节点成功")\n';
        code += '    else:\n'
        code += '        print("插入节点失败，未找到指定名称的节点")\n';
    }
    return code;
}

const ds_add_node_by_attr = function (_, generator) {
    var varName = generator.valueToCode(this, 'NODE', generator.ORDER_ASSIGNMENT) || '0';
    var varName2 = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';
    var varName3 = generator.valueToCode(this, 'NODE3', generator.ORDER_ASSIGNMENT) || '0';
    var typeName = generator.variableDB_.getName(this.getFieldValue('TYPE'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var direction = this.getFieldValue('DIR');
    if (direction == 'after') {
        var code = 'now = ' + varName + '\n';
        code += 'while now.' + typeName + ' != ' + varName2 + ' and now != None:\n';
        code += '    now = now.next\n';
        code += 'if now != None:\n'
        code += '    ' + varName3 + '.next = now.next\n';
        code += '    ' + 'now.next = ' + varName3 + '\n';
        code += '    print("插入节点成功")\n';
        code += 'else:\n'
        code += '    print("插入节点失败，未找到指定的节点")\n';
    }
    if (direction == 'before') {
        var code = 'if ' + varName + '.' + typeName + ' == ' + varName2 + ':\n';
        code += '    ' + varName3 + '.next = ' + varName + '\n';
        code += 'else:\n'
        code += '    now = ' + varName + '\n';
        code += '    while now.next.' + typeName + ' != ' + varName2 + "and now.next != None:\n";
        code += '        now = now.next\n';
        code += '    if now != None:\n'
        code += '        ' + varName3 + '.next = now.next\n';
        code += '        now.next = ' + varName3 + '\n';
        code += '        print("插入节点成功")\n';
        code += '    else:\n'
        code += '        print("插入节点失败，未找到指定的节点")\n';
    }
    return code;
}

const ds_del_node_by_name = function (_, generator) {
    var varName = generator.valueToCode(this, 'NODE', generator.ORDER_ASSIGNMENT) || '0';
    var varName2 = generator.valueToCode(this, 'NODE2', generator.ORDER_ASSIGNMENT) || '0';


    var code = 'if ' + varName + ' == ' + varName2 + ':\n';
    code += '    ' + varName + '.next = None\n';
    code += 'else:\n'
    code += '    now = ' + varName + '\n';
    code += '    while now.next != ' + varName2 + " and now.next != None:\n";
    code += '        now = now.next\n';
    code += '    if now != None:\n'
    code += '        now.next = now.next.next\n';
    code += '        print("删除节点成功")\n';
    code += '    else:\n'
    code += '        print("删除节点失败，未找到指定名称的节点")\n';

    return code;
}

const ds_del_node_by_attr = function (_, generator) {
    var varName = generator.valueToCode(this, 'NODE', generator.ORDER_ASSIGNMENT) || '0';
    var varName2 = generator.valueToCode(this, 'VAR', generator.ORDER_ASSIGNMENT) || '0';

    var typeName = generator.variableDB_.getName(this.getFieldValue('TYPE'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);

    var code = 'if ' + varName + '.' + typeName + ' == ' + varName2 + ':\n';
    code += '    ' + varName + '.next = None\n';
    code += 'else:\n'
    code += '    now = ' + varName + '\n';
    code += '    while now.next.' + typeName + ' != ' + varName2 + " and now.next != None:\n";
    code += '        now = now.next\n';
    code += '    if now != None:\n'
    code += '        now.next = now.next.next\n';
    code += '        print("删除节点成功")\n';
    code += '    else:\n'
    code += '        print("删除节点失败，未找到指定的节点")\n';

    return code;
}

const ds_reverse_linkedlist = function (_, generator) {
    var varName = generator.valueToCode(this, 'NODE', generator.ORDER_ASSIGNMENT) || '0';
    var varName2 = generator.valueToCode(this, 'NODE2', generator.ORDER_ASSIGNMENT) || '0';


    var code = 'ptr = ' + varName + '\n';
    code += 'before = None\n';
    code += 'while ptr != None:\n'
    code += '    last = before\n';
    code += '    before = ptr\n';
    code += '    ptr = ptr.next\n';
    code += '    before.next = last\n'
    code += varName2 + ' = before\n';
    return code;
}

/***/ }),

/***/ "../python_mixpy/generators/factory.js":
/*!*********************************************!*\
  !*** ../python_mixpy/generators/factory.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   factory_block: () => (/* binding */ factory_block),
/* harmony export */   factory_block_return: () => (/* binding */ factory_block_return),
/* harmony export */   factory_block_return_with_textarea: () => (/* binding */ factory_block_return_with_textarea),
/* harmony export */   factory_block_with_textarea: () => (/* binding */ factory_block_with_textarea),
/* harmony export */   factory_callMethod_noreturn: () => (/* binding */ factory_callMethod_noreturn),
/* harmony export */   factory_callMethod_return: () => (/* binding */ factory_callMethod_return),
/* harmony export */   factory_declare: () => (/* binding */ factory_declare),
/* harmony export */   factory_from_import: () => (/* binding */ factory_from_import),
/* harmony export */   factory_function_noreturn: () => (/* binding */ factory_function_noreturn),
/* harmony export */   factory_function_return: () => (/* binding */ factory_function_return),
/* harmony export */   factory_import: () => (/* binding */ factory_import)
/* harmony export */ });
const factory_from_import = function (_, generator) {
    var path = this.getFieldValue('path');
    var module = this.getFieldValue('module');
    generator.definitions_['import_' + path + '_' + module] = 'from ' + path + ' import ' + module;
    return '';
}

const factory_import = function (_, generator) {
    var module = this.getFieldValue('module');
    generator.definitions_['import_' + module] = 'import ' + module;
    return '';
}

const factory_function_noreturn = function (_, generator) {
    var NAME = this.getFieldValue('NAME');
    var code = new Array(this.itemCount_);
    for (var n = 0; n < this.itemCount_; n++) {
        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || '';
    }
    return NAME + '(' + code.join(', ') + ')\n';
}

const factory_function_return = function (_, generator) {
    var NAME = this.getFieldValue('NAME');
    var code = new Array(this.itemCount_);
    for (var n = 0; n < this.itemCount_; n++) {
        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || '';
    }
    return [NAME + '(' + code.join(', ') + ')', generator.ORDER_ATOMIC];
}

const factory_declare = function () {
    var TYPE = this.getFieldValue('TYPE');
    var NAME = this.getFieldValue('NAME');
    return NAME + ' = ' + TYPE + '()\n';
}

const factory_callMethod_noreturn = function (_, generator) {
    var NAME = this.getFieldValue('NAME');
    var METHOD = this.getFieldValue('METHOD');
    var code = new Array(this.itemCount_);
    for (var n = 0; n < this.itemCount_; n++) {
        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || '';
    }
    return NAME + '.' + METHOD + '(' + code.join(', ') + ')\n';
}

const factory_callMethod_return = function (_, generator) {
    var NAME = this.getFieldValue('NAME');
    var METHOD = this.getFieldValue('METHOD');
    var code = new Array(this.itemCount_);
    for (var n = 0; n < this.itemCount_; n++) {
        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || '';
    }
    return [NAME + '.' + METHOD + '(' + code.join(', ') + ')', generator.ORDER_ATOMIC];
}

const factory_block = function () {
    var VALUE = this.getFieldValue('VALUE');
    //if(!(VALUE.charAt(VALUE.length-1)==";")){
    //VALUE=VALUE+';';
    //}
    return VALUE + '\n';
}

const factory_block_return = function (_, generator) {
    var VALUE = this.getFieldValue('VALUE');
    return [VALUE, generator.ORDER_ATOMIC];
}

const factory_block_with_textarea = function () {
    var VALUE = this.getFieldValue('VALUE');
    //if(!(VALUE.charAt(VALUE.length-1)==";")){
    //VALUE=VALUE+';';
    //}
    return VALUE + '\n';
}

const factory_block_return_with_textarea = function (_, generator) {
    var VALUE = this.getFieldValue('VALUE');
    return [VALUE, generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python_mixpy/generators/hardware.js":
/*!**********************************************!*\
  !*** ../python_mixpy/generators/hardware.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hardware_arduino_analog_read: () => (/* binding */ hardware_arduino_analog_read),
/* harmony export */   hardware_arduino_analog_write: () => (/* binding */ hardware_arduino_analog_write),
/* harmony export */   hardware_arduino_digital_read: () => (/* binding */ hardware_arduino_digital_read),
/* harmony export */   hardware_arduino_digital_write: () => (/* binding */ hardware_arduino_digital_write),
/* harmony export */   hardware_arduino_start: () => (/* binding */ hardware_arduino_start),
/* harmony export */   inout_highlow: () => (/* binding */ inout_highlow)
/* harmony export */ });
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mixly */ "mixly");
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mixly__WEBPACK_IMPORTED_MODULE_0__);


const hardware_arduino_start = function (_, generator) {
    generator.definitions_['import_s4alib'] = 'import s4alib';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    // var code= v + '.start()\n';
    var code = v + ' = s4alib.s4a_start("' + mixly__WEBPACK_IMPORTED_MODULE_0__.JSFuncs.getCom() + '")\n';
    return code;
}

const inout_highlow = function (_, generator) {
    // Boolean values HIGH and LOW.
    var code = (this.getFieldValue('BOOL') == 'HIGH') ? '1' : '0';
    return [code, generator.ORDER_ATOMIC];
}

const hardware_arduino_digital_write = function (_, generator) {
    generator.definitions_['import_s4alib'] = 'import s4alib';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var dropdown_pin = generator.valueToCode(this, 'PIN', generator.ORDER_ATOMIC);
    var dropdown_stat = generator.valueToCode(this, 'STAT', generator.ORDER_ATOMIC);
    var code = "";
    code += '' + v + '.digital_write(' + dropdown_pin + ',' + dropdown_stat + ')\n'
    return code;
}

const hardware_arduino_digital_read = function (_, generator) {
    generator.definitions_['import_s4alib'] = 'import s4alib';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var dropdown_pin = generator.valueToCode(this, 'PIN', generator.ORDER_ATOMIC);
    var code = "";
    code = '' + v + '.digital_read(' + dropdown_pin + ')';
    return [code, generator.ORDER_ATOMIC];
}

const hardware_arduino_analog_read = function (_, generator) {
    generator.definitions_['import_s4alib'] = 'import s4alib';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var dropdown_pin = generator.valueToCode(this, 'PIN', generator.ORDER_ATOMIC);
    var code = "";
    code = '' + v + '.analog_read(' + dropdown_pin + ')';
    return [code, generator.ORDER_ATOMIC];
}

const hardware_arduino_analog_write = function (_, generator) {
    generator.definitions_['import_s4alib'] = 'import s4alib';
    var v = generator.valueToCode(this, 'SUB', generator.ORDER_ATOMIC);
    var dropdown_pin = generator.valueToCode(this, 'PIN', generator.ORDER_ATOMIC);
    var value_num = generator.valueToCode(this, 'NUM', generator.ORDER_ATOMIC);
    var code = "";
    code += '' + v + '.analog_write(' + dropdown_pin + ',' + value_num + ')\n'
    return code;
}


/***/ }),

/***/ "../python_mixpy/generators/inout.js":
/*!*******************************************!*\
  !*** ../python_mixpy/generators/inout.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inout_input: () => (/* binding */ inout_input),
/* harmony export */   inout_print: () => (/* binding */ inout_print),
/* harmony export */   inout_print_end: () => (/* binding */ inout_print_end),
/* harmony export */   inout_print_inline: () => (/* binding */ inout_print_inline),
/* harmony export */   inout_print_many: () => (/* binding */ inout_print_many),
/* harmony export */   inout_type_input: () => (/* binding */ inout_type_input),
/* harmony export */   pyinout_type_input: () => (/* binding */ pyinout_type_input)
/* harmony export */ });
const inout_input = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    return ['input(' + str + ')', generator.ORDER_ATOMIC];
}

const inout_print = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var code = "print(" + str + ")\n";
    return code;
}

const inout_print_inline = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var code = "print(" + str + ',end ="")\n';
    return code;
}

const inout_print_end = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var end = generator.valueToCode(this, 'END', generator.ORDER_ATOMIC) || '""';
    var code = "print(" + str + ',end =' + end + ')\n';
    return code;
}

const inout_type_input = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var type = this.getFieldValue('DIR');
    if (type == 'str') { var code = 'input(' + str + ')' }
    else if (type == 'int') { var code = 'int(input(' + str + '))' }
    else if (type == 'float') { var code = 'float(input(' + str + '))' }
    //var code=varname+"." + type + "("   + ')';
    return [code, generator.ORDER_ATOMIC];
}

const pyinout_type_input = function (_, generator) {
    var str = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""';
    var type = this.getFieldValue('DIR');
    generator.definitions_['import_pyinput'] = 'import pyinput';
    if (type == 'str') { var code = 'pyinput.input(' + str + ')' }
    else if (type == 'int') { var code = 'int(pyinput.input(' + str + '))' }
    else if (type == 'float') { var code = 'float(pyinput.input(' + str + '))' }
    //var code=varname+"." + type + "("   + ')';
    return [code, generator.ORDER_ATOMIC];
}

const inout_print_many = function (_, generator) {
    var code = new Array(this.itemCount_);
    var default_value = '0';
    for (var n = 0; n < this.itemCount_; n++) {
        code[n] = generator.valueToCode(this, 'ADD' + n,
            generator.ORDER_NONE) || default_value;
    }
    var code = 'print(' + code.join(', ') + ')\n';
    return code;
}

/***/ }),

/***/ "../python_mixpy/generators/iot.js":
/*!*****************************************!*\
  !*** ../python_mixpy/generators/iot.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IOT_EMQX_INIT_AND_CONNECT_BY_MIXLY_CODE: () => (/* binding */ IOT_EMQX_INIT_AND_CONNECT_BY_MIXLY_CODE),
/* harmony export */   IOT_EMQX_INIT_AND_CONNECT_BY_SHARE_CODE: () => (/* binding */ IOT_EMQX_INIT_AND_CONNECT_BY_SHARE_CODE),
/* harmony export */   IOT_EMQX_PING: () => (/* binding */ IOT_EMQX_PING),
/* harmony export */   IOT_FORMATTING: () => (/* binding */ IOT_FORMATTING),
/* harmony export */   IOT_FORMAT_STRING: () => (/* binding */ IOT_FORMAT_STRING),
/* harmony export */   IOT_MIXIO_NTP: () => (/* binding */ IOT_MIXIO_NTP),
/* harmony export */   IOT_MIXIO_PUBLISH: () => (/* binding */ IOT_MIXIO_PUBLISH),
/* harmony export */   IOT_MIXIO_SUBSCRIBE: () => (/* binding */ IOT_MIXIO_SUBSCRIBE),
/* harmony export */   IOT_MIXIO_UNSUBSCRIBE: () => (/* binding */ IOT_MIXIO_UNSUBSCRIBE),
/* harmony export */   iot_mixio_check: () => (/* binding */ iot_mixio_check),
/* harmony export */   iot_mixio_connect: () => (/* binding */ iot_mixio_connect),
/* harmony export */   iot_mixio_connect_only: () => (/* binding */ iot_mixio_connect_only),
/* harmony export */   iot_mixio_disconnect: () => (/* binding */ iot_mixio_disconnect),
/* harmony export */   iot_mixio_format_msg: () => (/* binding */ iot_mixio_format_msg),
/* harmony export */   iot_mixio_format_topic: () => (/* binding */ iot_mixio_format_topic),
/* harmony export */   iot_mixly_key: () => (/* binding */ iot_mixly_key),
/* harmony export */   iot_mixly_key_py: () => (/* binding */ iot_mixly_key_py)
/* harmony export */ });
const iot_mixio_connect = function (_, generator) {
    generator.definitions_['import_mixiot'] = "import mixiot";
    var server = generator.valueToCode(this, 'SERVER', generator.ORDER_ATOMIC);
    var username = generator.valueToCode(this, 'USERNAME', generator.ORDER_ATOMIC);
    var password = generator.valueToCode(this, 'PASSWORD', generator.ORDER_ATOMIC);
    var project = generator.valueToCode(this, 'PROJECT', generator.ORDER_ATOMIC);
    var timestamp = Math.round(new Date()).toString();
    //var subscribe = generator.valueToCode(this, 'SUB', generator.ORDER_ASSIGNMENT) || '0';
    var a = "f'python-mqtt-" + username.replace("'", "").replace("'", "") + timestamp.replace("'", "").replace("'", "") + "'";
    var code = 'mqtt_client = mixiot.MixIO(' + server + ', 1883 ,' + username + ', ' + password + ', ' + project + ', ' + a + ')\n';
    return code;
}

const IOT_MIXIO_PUBLISH = function (_, generator) {
    var topic = generator.valueToCode(this, 'TOPIC', generator.ORDER_ATOMIC);
    var msg = generator.valueToCode(this, 'MSG', generator.ORDER_ATOMIC);
    generator.definitions_['import_mixiot'] = "import mixiot";
    var code = 'mqtt_client.publish(' + topic + ', ' + msg + ')\n';
    return code;
}

const IOT_MIXIO_SUBSCRIBE = function (_, generator) {
    var topic = generator.valueToCode(this, 'TOPIC', generator.ORDER_ATOMIC);
    var method = generator.valueToCode(this, 'METHOD', generator.ORDER_ATOMIC);
    generator.definitions_['import_mixiot'] = "import mixiot";
    var code = 'mqtt_client.subscribe_and_set_callback(' + topic + ',' + method + ')\n';
    return code;
}

const IOT_MIXIO_UNSUBSCRIBE = function (_, generator) {
    var topic = generator.valueToCode(this, 'TOPIC', generator.ORDER_ATOMIC);
    generator.definitions_['import_mixiot'] = "import mixiot";
    var code = 'mqtt_client.unsubscribe(' + topic + ')\n';
    return code;
}

const iot_mixio_disconnect = function (_, generator) {
    generator.definitions_['import_mixiot'] = "import mixiot";
    var code = 'mqtt_client.disconnect()\n';
    return code;
}

const iot_mixio_connect_only = function (_, generator) {
    generator.definitions_['import_mixiot'] = "import mixiot";
    var code = 'mqtt_client.connect()\n';
    return code;
}

const iot_mixio_check = function (_, generator) {
    generator.definitions_['import_mixiot'] = "import mixiot";
    var code = 'mqtt_client.check_msg()\n';
    return code;
}

const iot_mixio_format_topic = function (_, generator) {
    var code = 'mqtt_client.decode("utf-8").split("/")[-1]';
    return [code, generator.ORDER_ATOMIC];
}

const iot_mixio_format_msg = function (_, generator) {
    var code = 'mqtt_client.decode("utf-8")';
    return [code, generator.ORDER_ATOMIC];
}

const IOT_FORMATTING = function (_, generator) {
    generator.definitions_['import_mixpy'] = "import mixpy";
    var v = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = 'mixpy.format_content(' + v + ', mqtt_client.client_id)';
    return [code, generator.ORDER_ATOMIC];
}

const IOT_FORMAT_STRING = function (_, generator) {
    generator.definitions_['import_mixpy'] = "import mixpy";
    var v = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = 'mixpy.format_str(' + v + ')';
    return [code, generator.ORDER_ATOMIC];
}

const IOT_EMQX_INIT_AND_CONNECT_BY_MIXLY_CODE = function (_, generator) {
    generator.definitions_['import_mixiot'] = "import mixiot";
    var server = generator.valueToCode(this, 'SERVER', generator.ORDER_ATOMIC);
    var share_code = generator.valueToCode(this, 'KEY', generator.ORDER_ATOMIC);
    var timestamp = Math.round(new Date()).toString();
    var a = "f'python-mqtt-" + share_code.replace("'", "").replace("'", "") + timestamp.replace("'", "").replace("'", "") + "'";
    var code = 'mqtt_client = mixiot.MixIO.from_mixly_key(' + server + ', 1883 ,' + share_code + ', ' + a + ')\n';
    return code;
}

const iot_mixly_key = function (_, generator) {
    var code = this.getFieldValue('VISITOR_ID');
    return [code, generator.ORDER_ATOMIC];
}

const iot_mixly_key_py = function (_, generator) {
    var code = this.getFieldValue('VISITOR_ID');
    return ["'" + code + "'", generator.ORDER_ATOMIC];
}

const IOT_EMQX_INIT_AND_CONNECT_BY_SHARE_CODE = function (_, generator) {
    generator.definitions_['import_mixiot'] = "import mixiot";
    var server = generator.valueToCode(this, 'SERVER', generator.ORDER_ATOMIC);
    var mixly_code = generator.valueToCode(this, 'KEY', generator.ORDER_ATOMIC);
    var timestamp = Math.round(new Date()).toString();
    var a = "f'python-mqtt-" + mixly_code.replace("'", "").replace("'", "") + timestamp.replace("'", "").replace("'", "") + "'";
    var code = 'mqtt_client = mixiot.MixIO.from_share_key(' + server + ', 1883 ,' + mixly_code + ', ' + a + ')\n';
    return code;
}

const IOT_EMQX_PING = function (_, generator) {
    generator.definitions_['import_mixiot'] = "import mixiot";
    var code = 'mqtt_client.pingSync()';
    return [code, generator.ORDER_ATOMIC];
}

const IOT_MIXIO_NTP = function (_, generator) {
    generator.definitions_['import_mixiot'] = "import mixiot";
    var addr = generator.valueToCode(this, 'addr', generator.ORDER_ATOMIC);
    var code = 'mixiot.ntp(' + addr + ')';
    return [code, generator.ORDER_ATOMIC];
}

/***/ }),

/***/ "../python_mixpy/generators/pins.js":
/*!******************************************!*\
  !*** ../python_mixpy/generators/pins.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pins_analog_read: () => (/* binding */ pins_analog_read),
/* harmony export */   pins_analog_write: () => (/* binding */ pins_analog_write),
/* harmony export */   pins_digital: () => (/* binding */ pins_digital),
/* harmony export */   pins_digital_read: () => (/* binding */ pins_digital_read),
/* harmony export */   pins_digital_write: () => (/* binding */ pins_digital_write)
/* harmony export */ });
const pins_digital = function (_, generator) {
    var code = this.getFieldValue('PIN');
    return [code, generator.ORDER_ATOMIC];
}

const pins_digital_write = pins_digital;
const pins_digital_read = pins_digital;
const pins_analog_write = pins_digital;
const pins_analog_read = pins_digital;

/***/ }),

/***/ "../python_mixpy/generators/serial.js":
/*!********************************************!*\
  !*** ../python_mixpy/generators/serial.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   serial_close: () => (/* binding */ serial_close),
/* harmony export */   serial_open: () => (/* binding */ serial_open),
/* harmony export */   serial_read_b: () => (/* binding */ serial_read_b),
/* harmony export */   serial_write: () => (/* binding */ serial_write)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mixly */ "mixly");
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mixly__WEBPACK_IMPORTED_MODULE_1__);



const serial_open = function (_, generator) {
    generator.definitions_['import_serial'] = 'import serial';
    var time = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0'
    var varName = generator.variableDB_.getName(this.getFieldValue('SER'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var bps = this.getFieldValue('BPS');
    // var code= v + '.start()\n';
    var code = varName + ' = serial.Serial("' + mixly__WEBPACK_IMPORTED_MODULE_1__.JSFuncs.getCom() + '", ' + bps + ', timeout=' + time + ')\n';
    return code;
}

const serial_write = function (_, generator) {
    generator.definitions_['import_serial'] = 'import serial';
    var ser = generator.valueToCode(this, 'SER', generator.ORDER_ADDITIVE) || 'ser';
    var str = (generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '""');
    // var code= v + '.start()\n';
    var code = ser + '.write(' + str + ')\n';
    return code;
}

const serial_read_b = function (_, generator) {
    generator.definitions_['import_serial'] = 'import serial';
    var ser = generator.valueToCode(this, 'SER', generator.ORDER_ADDITIVE) || 'ser';
    var len = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC) || '0'
    var code = ser + '.read(' + len + ')';
    return [code, generator.ORDER_ATOMIC];
}

const serial_close = function (_, generator) {
    generator.definitions_['import_serial'] = 'import serial';
    var ser = generator.valueToCode(this, 'SER', generator.ORDER_ADDITIVE) || 'ser';
    var code = ser + '.close()\n';
    return code;
}

/***/ }),

/***/ "../python_mixpy/generators/sklearn.js":
/*!*********************************************!*\
  !*** ../python_mixpy/generators/sklearn.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sklearn_DecisionTreeClassifier_Regressor: () => (/* binding */ sklearn_DecisionTreeClassifier_Regressor),
/* harmony export */   sklearn_GaussianNB: () => (/* binding */ sklearn_GaussianNB),
/* harmony export */   sklearn_KMeans: () => (/* binding */ sklearn_KMeans),
/* harmony export */   sklearn_KNeighborsClassifier_Regressor: () => (/* binding */ sklearn_KNeighborsClassifier_Regressor),
/* harmony export */   sklearn_LinearRegression: () => (/* binding */ sklearn_LinearRegression),
/* harmony export */   sklearn_RandomForestClassifier_Regressor: () => (/* binding */ sklearn_RandomForestClassifier_Regressor),
/* harmony export */   sklearn_Ridge: () => (/* binding */ sklearn_Ridge),
/* harmony export */   sklearn_cluster_centers_labels_inertia: () => (/* binding */ sklearn_cluster_centers_labels_inertia),
/* harmony export */   sklearn_coef_intercept: () => (/* binding */ sklearn_coef_intercept),
/* harmony export */   sklearn_data_target: () => (/* binding */ sklearn_data_target),
/* harmony export */   sklearn_fit: () => (/* binding */ sklearn_fit),
/* harmony export */   sklearn_fit_no_target: () => (/* binding */ sklearn_fit_no_target),
/* harmony export */   sklearn_load: () => (/* binding */ sklearn_load),
/* harmony export */   sklearn_make_blobs: () => (/* binding */ sklearn_make_blobs),
/* harmony export */   sklearn_make_classification: () => (/* binding */ sklearn_make_classification),
/* harmony export */   sklearn_make_regression: () => (/* binding */ sklearn_make_regression),
/* harmony export */   sklearn_predict: () => (/* binding */ sklearn_predict),
/* harmony export */   sklearn_save_load_model: () => (/* binding */ sklearn_save_load_model),
/* harmony export */   sklearn_score: () => (/* binding */ sklearn_score),
/* harmony export */   sklearn_score_no_target: () => (/* binding */ sklearn_score_no_target),
/* harmony export */   sklearn_train_test_split: () => (/* binding */ sklearn_train_test_split),
/* harmony export */   sklearn_train_test_split_no_target: () => (/* binding */ sklearn_train_test_split_no_target)
/* harmony export */ });
const sklearn_make_classification = function (_, generator) {
    var value_n_samples = generator.valueToCode(this, 'n_samples', generator.ORDER_ATOMIC) || '100';
    var value_n_features = generator.valueToCode(this, 'n_features', generator.ORDER_ATOMIC) || '20';
    var value_n_informative = generator.valueToCode(this, 'n_informative', generator.ORDER_ATOMIC) || '2';
    var value_n_redundant = generator.valueToCode(this, 'n_redundant', generator.ORDER_ATOMIC) || '2';
    var value_n_repeated = generator.valueToCode(this, 'n_repeated', generator.ORDER_ATOMIC) || '0';
    var value_n_classes = generator.valueToCode(this, 'n_classes', generator.ORDER_ATOMIC) || '2';
    var value_n_clusters_per_class = generator.valueToCode(this, 'n_clusters_per_class', generator.ORDER_ATOMIC) || '2';
    var value_random_state = generator.valueToCode(this, 'random_state', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_make_classification'] = 'from sklearn.datasets import make_classification';
    var code = 'make_classification(n_samples=' + value_n_samples + ',n_features=' + value_n_features + ',n_informative=' + value_n_informative + ',n_redundant=' + value_n_redundant + ',n_repeated=' + value_n_repeated + ',n_classes=' + value_n_classes + ',n_clusters_per_class=' + value_n_clusters_per_class + ',random_state=' + value_random_state + ')';
    return [code, generator.ORDER_ATOMIC];
}

// sklearn 生成回归样本
const sklearn_make_regression = function (_, generator) {
    var value_n_samples = generator.valueToCode(this, 'n_samples', generator.ORDER_ATOMIC) || '100';
    var value_n_features = generator.valueToCode(this, 'n_features', generator.ORDER_ATOMIC) || '100';
    var value_n_informative = generator.valueToCode(this, 'n_informative', generator.ORDER_ATOMIC) || '10';
    var value_n_targets = generator.valueToCode(this, 'n_targets', generator.ORDER_ATOMIC) || '1';
    var value_bias = generator.valueToCode(this, 'bias', generator.ORDER_ATOMIC) || '0.0';
    var value_noise = generator.valueToCode(this, 'noise', generator.ORDER_ATOMIC) || '0.0';
    var value_random_state = generator.valueToCode(this, 'random_state', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_make_regression'] = 'from sklearn.datasets import make_regression';
    var code = 'make_regression(n_samples=' + value_n_samples + ',n_features=' + value_n_features + ',n_informative=' + value_n_informative + ',n_targets=' + value_n_targets + ',bias=' + value_bias + ',noise=' + value_noise + ',random_state=' + value_random_state + ')';
    return [code, generator.ORDER_ATOMIC];
}

// sklearn 生成聚类样本
const sklearn_make_blobs = function (_, generator) {
    var value_n_samples = generator.valueToCode(this, 'n_samples', generator.ORDER_ATOMIC) || '100';
    var value_n_features = generator.valueToCode(this, 'n_features', generator.ORDER_ATOMIC) || '2';
    var value_centers = generator.valueToCode(this, 'centers', generator.ORDER_ATOMIC) || 'None';
    var value_cluster_std = generator.valueToCode(this, 'cluster_std', generator.ORDER_ATOMIC) || '1.0';
    var value_center_box = generator.valueToCode(this, 'center_box', generator.ORDER_ATOMIC) || '(-10.0,10.0)';
    var value_shuffle = generator.valueToCode(this, 'shuffle', generator.ORDER_ATOMIC) || 'True';
    var value_random_state = generator.valueToCode(this, 'random_state', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_make_blobs'] = 'from sklearn.datasets import make_blobs';
    var code = 'make_blobs(n_samples=' + value_n_samples + ',n_features=' + value_n_features + ',centers=' + value_centers + ',cluster_std=' + value_cluster_std + ',center_box=' + value_center_box + ',shuffle=' + value_shuffle + ',random_state=' + value_random_state + ')';
    return [code, generator.ORDER_ATOMIC];
}

// sklearn 加载数据集
const sklearn_load = function (_, generator) {
    var dropdown_type = this.getFieldValue('type');
    var text_name = this.getFieldValue('name');
    generator.definitions_['import_sklearn_datasets'] = 'from sklearn import datasets';
    var code = text_name + ' = datasets.' + dropdown_type + '()\n';
    return code;
}

// sklearn 获取特征值/标签值/标签/特征
const sklearn_data_target = function (_, generator) {
    var value_name = generator.valueToCode(this, 'name', generator.ORDER_ATOMIC) || 'iris';
    var dropdown_type = this.getFieldValue('type');
    var code = value_name + '.' + dropdown_type;
    return [code, generator.ORDER_ATOMIC];
}

// sklearn 数据集分割
const sklearn_train_test_split = function (_, generator) {
    var value_train_data = generator.valueToCode(this, 'train_data', generator.ORDER_ATOMIC) || 'iris_X';
    var value_train_target = generator.valueToCode(this, 'train_target', generator.ORDER_ATOMIC) || 'iris_y';
    var value_test_size = generator.valueToCode(this, 'test_size', generator.ORDER_ATOMIC) || '0.3';
    var value_rondom_state = generator.valueToCode(this, 'rondom_state', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_train_test_split'] = 'from sklearn.model_selection import train_test_split';
    if (value_train_target == 'None')
        var code = 'train_test_split(' + value_train_data + ',test_size = ' + value_test_size + ',random_state = ' + value_rondom_state + ')';
    else
        var code = 'train_test_split(' + value_train_data + ',' + value_train_target + ',test_size = ' + value_test_size + ',random_state = ' + value_rondom_state + ')';
    return [code, generator.ORDER_ATOMIC];
}

// sklearn 数据集分割-无标签值
const sklearn_train_test_split_no_target = function (_, generator) {
    var value_train_data = generator.valueToCode(this, 'train_data', generator.ORDER_ATOMIC) || 'iris_X';
    var value_test_size = generator.valueToCode(this, 'test_size', generator.ORDER_ATOMIC) || '0.3';
    var value_rondom_state = generator.valueToCode(this, 'rondom_state', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_train_test_split'] = 'from sklearn.model_selection import train_test_split';
    var code = 'train_test_split(' + value_train_data + ',test_size = ' + value_test_size + ',random_state = ' + value_rondom_state + ')';
    return [code, generator.ORDER_ATOMIC];
}

// sklearn 初始化线性回归
const sklearn_LinearRegression = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var value_fit_intercept = generator.valueToCode(this, 'fit_intercept', generator.ORDER_ATOMIC) || 'True';
    var value_normalize = generator.valueToCode(this, 'normalize', generator.ORDER_ATOMIC) || 'False';
    var value_n_jobs = generator.valueToCode(this, 'n_jobs', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_linear_model'] = 'from sklearn.linear_model import LinearRegression';
    var code = value_model_name + ' = LinearRegression(fit_intercept = ' + value_fit_intercept + ',normalize = ' + value_normalize + ',n_jobs = ' + value_n_jobs + ')\n';
    return code;
}

// sklearn 初始化岭回归
const sklearn_Ridge = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var value_alpha = generator.valueToCode(this, 'alpha', generator.ORDER_ATOMIC) || '1.0';
    var value_fit_intercept = generator.valueToCode(this, 'fit_intercept', generator.ORDER_ATOMIC) || 'True';
    var value_normalize = generator.valueToCode(this, 'normalize', generator.ORDER_ATOMIC) || 'False';
    var value_max_iter = generator.valueToCode(this, 'max_iter', generator.ORDER_ATOMIC) || '300';
    var value_random_state = generator.valueToCode(this, 'random_state', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_linear_model'] = 'from sklearn.linear_model import Ridge';
    var code = value_model_name + ' = Ridge(alpha = ' + value_alpha + ',fit_intercept = ' + value_fit_intercept + ',normalize = ' + value_normalize + ',max_iter = ' + value_max_iter + ',random_state = ' + value_random_state + ')\n';
    return code;
}

// sklearn 初始化决策树 分类/回归算法
const sklearn_DecisionTreeClassifier_Regressor = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var dropdown_type = this.getFieldValue('type');
    var value_max_depth = generator.valueToCode(this, 'max_depth', generator.ORDER_ATOMIC) || 'None';
    var value_random_state = generator.valueToCode(this, 'random_state', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_' + dropdown_type] = 'from sklearn.tree import ' + dropdown_type;
    var code = value_model_name + ' = ' + dropdown_type + '(max_depth = ' + value_max_depth + ',random_state = ' + value_random_state + ')\n';
    return code;
}

const sklearn_RandomForestClassifier_Regressor = function (_, generator) {
    var dropdown_type = this.getFieldValue('type');
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'Model';
    var value_n_estimators = generator.valueToCode(this, 'n_estimators', generator.ORDER_ATOMIC) || '100';
    var value_max_depth = generator.valueToCode(this, 'max_depth', generator.ORDER_ATOMIC) || 'None';
    var value_n_jobs = generator.valueToCode(this, 'n_jobs', generator.ORDER_ATOMIC) || 'None';
    var value_random_state = generator.valueToCode(this, 'random_state', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_' + dropdown_type] = 'from sklearn.ensemble import ' + dropdown_type;
    var code = value_model_name + ' = ' + dropdown_type + '(n_estimators = ' + value_n_estimators + ',max_depth = ' + value_max_depth + ',n_jobs = ' + value_n_jobs + ',random_state = ' + value_random_state + ')\n';
    return code;
}

// sklearn 初始化K近邻 分类/回归算法
const sklearn_KNeighborsClassifier_Regressor = function (_, generator) {
    var dropdown_type = this.getFieldValue('type');
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var value_K = generator.valueToCode(this, 'K', generator.ORDER_ATOMIC) || '5';
    var value_n_jobs = generator.valueToCode(this, 'n_jobs', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_' + dropdown_type] = 'from sklearn.neighbors import ' + dropdown_type;
    var code = value_model_name + ' = ' + dropdown_type + '(n_neighbors = ' + value_K + ',n_jobs = ' + value_n_jobs + ')\n';
    return code;
}

// sklearn 初始化高斯贝叶斯分类算法
const sklearn_GaussianNB = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    generator.definitions_['import_sklearn_GaussianNB'] = 'from sklearn.naive_bayes import GaussianNB';
    var code = value_model_name + ' = GaussianNB()\n';
    return code;
}

// sklearn 初始K-均值聚类
const sklearn_KMeans = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var value_n_clusters = generator.valueToCode(this, 'n_clusters', generator.ORDER_ATOMIC) || '8';
    var value_max_iter = generator.valueToCode(this, 'max_iter', generator.ORDER_ATOMIC) || '300';
    var value_random_state = generator.valueToCode(this, 'random_state', generator.ORDER_ATOMIC) || 'None';
    var value_n_jobs = generator.valueToCode(this, 'n_jobs', generator.ORDER_ATOMIC) || 'None';
    generator.definitions_['import_sklearn_KMeans'] = 'from sklearn.cluster import KMeans';
    var code = value_model_name + ' = KMeans(n_clusters = ' + value_n_clusters + ',max_iter = ' + value_max_iter + ',random_state = ' + value_random_state + ',n_jobs = ' + value_n_jobs + ')\n';
    return code;
}

// sklearn 训练模型
const sklearn_fit = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var value_train_data = generator.valueToCode(this, 'train_data', generator.ORDER_ATOMIC) || 'X_train';
    var value_train_target = generator.valueToCode(this, 'train_target', generator.ORDER_ATOMIC) || 'y_train';
    if (value_train_target == 'None')
        var code = value_model_name + '.fit(' + value_train_data + ')\n';
    else
        var code = value_model_name + '.fit(' + value_train_data + ',' + value_train_target + ')\n';
    return code;
}

// sklearn 训练模型-无标签值
const sklearn_fit_no_target = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var value_train_data = generator.valueToCode(this, 'train_data', generator.ORDER_ATOMIC) || 'X_train';
    var code = value_model_name + '.fit(' + value_train_data + ')\n';
    return code;
}

// sklearn 模型预测
const sklearn_predict = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var value_train_data = generator.valueToCode(this, 'train_data', generator.ORDER_ATOMIC) || 'X_test';
    var code = value_model_name + '.predict(' + value_train_data + ')';
    return [code, generator.ORDER_ATOMIC];
}

// sklearn 计算模型得分
const sklearn_score = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var value_train_data = generator.valueToCode(this, 'train_data', generator.ORDER_ATOMIC) || 'X_train';
    var value_train_target = generator.valueToCode(this, 'train_target', generator.ORDER_ATOMIC) || 'y_train';
    if (value_train_target == 'None')
        var code = value_model_name + '.score(' + value_train_data + ')';
    else
        var code = value_model_name + '.score(' + value_train_data + ',' + value_train_target + ')';
    return [code, generator.ORDER_ATOMIC];
}

// sklearn 计算模型得分-无标签值
const sklearn_score_no_target = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var value_train_data = generator.valueToCode(this, 'train_data', generator.ORDER_ATOMIC) || 'X_train';
    var code = value_model_name + '.score(' + value_train_data + ')';
    return [code, generator.ORDER_ATOMIC];
}

// sklearn 线性回归 模型获取 斜率/截距
const sklearn_coef_intercept = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var dropdown_type = this.getFieldValue('type');
    var code = value_model_name + '.' + dropdown_type;
    return [code, generator.ORDER_ATOMIC];
}

// sklearn K-均值聚类 模型获取 簇中心坐标/聚类后的标签/所有点到对应簇中心的距离平方和
const sklearn_cluster_centers_labels_inertia = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var dropdown_type = this.getFieldValue('type');
    var code = value_model_name + '.' + dropdown_type;
    return [code, generator.ORDER_ATOMIC];
}

// sklearn 保存/加载模型
const sklearn_save_load_model = function (_, generator) {
    var value_model_name = generator.valueToCode(this, 'model_name', generator.ORDER_ATOMIC) || 'model';
    var dropdown_type = this.getFieldValue('type');
    var value_address = generator.valueToCode(this, 'address', generator.ORDER_ATOMIC) || 'D:/mixly/test.pkl';
    generator.definitions_['import_sklearn_joblib'] = 'import joblib';
    var code = '';
    if (dropdown_type == 'dump')
        code = 'joblib.dump(' + value_model_name + ',' + value_address + ')\n';
    else
        code = value_model_name + ' = joblib.load(' + value_address + ')\n';
    return code;
}

/***/ }),

/***/ "../python_mixpy/generators/system.js":
/*!********************************************!*\
  !*** ../python_mixpy/generators/system.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   controls_end_program: () => (/* binding */ controls_end_program),
/* harmony export */   controls_millis: () => (/* binding */ controls_millis),
/* harmony export */   time_localtime: () => (/* binding */ time_localtime)
/* harmony export */ });
const controls_millis = function (_, generator) {
    generator.definitions_.import_time = "import time";
    var code = 'time.time()';
    return [code, generator.ORDER_ATOMIC];
}

const controls_end_program = function () {
    return 'exit()\n';
}

const time_localtime = function (_, generator) {
    generator.definitions_.import_time = "import time";
    var op = this.getFieldValue('op');
    var code = "time.localtime()[" + op + "]";
    switch (op) {
        case "all":
            var code1 = "time.localtime()";
            return [code1, generator.ORDER_ASSIGNMENT];
        default:
            return [code, generator.ORDER_ASSIGNMENT];
    }
}

/***/ }),

/***/ "../python_mixpy/generators/turtle.js":
/*!********************************************!*\
  !*** ../python_mixpy/generators/turtle.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   turtle_bgcolor: () => (/* binding */ turtle_bgcolor),
/* harmony export */   turtle_bgcolor_hex: () => (/* binding */ turtle_bgcolor_hex),
/* harmony export */   turtle_bgcolor_hex_new: () => (/* binding */ turtle_bgcolor_hex_new),
/* harmony export */   turtle_circle: () => (/* binding */ turtle_circle),
/* harmony export */   turtle_circle_advanced: () => (/* binding */ turtle_circle_advanced),
/* harmony export */   turtle_clear: () => (/* binding */ turtle_clear),
/* harmony export */   turtle_clone: () => (/* binding */ turtle_clone),
/* harmony export */   turtle_color: () => (/* binding */ turtle_color),
/* harmony export */   turtle_color_hex: () => (/* binding */ turtle_color_hex),
/* harmony export */   turtle_color_seclet: () => (/* binding */ turtle_color_seclet),
/* harmony export */   turtle_create: () => (/* binding */ turtle_create),
/* harmony export */   turtle_done: () => (/* binding */ turtle_done),
/* harmony export */   turtle_exitonclick: () => (/* binding */ turtle_exitonclick),
/* harmony export */   turtle_fill: () => (/* binding */ turtle_fill),
/* harmony export */   turtle_fillcolor: () => (/* binding */ turtle_fillcolor),
/* harmony export */   turtle_fillcolor_hex: () => (/* binding */ turtle_fillcolor_hex),
/* harmony export */   turtle_fillcolor_hex_new: () => (/* binding */ turtle_fillcolor_hex_new),
/* harmony export */   turtle_getscreen: () => (/* binding */ turtle_getscreen),
/* harmony export */   turtle_goto: () => (/* binding */ turtle_goto),
/* harmony export */   turtle_listen: () => (/* binding */ turtle_listen),
/* harmony export */   turtle_move: () => (/* binding */ turtle_move),
/* harmony export */   turtle_numinput: () => (/* binding */ turtle_numinput),
/* harmony export */   turtle_onclick: () => (/* binding */ turtle_onclick),
/* harmony export */   turtle_onkey: () => (/* binding */ turtle_onkey),
/* harmony export */   turtle_ontimer: () => (/* binding */ turtle_ontimer),
/* harmony export */   turtle_pencolor: () => (/* binding */ turtle_pencolor),
/* harmony export */   turtle_pencolor_hex: () => (/* binding */ turtle_pencolor_hex),
/* harmony export */   turtle_pencolor_hex_new: () => (/* binding */ turtle_pencolor_hex_new),
/* harmony export */   turtle_penup: () => (/* binding */ turtle_penup),
/* harmony export */   turtle_pos_shape: () => (/* binding */ turtle_pos_shape),
/* harmony export */   turtle_rotate: () => (/* binding */ turtle_rotate),
/* harmony export */   turtle_screen_delay: () => (/* binding */ turtle_screen_delay),
/* harmony export */   turtle_screen_savefig: () => (/* binding */ turtle_screen_savefig),
/* harmony export */   turtle_setheading: () => (/* binding */ turtle_setheading),
/* harmony export */   turtle_setxy: () => (/* binding */ turtle_setxy),
/* harmony export */   turtle_shape: () => (/* binding */ turtle_shape),
/* harmony export */   turtle_shapesize: () => (/* binding */ turtle_shapesize),
/* harmony export */   turtle_size: () => (/* binding */ turtle_size),
/* harmony export */   turtle_size_speed: () => (/* binding */ turtle_size_speed),
/* harmony export */   turtle_speed: () => (/* binding */ turtle_speed),
/* harmony export */   turtle_textinput: () => (/* binding */ turtle_textinput),
/* harmony export */   turtle_visible: () => (/* binding */ turtle_visible),
/* harmony export */   turtle_write: () => (/* binding */ turtle_write),
/* harmony export */   turtle_write_format: () => (/* binding */ turtle_write_format),
/* harmony export */   turtle_write_format_skulpt: () => (/* binding */ turtle_write_format_skulpt)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);


const turtle_create = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    //var size=window.parseFloat(this.getFieldValue('SIZE'));

    //generator.definitions_['var_declare'+varName] = varName+'= '+ 'turtle.Turtle()\n';
    var code = varName + ' = ' + 'turtle.Turtle()\n';
    return code;
    // return '';
}

const turtle_done = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var code = 'turtle.done()\n';
    return code;
}

const turtle_exitonclick = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var code = 'turtle.exitonclick()\n';
    return code;
}

const turtle_move = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var direction = this.getFieldValue('DIR');
    var num = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = varName + "." + direction + "(" + num + ')\n';
    return code;
}

const turtle_rotate = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var direction = this.getFieldValue('DIR');
    var num = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = varName + "." + direction + "(" + num + ')\n';
    return code;
}

const turtle_setheading = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var argument = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.setheading(' + argument + ')\n';
    return code;
}

const turtle_screen_delay = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var argument = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.screen.delay(' + argument + ')\n';
    return code;
}

const turtle_goto = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var xnum = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var ynum = generator.valueToCode(this, 'val', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.goto(' + xnum + ',' + ynum + ')\n';
    return code;
}

const turtle_pos_shape = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var get = this.getFieldValue('DIR');
    var code = varName + '.' + get + '()';
    return [code, generator.ORDER_ATOMIC];
}

const turtle_clear = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var clear = this.getFieldValue('DIR');
    var code = varName + "." + clear + "(" + ')\n';
    return code;
}

const turtle_penup = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var penup = this.getFieldValue('DIR');
    var code = varName + "." + penup + "(" + ')\n';
    return code;
}

const turtle_fill = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var penup = this.getFieldValue('DIR');
    var code = varName + "." + penup + "_fill(" + ')\n';
    return code;
}

const turtle_size_speed = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = this.getFieldValue('TUR');
    var size = this.getFieldValue('DIR');
    var num = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = varName + "." + size + "(" + num + ')\n';
    return code;
}

const turtle_size = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var argument = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.pensize(' + argument + ')\n';
    return code;
}

const turtle_speed = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var argument = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.speed(' + argument + ')\n';
    return code;
}

const turtle_circle = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var circle = this.getFieldValue('DIR');
    var num = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = varName + "." + circle + "(" + num + ')\n';
    return code;
}

const turtle_setxy = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var xy = this.getFieldValue('DIR');
    var num = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = varName + ".set" + xy + "(" + num + ')\n';
    return code;
}

const turtle_circle_advanced = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var argument = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var num = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = varName + ".circle (" + num + ',' + argument + ')\n';
    return code;
}

const turtle_visible = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var visible = this.getFieldValue('DIR');
    var code = varName + "." + visible + "(" + ')\n';
    return code;
}

const turtle_bgcolor = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var color = this.getFieldValue('FIELDNAME');
    var code = "turtle." + 'bgcolor' + '("' + color + '")\n';
    return code;
}

const turtle_pencolor = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var color = this.getFieldValue('FIELDNAME');
    var code = varName + "." + 'pencolor' + '("' + color + '")\n';
    return code;
}

const turtle_fillcolor = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var color = this.getFieldValue('FIELDNAME');
    var code = varName + "." + 'fillcolor' + '("' + color + '")\n';
    return code;
}

const turtle_clone = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.clone()';
    return [code, generator.ORDER_ATOMIC];
}

const turtle_bgcolor_hex = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var color = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = "turtle." + 'bgcolor' + '(' + color + ')\n';
    return code;
}

const turtle_pencolor_hex = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var color = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    //var color = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + "." + 'pencolor' + '(' + color + ')\n';
    return code;
}

const turtle_fillcolor_hex = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var color = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = varName + "." + 'fillcolor' + '(' + color + ')\n';
    return code;
}

const turtle_bgcolor_hex_new = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var color = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = "turtle." + 'bgcolor' + '(' + color + ')\n';
    return code;
}

const turtle_pencolor_hex_new = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var color = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    //var color = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + "." + 'pencolor' + '(' + color + ')\n';
    return code;
}

const turtle_fillcolor_hex_new = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var color = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = varName + "." + 'fillcolor' + '(' + color + ')\n';
    return code;
}

const turtle_color_hex = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var color1 = generator.valueToCode(this, 'VAR1', generator.ORDER_ATOMIC);
    var color2 = generator.valueToCode(this, 'VAR2', generator.ORDER_ATOMIC);
    var code = varName + "." + 'color' + '(' + color1 + ',' + color2 + ')\n';
    return code;
}

const turtle_color = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var color1 = this.getFieldValue('FIELDNAME');
    var color2 = this.getFieldValue('FIELDNAME2');
    var code = varName + "." + 'color' + '("' + color1 + '","' + color2 + '")\n';
    return code;
}

const turtle_shape = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var direction = this.getFieldValue('DIR');

    var code = varName + ".shape('" + direction + "')\n";
    return code;
}

const turtle_shapesize = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var argument1 = generator.valueToCode(this, 'WID', generator.ORDER_ASSIGNMENT) || '0';
    var argument2 = generator.valueToCode(this, 'LEN', generator.ORDER_ASSIGNMENT) || '0';
    var argument3 = generator.valueToCode(this, 'OUTLINE', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + ".shapesize(" + argument1 + ',' + argument2 + ',' + argument3 + ')\n';
    return code;
}

const turtle_textinput = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var title = generator.valueToCode(this, 'TITLE', generator.ORDER_ATOMIC);
    var prompt = generator.valueToCode(this, 'PROMPT', generator.ORDER_ATOMIC);
    var code = "turtle.textinput" + '(' + title + ',' + prompt + ')';
    return [code, generator.ORDER_ATOMIC];
}

const turtle_numinput = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var title = generator.valueToCode(this, 'TITLE', generator.ORDER_ATOMIC);
    var prompt = generator.valueToCode(this, 'PROMPT', generator.ORDER_ATOMIC);
    var data = generator.valueToCode(this, 'DEFAULT', generator.ORDER_ATOMIC);
    var min = generator.valueToCode(this, 'MIN', generator.ORDER_ATOMIC);
    var max = generator.valueToCode(this, 'MAX', generator.ORDER_ATOMIC);
    var code = "turtle.numinput" + '(' + title + ',' + prompt + "," + data + ',minval = ' + min + ',maxval = ' + max + ')';
    return [code, generator.ORDER_ATOMIC];
}

const turtle_write = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var write = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    //var color = generator.valueToCode(this, 'data', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + "." + 'write' + '(' + write + ')\n';
    return code;
}

const turtle_write_format = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var move = this.getFieldValue('MOVE');
    var align = this.getFieldValue('ALIGN');
    var fontname = generator.valueToCode(this, 'FONTNAME', generator.ORDER_ATOMIC);
    var fontnum = generator.valueToCode(this, 'FONTNUM', generator.ORDER_ASSIGNMENT) || '0';
    var fonttype = this.getFieldValue('FONTTYPE');
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var write = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = varName + "." + 'write' + '(' + write + ',' + move + ',align="' + align + '",font=(' + fontname + ',' + fontnum + ',"' + fonttype + '"))\n';
    return code;
}

const turtle_write_format_skulpt = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var move = this.getFieldValue('MOVE');
    var align = this.getFieldValue('ALIGN');
    var fontname = generator.valueToCode(this, 'FONTNAME', generator.ORDER_ATOMIC);
    var fontnum = generator.valueToCode(this, 'FONTNUM', generator.ORDER_ASSIGNMENT) || '0';
    var fonttype = this.getFieldValue('FONTTYPE');
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var write = generator.valueToCode(this, 'VAR', generator.ORDER_ATOMIC);
    var code = varName + "." + 'write' + '(' + write + ',' + move + ',align="' + align + '",font=(' + fontname + ',' + fontnum + ',"' + fonttype + '"))\n';
    return code;
}

const turtle_color_seclet = function (_, generator) {
    var colour = this.getFieldValue('COLOR');
    var code = '"' + colour + '"'
    return [code, generator.ORDER_ATOMIC];
}

const turtle_getscreen = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var turName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var varName = generator.variableDB_.getName(this.getFieldValue('VAR'),
        blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables.NAME_TYPE);
    var code = varName + ' = ' + turName + '.getscreen()\n';
    return code;
}

const turtle_onkey = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var v = generator.valueToCode(this, "VAR", generator.ORDER_NONE) || "None";
    var callback = generator.valueToCode(this, "callback", generator.ORDER_NONE) || "None";
    var code = varName + ".onkey(" + callback + ", " + v + ")\n";
    return code;
}

const turtle_onclick = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var callback = generator.valueToCode(this, "callback", generator.ORDER_NONE) || "None";
    var code = varName + ".onclick(" + callback + ")\n";
    return code;
}

const turtle_ontimer = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var v = generator.valueToCode(this, "VAR", generator.ORDER_NONE) || "None";
    var callback = generator.valueToCode(this, "callback", generator.ORDER_NONE) || "None";
    var code = varName + ".ontimer(" + callback + ", " + v + ")\n";
    return code;
}

const turtle_listen = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var code = varName + '.listen()\n';
    return code;
}

const turtle_screen_savefig = function (_, generator) {
    generator.definitions_.import_turtle = "import turtle";
    var varName = generator.valueToCode(this, 'TUR', generator.ORDER_ASSIGNMENT) || '0';
    var file = generator.valueToCode(this, 'FILE', generator.ORDER_ATOMIC);
    var code = varName + ".getcanvas().postscript(file=" + file + ")\n";
    return code;
}

/***/ }),

/***/ "./language/en.js":
/*!************************!*\
  !*** ./language/en.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnCatgories: () => (/* binding */ EnCatgories),
/* harmony export */   EnMsg: () => (/* binding */ EnMsg)
/* harmony export */ });
const EnMsg = {
    'PYTHON_PYODIDE_IMAGE': 'Image'
};

const EnCatgories = {};

/***/ }),

/***/ "./language/loader.js":
/*!****************************!*\
  !*** ./language/loader.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _zh_hans__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zh-hans */ "./language/zh-hans.js");
/* harmony import */ var _zh_hant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zh-hant */ "./language/zh-hant.js");
/* harmony import */ var _en__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./en */ "./language/en.js");





// 载入语言文件
Object.assign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Lang.ZhHans, _zh_hans__WEBPACK_IMPORTED_MODULE_1__.ZhHansMsg);
Object.assign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Lang.ZhHant, _zh_hant__WEBPACK_IMPORTED_MODULE_2__.ZhHantMsg);
Object.assign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Lang.En, _en__WEBPACK_IMPORTED_MODULE_3__.EnMsg);
Object.assign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Lang.ZhHans.MSG, _zh_hans__WEBPACK_IMPORTED_MODULE_1__.ZhHansCatgories);
Object.assign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Lang.ZhHant.MSG, _zh_hant__WEBPACK_IMPORTED_MODULE_2__.ZhHantCatgories);
Object.assign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Lang.En.MSG, _en__WEBPACK_IMPORTED_MODULE_3__.EnCatgories);

/***/ }),

/***/ "./language/zh-hans.js":
/*!*****************************!*\
  !*** ./language/zh-hans.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZhHansCatgories: () => (/* binding */ ZhHansCatgories),
/* harmony export */   ZhHansMsg: () => (/* binding */ ZhHansMsg)
/* harmony export */ });
const ZhHansMsg = {
    'PYTHON_PYODIDE_IMAGE': '图像'
};

const ZhHansCatgories = {};

/***/ }),

/***/ "./language/zh-hant.js":
/*!*****************************!*\
  !*** ./language/zh-hant.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZhHantCatgories: () => (/* binding */ ZhHantCatgories),
/* harmony export */   ZhHantMsg: () => (/* binding */ ZhHantMsg)
/* harmony export */ });
const ZhHantMsg = {
    'PYTHON_PYODIDE_IMAGE': '影像'
};

const ZhHantCatgories = {};

/***/ }),

/***/ "./node_modules/@basthon/kernel-loader/lib/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@basthon/kernel-loader/lib/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KernelLoader: () => (/* reexport safe */ _main__WEBPACK_IMPORTED_MODULE_0__.KernelLoader)
/* harmony export */ });
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ "./node_modules/@basthon/kernel-loader/lib/main.js");



/***/ }),

/***/ "./node_modules/@basthon/kernel-loader/lib/main.js":
/*!*********************************************************!*\
  !*** ./node_modules/@basthon/kernel-loader/lib/main.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KernelLoader: () => (/* binding */ KernelLoader)
/* harmony export */ });
/* harmony import */ var promise_delegate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! promise-delegate */ "./node_modules/promise-delegate/dist/es/PromiseDelegate.js");

/**
 * Helper class to dynamically load kernels.
 */
class KernelLoader {
    constructor(options, loaderId) {
        this._pageLoad = new promise_delegate__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();
        this._kernelAvailable = new promise_delegate__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();
        this._loaderId = "basthon-loader";
        /**
         * Flag to force loader to be shown.
         * Basically, loader can be hidden after Basthon loading.
         */
        this._doNotHideLoader = true;
        const language = options.language;
        if (loaderId != null)
            this._loaderId = loaderId;
        if (document.readyState === "loading") {
            const callback = () => {
                document.removeEventListener("DOMContentLoaded", callback);
                this._pageLoad.resolve();
            };
            document.addEventListener("DOMContentLoaded", callback);
        }
        else {
            // `DOMContentLoaded` has already fired
            this._pageLoad.resolve();
        }
        // Dynamicaly import to allow webpack chuncks
        (async () => {
            switch (language) {
                case "python":
                case "python3":
                case "python3.11":
                    const { Python3Kernel } = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_basthon_kernel-base_lib_kernel_js"), __webpack_require__.e("node_modules_basthon_kernel-python3_lib_index_js")]).then(__webpack_require__.bind(__webpack_require__, /*! @basthon/kernel-python3 */ "./node_modules/@basthon/kernel-python3/lib/index.js"));
                    this._kernel = new Python3Kernel(options);
                    break;
                case "python3-old":
                case "python3.8":
                    const { Python3OldKernel } = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_basthon_kernel-base_lib_kernel_js"), __webpack_require__.e("node_modules_basthon_kernel-python3-old_lib_index_js")]).then(__webpack_require__.bind(__webpack_require__, /*! @basthon/kernel-python3-old */ "./node_modules/@basthon/kernel-python3-old/lib/index.js"));
                    this._kernel = new Python3OldKernel(options);
                    break;
                case "js":
                case "javascript":
                    const { JavaScriptKernel } = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_basthon_kernel-base_lib_kernel_js"), __webpack_require__.e("vendors-node_modules_comlink_dist_esm_comlink_mjs"), __webpack_require__.e("vendors-node_modules_basthon_kernel-base_lib_worker_index_js"), __webpack_require__.e("node_modules_basthon_kernel-javascript_lib_index_js")]).then(__webpack_require__.bind(__webpack_require__, /*! @basthon/kernel-javascript */ "./node_modules/@basthon/kernel-javascript/lib/index.js"));
                    this._kernel = new JavaScriptKernel(options);
                    break;
                case "sql":
                    const { SQLKernel } = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_basthon_kernel-base_lib_kernel_js"), __webpack_require__.e("vendors-node_modules_comlink_dist_esm_comlink_mjs"), __webpack_require__.e("vendors-node_modules_basthon_kernel-base_lib_worker_index_js"), __webpack_require__.e("node_modules_basthon_kernel-sql_lib_index_js")]).then(__webpack_require__.bind(__webpack_require__, /*! @basthon/kernel-sql */ "./node_modules/@basthon/kernel-sql/lib/index.js"));
                    this._kernel = new SQLKernel(options);
                    break;
                case "ocaml":
                    const { OCamlKernel } = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_basthon_kernel-base_lib_kernel_js"), __webpack_require__.e("vendors-node_modules_comlink_dist_esm_comlink_mjs"), __webpack_require__.e("vendors-node_modules_basthon_kernel-base_lib_worker_index_js"), __webpack_require__.e("node_modules_basthon_kernel-ocaml_lib_index_js")]).then(__webpack_require__.bind(__webpack_require__, /*! @basthon/kernel-ocaml */ "./node_modules/@basthon/kernel-ocaml/lib/index.js"));
                    this._kernel = new OCamlKernel(options);
                    break;
                default:
                    window.console.error(`Kernel '${language}' not supported.`);
                    this._kernelAvailable.reject();
                    return;
            }
            // Some kernels need this e.g. Python3Kernel).
            window.Basthon = this._kernel;
            this._kernelAvailable.resolve(this._kernel);
        })();
    }
    /**
     * Returns a promise that resolves when page is loaded
     * (document.body available).
     */
    async pageLoad() {
        await this._pageLoad.promise;
    }
    /**
     * Is the kernel object available (not null)?
     * Be careful, it does not resolves when the kernel is started but when
     * it is set. See kernelStarted.
     */
    async kernelAvailable() {
        return await this._kernelAvailable.promise;
    }
    /**
     * Is the kernel started?
     */
    async kernelStarted() {
        const kernel = await this.kernelAvailable();
        await kernel.ready();
        return kernel;
    }
    /**
     * Kernel getter.
     */
    get kernel() {
        return this._kernel;
    }
    /**
     * Access the kernel or null if not ready
     */
    get kernelSafe() {
        return this.kernel?.isReady ? this.kernel : null;
    }
    /**
     * Show a fullscreen loader that disapear when Basthon is loaded.
     * If you want to manually hide the loader, set hideAfter to false.
     */
    async showLoader(text, fullscreen = false, hideAfter = true) {
        // kernel init
        this.kernelAvailable().then(() => this.kernel?.init());
        // dynamically import css
        // @ts-ignore
        __webpack_require__.e(/*! import() */ "node_modules_basthon_kernel-loader_lib_style_css").then(__webpack_require__.bind(__webpack_require__, /*! ./style.css */ "./node_modules/@basthon/kernel-loader/lib/style.css"));
        const layer = `basthon-loader-${fullscreen ? "full" : "foot"}`;
        // dynamically adding the loader to the DOM
        const root = document.createElement("div");
        root.id = this._loaderId;
        root.classList.add("darklighted");
        root.classList.add("basthon-loader-root");
        root.classList.add(layer);
        const container = document.createElement("div");
        container.classList.add("basthon-loader-container");
        container.classList.add(layer);
        root.appendChild(container);
        const loader = document.createElement("div");
        loader.classList.add("basthon-loader-spinner");
        loader.classList.add(layer);
        loader.innerHTML = "<span><span></span><span></span></span>";
        container.appendChild(loader);
        const space = document.createElement("div");
        space.classList.add("basthon-loader-break");
        space.classList.add(layer);
        container.appendChild(space);
        const textElem = document.createElement("div");
        textElem.classList.add("basthon-loader-text");
        textElem.classList.add(layer);
        textElem.innerHTML = text;
        container.appendChild(textElem);
        this._loaderTextElem = textElem;
        const textError = document.createElement("div");
        textError.classList.add("basthon-loader-text");
        textError.classList.add(layer);
        textError.style.display = "none";
        container.appendChild(textError);
        this._loaderTextError = textError;
        await this.pageLoad();
        document.body.appendChild(root);
        // backup root
        this._rootLoader = root;
        // waiting for Basthon
        try {
            await this.kernelStarted();
        }
        catch (e) {
            const browser = this.browser();
            this.setErrorText("Erreur de chargement de Basthon !!!" +
                "<br>" +
                "Vérifiez que votre navigateur est à jour." +
                "<br>" +
                `Version détectée : ${browser.name} ${browser.version}.`);
            for (const elem of document.body.querySelectorAll(".basthon-loader-foot")) {
                elem.classList.remove("basthon-loader-foot");
                elem.classList.add("basthon-loader-full");
            }
            loader.classList.remove("basthon-loader-spinner");
            loader.classList.add("basthon-loader-error");
            this._doNotHideLoader = true;
            return;
        }
        this._doNotHideLoader = false;
        // hide the loader if requested
        if (hideAfter) {
            this.hideLoader();
        }
    }
    /**
     * Setting the text loader.
     */
    setLoaderText(text) {
        if (this._loaderTextElem != null)
            this._loaderTextElem.innerHTML = text;
    }
    /**
     * Setting the error text.
     */
    setErrorText(text) {
        if (this._loaderTextElem != null)
            this._loaderTextElem.style.display = "none";
        if (this._loaderTextError != null) {
            this._loaderTextError.style.display = "";
            this._loaderTextError.innerHTML = text;
        }
    }
    /**
     * Hide the Basthon's loader.
     */
    hideLoader() {
        if (this._doNotHideLoader)
            return;
        const root = this._rootLoader;
        if (root == null)
            return;
        root.classList.add("basthon-loader-hide");
        window.setTimeout(() => {
            this._rootLoader = undefined;
            root.remove();
        }, 1100);
    }
    /**
     * Get browser info (name and version).
     */
    browser() {
        var ua = navigator.userAgent;
        var tem;
        var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if (/trident/i.test(M[1])) {
            tem = /\brv[ :]+(\d+)/g.exec(ua) || [""];
            return {
                name: "IE",
                version: tem[1] || "",
            };
        }
        if (M[1] === "Chrome") {
            tem = ua.match(/\bOPR|Edge\/(\d+)/);
            if (tem != null) {
                return {
                    name: "Opera",
                    version: tem[1],
                };
            }
        }
        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, "-?"];
        if ((tem = ua.match(/version\/(\d+)/i)) != null) {
            M.splice(1, 1, tem[1]);
        }
        return {
            name: M[0],
            version: M[1],
        };
    }
}


/***/ }),

/***/ "./node_modules/promise-delegate/dist/es/PromiseDelegate.js":
/*!******************************************************************!*\
  !*** ./node_modules/promise-delegate/dist/es/PromiseDelegate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PromiseDelegate: () => (/* binding */ PromiseDelegate)
/* harmony export */ });
var PromiseDelegate = (function () {
    function PromiseDelegate(ignoreMultipleSettles) {
        var _this = this;
        if (ignoreMultipleSettles === void 0) { ignoreMultipleSettles = false; }
        this.ignoreMultipleSettles = ignoreMultipleSettles;
        this.isSettled = false;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolveCallback = resolve;
            _this.rejectCallback = reject;
        });
    }
    PromiseDelegate.prototype.markAsSettled = function () {
        var wasSettled = this.isSettled;
        if (wasSettled && !this.ignoreMultipleSettles) {
            throw new Error("PromiseDelegate is already settled!");
        }
        this.isSettled = true;
        return !wasSettled;
    };
    Object.defineProperty(PromiseDelegate.prototype, "settled", {
        get: function () {
            return this.isSettled;
        },
        enumerable: false,
        configurable: true
    });
    PromiseDelegate.prototype.resolve = function (value) {
        if (this.markAsSettled()) {
            this.resolveCallback(value);
        }
    };
    PromiseDelegate.prototype.reject = function (reason) {
        if (this.markAsSettled()) {
            this.rejectCallback(reason);
        }
    };
    return PromiseDelegate;
}());

//# sourceMappingURL=PromiseDelegate.js.map

/***/ }),

/***/ "./others/loader.js":
/*!**************************!*\
  !*** ./others/loader.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nav_ext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nav-ext */ "./others/nav-ext.js");


_nav_ext__WEBPACK_IMPORTED_MODULE_0__["default"].init();

/***/ }),

/***/ "./others/nav-ext.js":
/*!***************************!*\
  !*** ./others/nav-ext.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mixly */ "mixly");
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mixly__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _python_shell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./python-shell */ "./others/python-shell.js");




const NavExt = {};

NavExt.init = async function () {
    const nav = mixly__WEBPACK_IMPORTED_MODULE_0__.app.getNav();

    nav.register({
        icon: 'icon-play-circled',
        title: '',
        id: 'python-run-btn',
        displayText: blockly_core__WEBPACK_IMPORTED_MODULE_1__.Msg.MSG['run'],
        preconditionFn: () => {
            return true;
        },
        callback: () => {
            _python_shell__WEBPACK_IMPORTED_MODULE_2__["default"].run();
        },
        scopeType: mixly__WEBPACK_IMPORTED_MODULE_0__.Nav.Scope.LEFT,
        weight: 4
    });

    nav.register({
        icon: 'icon-cancel',
        title: '',
        id: 'python-stop-btn',
        displayText: blockly_core__WEBPACK_IMPORTED_MODULE_1__.Msg.MSG['stop'],
        preconditionFn: () => {
            return true;
        },
        callback: () => {
            _python_shell__WEBPACK_IMPORTED_MODULE_2__["default"].stop();
        },
        scopeType: mixly__WEBPACK_IMPORTED_MODULE_0__.Nav.Scope.LEFT,
        weight: 5
    });

    await _python_shell__WEBPACK_IMPORTED_MODULE_2__["default"].init();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NavExt);

/***/ }),

/***/ "./others/python-shell.js":
/*!********************************!*\
  !*** ./others/python-shell.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mixly */ "mixly");
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mixly__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _basthon_kernel_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @basthon/kernel-loader */ "./node_modules/@basthon/kernel-loader/lib/index.js");
/* harmony import */ var _statusbar_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./statusbar-image */ "./others/statusbar-image.js");

// import * as dayjs from 'dayjs';




class PythonShell {
    static {
        this.pythonShell = null;

        this.init = async function () {
            _statusbar_image__WEBPACK_IMPORTED_MODULE_3__["default"].init();
            const projectPath = path__WEBPACK_IMPORTED_MODULE_0__.relative(mixly__WEBPACK_IMPORTED_MODULE_1__.Env.indexDirPath, mixly__WEBPACK_IMPORTED_MODULE_1__.Env.boardDirPath);
            const loader = new _basthon_kernel_loader__WEBPACK_IMPORTED_MODULE_2__.KernelLoader({
                rootPath: path__WEBPACK_IMPORTED_MODULE_0__.join(projectPath, 'deps'),
                language: 'python3',
            });

            const kernel = await loader.kernelAvailable();
            if (!kernel) {
                return;
            }
            await kernel.init();
            await kernel.loaded();

            this.loader = loader;
            this.kernel = kernel;
            this.pythonShell = new PythonShell();
            this.pyodide = window.pyodide;
            this.interruptBuffer = new Uint8Array(new ArrayBuffer(1));
            this.pyodide.setInterruptBuffer(this.interruptBuffer);
        }

        this.run = function () {
            const mainWorkspace = mixly__WEBPACK_IMPORTED_MODULE_1__.Workspace.getMain();
            const editor = mainWorkspace.getEditorsManager().getActive();
            const code = editor.getCode();
            return this.pythonShell.run(code);
        }

        this.stop = function () {
            return this.pythonShell.stop();
        }
    }

    #statusBarTerminal_ = null;
    #statusBarImage_ = null;
    #statusBarsManager_ = null;
    #cursor_ = {
        row: 0,
        column: 0
    };
    #prompt_ = '';
    #inputResolve_ = null;
    #inputReject_ = null;
    #waittingForInput_ = false;
    #running_ = false;
    #kernel_ = null;
    #onCursorChangeEvent_ = () => this.#onCursorChange_();
    #commands_ = [
        {
            name: 'REPL-Enter',
            bindKey: 'Enter',
            exec: (editor) => {
                const session = editor.getSession();
                const cursor = session.selection.getCursor();
                if (cursor.row === this.#cursor_.row) {
                    const newPos = this.#statusBarTerminal_.getEndPos();
                    let str = this.#statusBarTerminal_.getValueRange(this.#cursor_, newPos);
                    str = str.replace(this.#prompt_, '');
                    this.#inputResolve_?.(str);
                    this.#inputResolve_ = null;
                    this.#inputReject_ = null;
                    this.#statusBarTerminal_.addValue('\n');
                    this.#exitInput_();
                }
                return false;
            }
        }, {
            name: 'REPL-ChangeEditor',
            bindKey: 'Delete|Ctrl-X|Backspace',
            exec: (editor) => {
                const session = editor.getSession();
                const cursor = session.selection.getCursor();
                if (cursor.row < this.#cursor_.row || cursor.column <= this.#cursor_.column) {
                    return true;
                }
                return false;
            }
        }
    ];
    constructor() {
        const mainWorkspace = mixly__WEBPACK_IMPORTED_MODULE_1__.Workspace.getMain();
        this.#statusBarsManager_ = mainWorkspace.getStatusBarsManager();
        this.#statusBarTerminal_ = this.#statusBarsManager_.getStatusBarById('output');
        this.#statusBarImage_ = this.#statusBarsManager_.getStatusBarById('images');
        this.#kernel_ = PythonShell.kernel;
        this.#addEventsListener_();
    }

    #addEventsListener_() {
        this.#kernel_.addEventListener('eval.finished', () => {
            this.#running_ = false;
            this.#statusBarTerminal_.addValue(`\n==${mixly__WEBPACK_IMPORTED_MODULE_1__.Msg.Lang['shell.finish']}==`);
        });

        this.#kernel_.addEventListener('eval.output', (data) => {
            this.#statusBarTerminal_.addValue(data.content);
        });

        this.#kernel_.addEventListener('eval.error', () => {
            this.#running_ = false;
            this.#statusBarTerminal_.addValue(`\n==${mixly__WEBPACK_IMPORTED_MODULE_1__.Msg.Lang['shell.finish']}==`);
        });

        this.#kernel_.addEventListener('eval.input', (data) => {
            const prompt = String(data?.content?.prompt);
            this.#statusBarTerminal_.addValue(prompt);
            this.#prompt_ = prompt;
            this.#inputResolve_ = data.resolve;
            this.#inputReject_ = data.reject;
            this.#enterInput_();
        });

        this.#kernel_.addEventListener('eval.display', (data) => {
            this.#statusBarsManager_.changeTo('images');
            this.#statusBarImage_.display(data);
        });
    }

    #onCursorChange_() {
        const editor = this.#statusBarTerminal_.getEditor();
        const session = editor.getSession();
        const cursor = session.selection.getCursor();
        editor.setReadOnly(
            cursor.row < this.#cursor_.row || cursor.column < this.#cursor_.column
        );
    }

    #enterInput_() {
        if (!this.#running_) {
            return;
        }
        this.#waittingForInput_ = true;
        this.#cursor_ = this.#statusBarTerminal_.getEndPos();
        const editor = this.#statusBarTerminal_.getEditor();
        editor.setReadOnly(false);
        editor.focus();
        const session = editor.getSession();
        session.selection.on('changeCursor', this.#onCursorChangeEvent_);
        editor.commands.addCommands(this.#commands_);
    }

    #exitInput_() {
        this.#waittingForInput_ = false;
        const editor = this.#statusBarTerminal_.getEditor();
        const session = editor.getSession();
        session.selection.off('changeCursor', this.#onCursorChangeEvent_);
        editor.commands.removeCommands(this.#commands_);
        this.#prompt_ = '';
        this.#inputResolve_?.('');
        // this.#inputReject_?.({});
        this.cursor_ = { row: 0, column: 0 };
        editor.setReadOnly(true);
    }

    run(code) {
        this.stop()
            .then(() => {
                if (code.indexOf('import turtle') !== -1) {
                    code += '\nturtle.done()\n';
                }
                if (code.indexOf('import matplotlib.pyplot') !== -1) {
                    code += '\nplt.clf()\n';
                }
                this.#statusBarsManager_.changeTo('output');
                this.#statusBarsManager_.show();
                this.#statusBarTerminal_.setValue(`${mixly__WEBPACK_IMPORTED_MODULE_1__.Msg.Lang['shell.running']}...\n`);
                this.#running_ = true;
                this.#kernel_.dispatchEvent('eval.request', {
                    code,
                    interactive: false,
                });
            })
            .catch(mixly__WEBPACK_IMPORTED_MODULE_1__.Debug.error);
    }

    async stop() {
        if (this.#waittingForInput_) {
            this.#exitInput_();
        }
        if (this.#running_) {
            const timeout = 5;
            PythonShell.interruptBuffer[0] = 2;
            const startTime = Number(new Date());
            while (Number(new Date()) - startTime < timeout * 1000) {
                if (this.#running_) {
                    PythonShell.interruptBuffer[0] = 2;
                    await this.sleep(100);
                } else {
                    break;
                }
            }
            this.#running_ = false;
        }
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PythonShell);

/***/ }),

/***/ "./others/statusbar-image.js":
/*!***********************************!*\
  !*** ./others/statusbar-image.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mixly */ "mixly");
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mixly__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _language_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../language/loader */ "./language/loader.js");
/* harmony import */ var _templates_html_statusbar_image_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../templates/html/statusbar-image.html */ "./templates/html/statusbar-image.html");







class StatusBarImage extends mixly__WEBPACK_IMPORTED_MODULE_1__.PageBase {
    static {
        mixly__WEBPACK_IMPORTED_MODULE_1__.HTMLTemplate.add(
            'html/statusbar/statusbar-image.html',
            new mixly__WEBPACK_IMPORTED_MODULE_1__.HTMLTemplate(_templates_html_statusbar_image_html__WEBPACK_IMPORTED_MODULE_4__)
        );

        this.init = function () {
            mixly__WEBPACK_IMPORTED_MODULE_1__.StatusBarsManager.typesRegistry.register(['images'], StatusBarImage);
            const mainWorkspace = mixly__WEBPACK_IMPORTED_MODULE_1__.Workspace.getMain();
            const statusBarsManager = mainWorkspace.getStatusBarsManager();
            statusBarsManager.add('images', 'images', blockly_core__WEBPACK_IMPORTED_MODULE_0__.Msg.PYTHON_PYODIDE_IMAGE);
            statusBarsManager.changeTo('output');
        }
    }

    constructor() {
        super();
        const $content = jquery__WEBPACK_IMPORTED_MODULE_2___default()(mixly__WEBPACK_IMPORTED_MODULE_1__.HTMLTemplate.get('html/statusbar/statusbar-image.html').render());
        this.setContent($content);
    }

    init() {
        super.init();
        this.hideCloseBtn();
    }

    clean() {
        this.getContent().empty();
    }

    display(data) {
        const $content = this.getContent();
        const autoFit = function (node) {
            node.style.width = 'auto';
            node.style.height = 'auto';
            node.style.maxWidth = '100%';
            node.style.maxHeight = '100%';
        };
        this.clean();
        let root = data.content;
        let canvas = null;
        let iframe = null;
        switch (data.display_type) {
            case 'p5':
                root.style.width = '100%';
                root.style.height = '100%';
                root.style.display = 'flex';
                root.style.justifyContent = 'center';
                root.style.alignItems = 'center';

                // some canvas nodes can be added later so we observe...
                new MutationObserver(function (mutationsList) {
                    mutationsList.forEach((mutation) =>
                        mutation.addedNodes.forEach((node) => {
                            const elem = node;
                            if (
                                elem.tagName != null &&
                                ['canvas', 'video'].includes(elem.tagName.toLowerCase())
                            )
                                autoFit(elem);
                        })
                    );
                }).observe(root, { childList: true });

                root.querySelectorAll('canvas,video').forEach(autoFit);
                $content.append(root);
                break;
            case 'matplotlib':
                canvas = root.querySelector('canvas');
                if (canvas) root = canvas;
                root.style.width = '';
                root.style.height = '';
                root.style.maxWidth = '100%';
                root.style.maxHeight = '100%';
                $content.append(root);
                break;
            case 'ocaml-canvas':
                root.style.width = '';
                root.style.height = '';
                root.style.maxWidth = '100%';
                root.style.maxHeight = '100%';
                $content.append(root);
                break;
            case 'turtle':
                // Turtle result
                root.setAttribute('width', '100%');
                root.setAttribute('height', '100%');
                $content.append(root.outerHTML);
                break;
            case 'sympy':
                $content.append(data.content);
                if (typeof window.MathJax === 'undefined') {
                    // dynamically loading MathJax
                    console.log('Loading MathJax (Sympy expression needs it).');
                    (function () {
                        let script = document.createElement('script');
                        script.type = 'text/javascript';
                        script.src =
                            'https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js';
                        document.getElementsByTagName('head')[0].appendChild(script);
                    })();
                } else {
                    // otherwise, render it
                    window.MathJax.typeset();
                }
                break;
            case 'multiple':
                /* typically dispached by display() */
                for (let mime of [
                    'image/svg+xml',
                    'image/png',
                    'text/html',
                    'text/plain',
                ]) {
                    if (mime in data.content) {
                        let content = data.content[mime];
                        if (mime === 'image/png') {
                            content =
                                '<img src="data:image/png;base64,' +
                                content +
                                '" style="max-width: 100%; max-height: 100%;">';
                        }
                        $content.append(content);
                        break;
                    }
                }
                break;
            case 'tutor':
                // hacky but iframe.document.body.style require to wait for
                // iframe loading
                $content.append(jquery__WEBPACK_IMPORTED_MODULE_2___default()(data.content.replace('overflow-y%3A%20hidden%3B', '')));
                iframe = this.getContent()[0].getElementsByTagName('iframe')[0];
                if (iframe == null) return;
                // trick to avoid taking height update into account
                iframe.style.maxHeight = iframe.style.minHeight = '100%';

                // force rendering when visible,
                // otherwise, strange things happends
                // since PythonTutor check for visibility at some point
                new IntersectionObserver((entries, observer) => {
                    const entry = entries[0];
                    if (entry && !entry.isIntersecting) return;
                    iframe.contentWindow?.postMessage({ type: 'redraw' }, '*');
                    observer.disconnect();
                }).observe(iframe);

                break;
            default:
                console.error(
                    `Not supported node type '${data.display_type}' in eval.display result processing.`
                );
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StatusBarImage);

/***/ }),

/***/ "./css/color_mixpy_python_advance.css":
/*!********************************************!*\
  !*** ./css/color_mixpy_python_advance.css ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./templates/html/statusbar-image.html":
/*!*********************************************!*\
  !*** ./templates/html/statusbar-image.html ***!
  \*********************************************/
/***/ ((module) => {

module.exports = "<style>\n    div[m-id=\"{{d.mId}}\"] {\n        display: flex;\n        flex-direction: row;\n        justify-content: center;\n        align-items: center;\n    }\n\n    html[data-bs-theme=light] div[m-id=\"{{d.mId}}\"] {\n        background-color: #ffffff;\n    }\n\n    html[data-bs-theme=dark] div[m-id=\"{{d.mId}}\"] {\n        background-color: #1e1e1e;\n    }\n</style>\n<div m-id=\"{{d.mId}}\" class=\"page-item\">\n\n</div>";

/***/ }),

/***/ "jquery":
/*!********************!*\
  !*** external "$" ***!
  \********************/
/***/ ((module) => {

module.exports = $;

/***/ }),

/***/ "blockly/core":
/*!**************************!*\
  !*** external "Blockly" ***!
  \**************************/
/***/ ((module) => {

module.exports = Blockly;

/***/ }),

/***/ "mixly":
/*!************************!*\
  !*** external "Mixly" ***!
  \************************/
/***/ ((module) => {

module.exports = Mixly;

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = path;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "styles/" + chunkId + "." + "1da6949d" + ".css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "@mixly/python-pyodide:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		if (typeof document === "undefined") return;
/******/ 		var createStylesheet = (chunkId, fullhref, oldTag, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			if (__webpack_require__.nc) {
/******/ 				linkTag.nonce = __webpack_require__.nc;
/******/ 			}
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && event.type;
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + errorType + ": " + realHref + ")");
/******/ 					err.name = "ChunkLoadError";
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					if (linkTag.parentNode) linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 		
/******/ 			if (oldTag) {
/******/ 				oldTag.parentNode.insertBefore(linkTag, oldTag.nextSibling);
/******/ 			} else {
/******/ 				document.head.appendChild(linkTag);
/******/ 			}
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, null, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// object to store loaded CSS chunks
/******/ 		var installedCssChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.miniCss = (chunkId, promises) => {
/******/ 			var cssChunks = {"node_modules_basthon_kernel-loader_lib_style_css":1};
/******/ 			if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);
/******/ 			else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {
/******/ 				promises.push(installedCssChunks[chunkId] = loadStylesheet(chunkId).then(() => {
/******/ 					installedCssChunks[chunkId] = 0;
/******/ 				}, (e) => {
/******/ 					delete installedCssChunks[chunkId];
/******/ 					throw e;
/******/ 				}));
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no hmr
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_mixly_python_pyodide"] = self["webpackChunk_mixly_python_pyodide"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
/*!******************!*\
  !*** ./index.js ***!
  \******************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ "blockly/core");
/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _language_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./language/loader */ "./language/loader.js");
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mixly */ "mixly");
/* harmony import */ var mixly__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mixly__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _mixly_python__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mixly/python */ "../python/export.js");
/* harmony import */ var _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mixly/python-mixpy */ "../python_mixpy/export.js");
/* harmony import */ var _others_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./others/loader */ "./others/loader.js");
/* harmony import */ var _css_color_mixpy_python_advance_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./css/color_mixpy_python_advance.css */ "./css/color_mixpy_python_advance.css");












Object.assign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Variables, _mixly_python__WEBPACK_IMPORTED_MODULE_3__.Variables);
Object.assign(blockly_core__WEBPACK_IMPORTED_MODULE_0__.Procedures, _mixly_python__WEBPACK_IMPORTED_MODULE_3__.Procedures);
blockly_core__WEBPACK_IMPORTED_MODULE_0__.Python = _mixly_python__WEBPACK_IMPORTED_MODULE_3__.Python;
blockly_core__WEBPACK_IMPORTED_MODULE_0__.generator = _mixly_python__WEBPACK_IMPORTED_MODULE_3__.Python;

mixly__WEBPACK_IMPORTED_MODULE_2__.Profile.default = {};

Object.assign(
    blockly_core__WEBPACK_IMPORTED_MODULE_0__.Blocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonVariablesBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonControlBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonMathBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonTextBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonListsBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonDictsBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonLogicBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonStorageBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonProceduresBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonTupleBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonSetBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonHtmlBlocks,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonUtilityBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyAIBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyAlgorithmBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyCommunicateBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyCVBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyDataBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyDatastructureBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyFactoryBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyHardwareBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyInoutBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyIOTBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyPinsBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpySerialBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpySKLearnBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpySystemBlocks,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyTurtleBlocks,
);

Object.assign(
    blockly_core__WEBPACK_IMPORTED_MODULE_0__.Python.forBlock,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonVariablesGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonControlGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonMathGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonTextGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonListsGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonDictsGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonLogicGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonStorageGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonProceduresGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonTupleGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonSetGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonHtmlGenerators,
    _mixly_python__WEBPACK_IMPORTED_MODULE_3__.PythonUtilityGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyAIGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyAlgorithmGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyCommunicateGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyCVGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyDataGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyDatastructureGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyFactoryGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyHardwareGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyInoutGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyIOTGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyPinsGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpySerialGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpySKLearnGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpySystemGenerators,
    _mixly_python_mixpy__WEBPACK_IMPORTED_MODULE_4__.PythonMixpyTurtleGenerators
);
/******/ })()
;
//# sourceMappingURL=main.bundle.js.map