"use strict";
(self["webpackChunk_mixly_python_pyodide"] = self["webpackChunk_mixly_python_pyodide"] || []).push([["vendors-node_modules_basthon_kernel-base_lib_kernel_js"],{

/***/ "./node_modules/@basthon/kernel-base/lib/commons.js":
/*!**********************************************************!*\
  !*** ./node_modules/@basthon/kernel-base/lib/commons.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotImplementedError: () => (/* binding */ NotImplementedError),
/* harmony export */   mockFetch: () => (/* binding */ mockFetch)
/* harmony export */ });
/**
 * An error thrown by not implemented API functions.
 */
class NotImplementedError extends Error {
    constructor(funcName) {
        super(`Function ${funcName} not implemented!`);
        this.name = "NotImplementedError";
    }
}
/* fetch from local FS */
const fetchFromLocalFS = async (localfsScheme, url) => {
    const toDataURL = async (content) => {
        return await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                resolve(reader.result);
            };
            reader.onerror = reject;
            reader.readAsDataURL(new Blob([content]));
        });
    };
    const prefix = localfsScheme;
    const path = url.slice(prefix.length);
    let content = null;
    const options = {
        status: 200,
        statusText: "OK",
        headers: new Headers(),
    };
    try {
        //@ts-ignore
        content = self.Basthon.getFile(path);
        const dataURL = await toDataURL(content);
        const mime = dataURL.substring(dataURL.indexOf(":") + 1, dataURL.indexOf(";"));
        content = content.buffer;
        options.headers.append("Content-Type", mime);
        options.headers.append("Content-Length", content.byteLength);
    }
    catch (e) {
        options.status = 404;
        options.statusText = "Not Found";
    }
    return new Response(content, options);
};
/**
 * Get the origin of an url.
 */
const origin = (url) => new URL(url).origin;
/**
 * Get the parent path of an url.
 */
const parent = (url) => {
    const abs = new URL(url).href;
    return abs.substring(0, abs.lastIndexOf("/"));
};
/**
 * we mock the fetch function to:
 *  - redirect queries to local FS
 *  - bypass the worker's opaque origin
 */
const mockFetch = () => {
    // already mocked?
    if (self.fetch.name === "mockedFetch")
        return;
    const trueFetch = self.fetch;
    async function mockedFetch(request, init) {
        if (self.importScripts == null || self._assetsURL == null)
            return Response.error();
        // force all params to init object
        if (request instanceof Request)
            init = { ...request, ...init };
        // ensure credentials are not sent
        init = { ...init, ...{ credentials: "omit" } };
        const url = request.url ?? request.toString();
        const localfsScheme = "filesystem:/";
        try {
            // requests towards localfs
            if (url.startsWith(localfsScheme)) {
                return await fetchFromLocalFS(localfsScheme, url);
            }
            else if (origin(url) === origin(self._assetsURL)) {
                // requests towards same origin
                // only url under the assets folder are proxyied
                if (parent(url).startsWith(self._assetsURL)) {
                    const proxy = self._remoteProxy;
                    const { body, options } = await proxy.fetch(url, init);
                    return new Response(body, options);
                }
                throw new Error("Ressource is outside the proxy' scope");
            }
            return await trueFetch(url, init);
        }
        catch (e) {
            console.error(`security proxy: request to ${url} throw error: ${e.toString()}`);
            return Response.error();
        }
    }
    self.fetch = mockedFetch;
};



/***/ }),

/***/ "./node_modules/@basthon/kernel-base/lib/kernel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@basthon/kernel-base/lib/kernel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KernelBase: () => (/* binding */ KernelBase),
/* harmony export */   VERSION: () => (/* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_1__.VERSION)
/* harmony export */ });
/* harmony import */ var promise_delegate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! promise-delegate */ "./node_modules/promise-delegate/dist/es/PromiseDelegate.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./version */ "./node_modules/@basthon/kernel-base/lib/version.js");
/* harmony import */ var _commons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commons */ "./node_modules/@basthon/kernel-base/lib/commons.js");



// const desc = Object.getOwnPropertyDescriptor(
//   HTMLImageElement.prototype,
//   "src"
// );
// Object.defineProperty(HTMLImageElement.prototype, "src", {
//   ...desc,
//   get: function () {
//     return desc?.get?.call(this);
//   },
//   set: function (e) {
//     const prefix = _localfsScheme;
//     if (e.startsWith(prefix)) {
//       const path = e.slice(prefix.length);
//       //@ts-ignore
//       const content = window.Basthon.getFile(path).buffer;
//       (async () => desc?.set?.call(this, await toDataURL(content)))();
//     } else {
//       desc?.set?.call(this, e);
//     }
//   },
// });
/**
 * Event for Basthon's dispatch/listen.
 */
class BasthonEvent extends Event {
    constructor(id, data) {
        super(id);
        this.detail = data;
    }
}

/**
 * API that any Basthon kernel should fill to be supported
 * in console/notebook.
 */
class KernelBase {
    constructor(options) {
        this._isReady = false;
        this._ready = new promise_delegate__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();
        this._stopped = Promise.resolve();
        this._execution_count = 0;
        this._pendingInput = undefined;
        // a map to register wrapped listeners to allow later remove
        this._listeners = new Map();
        this._files = new Map();
        this._modules = new Map();
        this._options = this.clone(options);
        // root path where kernel is installed
        this._rootPath = options.rootPath;
        if (!this.safeKernel())
            console.warn(`%c⚠ DANGER ⚠: kernel ${this.language()} not safe!` +
                " Please consider using a safe kernel.", "color: red; font-size: 20px;");
    }
    /**
     * Is this kernel safe? (loaded from an isolated web worker)
     */
    safeKernel() {
        return false;
    }
    /**
     * Kernel version number (string).
     */
    version() {
        return _version__WEBPACK_IMPORTED_MODULE_1__.VERSION;
    }
    /**
     * Language implemented in the kernel (string).
     * Generally lower case.
     */
    language() {
        throw new _commons__WEBPACK_IMPORTED_MODULE_2__.NotImplementedError("language");
    }
    /**
     * Language name implemented in the kernel (string).
     * As it should be displayed in text.
     */
    languageName() {
        throw new _commons__WEBPACK_IMPORTED_MODULE_2__.NotImplementedError("languageName");
    }
    /**
     * Script (module) file extensions
     */
    moduleExts() {
        throw new _commons__WEBPACK_IMPORTED_MODULE_2__.NotImplementedError("moduleExts");
    }
    /**
     * Execution count getter.
     */
    get execution_count() {
        return this._execution_count;
    }
    /**
     * Async code evaluation that resolves with the result.
     */
    evalAsync(code, outCallback, errCallback, data = null) {
        throw new _commons__WEBPACK_IMPORTED_MODULE_2__.NotImplementedError("evalAsync");
    }
    async putFile(filename, content) {
        this._files.set(filename, content);
    }
    async putModule(filename, content) {
        this._modules.set(filename, content);
    }
    userModules() {
        return [];
    }
    /**
     * Get a file content from the VFS.
     */
    getFile(path) {
        throw new _commons__WEBPACK_IMPORTED_MODULE_2__.NotImplementedError("getFile");
    }
    /**
     * Get a user module file content.
     */
    getUserModuleFile(filename) {
        throw new _commons__WEBPACK_IMPORTED_MODULE_2__.NotImplementedError("getUserModuleFile");
    }
    async more(source) {
        throw new _commons__WEBPACK_IMPORTED_MODULE_2__.NotImplementedError("more");
    }
    async complete(code) {
        return [];
    }
    banner() {
        return `Welcome to the ${this.languageName()} REPL!`;
    }
    ps1() {
        return ">>> ";
    }
    ps2() {
        return "... ";
    }
    /**
     * Launch the kernel (used to wrap a promise around init).
     */
    async _init() { }
    /**
     * Initialize the kernel and start it.
     */
    async init() {
        try {
            await this._init();
        }
        catch (error) {
            this._ready.reject(error);
            return;
        }
        // connecting eval to basthon.eval.request event.
        this.addEventListener("eval.request", this.evalFromEvent.bind(this));
        await this.start();
    }
    /**
     * Start the kernel (used to wrap a promise around start).
     */
    async _start() { }
    /**
     * Start the kernel.
     */
    async start() {
        await this._stopped;
        this._execution_count = 0;
        try {
            await this._start();
        }
        catch (error) {
            this._ready.reject(error);
            return;
        }
        this._files.forEach((v, k) => this.putFile(k, v));
        this._modules.forEach((v, k) => this.putModule(k, v));
        this._isReady = true;
        this._ready.resolve();
    }
    /**
     * Perform async part of the stoping process.
     */
    async _stop() { }
    /**
     * Stop the kernel synchronously (to ensure kernel is stopped after the call).
     */
    stop() {
        this._isReady = false;
        this._ready = new promise_delegate__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();
        this._stopped = this._stop();
    }
    /**
     * Restart the kernel (stop and start).
     * Use await this.ready() to ensure kernel is started
     */
    restart() {
        this.stop(); // sync
        this.start(); // async
    }
    /**
     * Is the kernel ready?
     */
    get isReady() {
        return this._isReady;
    }
    /**
     * Promise that resolves when the kernel is ready (started).
     */
    async ready() {
        return this._ready.promise;
    }
    /**
     * Root for kernel files. This is always the language directory
     * inside the version number directory inside the kernel directory.
     */
    basthonRoot(absolute = false) {
        let url = this._rootPath + "/" + this.version() + "/" + this.language();
        if (absolute && !url.startsWith("http")) {
            const base = window.location.origin + window.location.pathname;
            url = base.substring(0, base.lastIndexOf("/")) + "/" + url;
        }
        return url;
    }
    /**
     * Downloading data (bytes array or data URL) as filename
     * (opening browser dialog).
     */
    download(data, filename) {
        if (!(typeof data === "string" || data instanceof String)) {
            const blob = new Blob([data], { type: "application/octet-stream" });
            data = window.URL.createObjectURL(blob);
        }
        const anchor = document.createElement("a");
        anchor.download = filename;
        anchor.href = data;
        anchor.target = "_blank";
        anchor.style.display = "none"; // just to be safe!
        document.body.appendChild(anchor);
        anchor.click();
        document.body.removeChild(anchor);
    }
    /**
     * Dynamically load a script asynchronously.
     */
    static loadScript(url) {
        return new Promise(function (resolve, reject) {
            let script = document.createElement("script");
            script.onload = resolve;
            script.onerror = reject;
            script.src = url;
            document.head.appendChild(script);
        });
    }
    /**
     * Wrapper around document.dispatchEvent.
     * It adds the 'basthon.' prefix to each event name and
     * manage the event lookup to retreive relevent data.
     */
    dispatchEvent(eventName, data) {
        document.dispatchEvent(new BasthonEvent(`basthon.${eventName}`, data));
    }
    /**
     * Wrapper around document.addEventListener.
     * It manages the 'basthon.' prefix to each event name and
     * manage the event lookup to retreive relevent data.
     */
    addEventListener(eventName, callback) {
        // wrapped callback
        const _callback = (event) => callback(event.detail);
        document.addEventListener(`basthon.${eventName}`, _callback);
        // register the wrapped callback in order to remove it
        let listeners = this._listeners.get(eventName);
        if (listeners == null) {
            listeners = new Map();
            this._listeners.set(eventName, listeners);
        }
        listeners.set(callback, _callback);
    }
    /**
     * Wrapper around document.removeEventListener.
     * It manages the 'basthon.' prefix to each event name.
     */
    removeEventListener(eventName, callback) {
        // get the wrapped callback
        const listeners = this._listeners.get(eventName);
        document.removeEventListener(`basthon.${eventName}`, listeners?.get(callback));
    }
    /**
     * Send eval.input event then wait for the user response and return it.
     */
    async inputAsync(prompt, password = false, data = undefined) {
        data = this.clone(data);
        data.content = { prompt, password };
        const pd = new promise_delegate__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();
        data.resolve = pd.resolve.bind(pd);
        data.reject = pd.reject.bind(pd);
        this._pendingInput = pd;
        this.dispatchEvent("eval.input", data);
        const res = await pd.promise;
        this._pendingInput = undefined;
        return res;
    }
    /**
     * Close a pending input.
     */
    resolvePendingInput() {
        this._pendingInput?.resolve("");
    }
    /**
     * Simple clone via JSON copy.
     */
    clone(obj) {
        // simple trick that is enough for our purpose.
        return JSON.parse(JSON.stringify(obj));
    }
    /**
     * Put a ressource (file or module).
     * Detection is based on extension.
     */
    async putRessource(filename, content) {
        const ext = filename.split(".").pop() ?? "";
        if (this.moduleExts().includes(ext)) {
            return await this.putModule(filename, content);
        }
        else {
            return await this.putFile(filename, content);
        }
    }
    /**
     * Is an input pending?
     */
    pendingInput() {
        return this._pendingInput != null;
    }
    /**
     * Internal. Code evaluation after an eval.request event.
     */
    async evalFromEvent(data) {
        const stdCallback = (std) => (text) => {
            let dataEvent = this.clone(data);
            dataEvent.stream = std;
            dataEvent.content = text;
            this.dispatchEvent("eval.output", dataEvent);
        };
        const outCallback = stdCallback("stdout");
        const errCallback = stdCallback("stderr");
        let args;
        try {
            args = await this.evalAsync(data.code, outCallback, errCallback, data);
        }
        catch (error) {
            errCallback(error.toString());
            const dataEvent = this.clone(data);
            dataEvent.error = error;
            dataEvent.execution_count = this.execution_count;
            this.dispatchEvent("eval.error", dataEvent);
            return;
        }
        if (args == null)
            return; // this should not happend
        const result = args[0];
        const executionCount = args[1];
        let dataEvent = this.clone(data);
        dataEvent.execution_count = executionCount;
        if (result != null)
            dataEvent.result = result;
        this.dispatchEvent("eval.finished", dataEvent);
    }
}


/***/ }),

/***/ "./node_modules/@basthon/kernel-base/lib/version.js":
/*!**********************************************************!*\
  !*** ./node_modules/@basthon/kernel-base/lib/version.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const VERSION = "0.62.22";


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_basthon_kernel-base_lib_kernel_js.bundle.js.map