{"version":3,"file":"vendors-node_modules_basthon_kernel-base_lib_kernel_js.bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,KAAK,eAAe,aAAa;AACzF;AACA;AACA;AACA;AACA;AAC0C;;;;;;;;;;;;;;;;;;;ACnGS;AACf;AACY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmB;AACnB;AACA;AACA;AACA;AACO;AACP;AACA;AACA,0BAA0B,6DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE,sEAAsE,gBAAgB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kCAAkC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uBAAuB,6DAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9WO","sources":["webpack://@mixly/python-pyodide/./node_modules/@basthon/kernel-base/lib/commons.js","webpack://@mixly/python-pyodide/./node_modules/@basthon/kernel-base/lib/kernel.js","webpack://@mixly/python-pyodide/./node_modules/@basthon/kernel-base/lib/version.js"],"sourcesContent":["/**\n * An error thrown by not implemented API functions.\n */\nclass NotImplementedError extends Error {\n    constructor(funcName) {\n        super(`Function ${funcName} not implemented!`);\n        this.name = \"NotImplementedError\";\n    }\n}\n/* fetch from local FS */\nconst fetchFromLocalFS = async (localfsScheme, url) => {\n    const toDataURL = async (content) => {\n        return await new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onloadend = () => {\n                resolve(reader.result);\n            };\n            reader.onerror = reject;\n            reader.readAsDataURL(new Blob([content]));\n        });\n    };\n    const prefix = localfsScheme;\n    const path = url.slice(prefix.length);\n    let content = null;\n    const options = {\n        status: 200,\n        statusText: \"OK\",\n        headers: new Headers(),\n    };\n    try {\n        //@ts-ignore\n        content = self.Basthon.getFile(path);\n        const dataURL = await toDataURL(content);\n        const mime = dataURL.substring(dataURL.indexOf(\":\") + 1, dataURL.indexOf(\";\"));\n        content = content.buffer;\n        options.headers.append(\"Content-Type\", mime);\n        options.headers.append(\"Content-Length\", content.byteLength);\n    }\n    catch (e) {\n        options.status = 404;\n        options.statusText = \"Not Found\";\n    }\n    return new Response(content, options);\n};\n/**\n * Get the origin of an url.\n */\nconst origin = (url) => new URL(url).origin;\n/**\n * Get the parent path of an url.\n */\nconst parent = (url) => {\n    const abs = new URL(url).href;\n    return abs.substring(0, abs.lastIndexOf(\"/\"));\n};\n/**\n * we mock the fetch function to:\n *  - redirect queries to local FS\n *  - bypass the worker's opaque origin\n */\nconst mockFetch = () => {\n    // already mocked?\n    if (self.fetch.name === \"mockedFetch\")\n        return;\n    const trueFetch = self.fetch;\n    async function mockedFetch(request, init) {\n        if (self.importScripts == null || self._assetsURL == null)\n            return Response.error();\n        // force all params to init object\n        if (request instanceof Request)\n            init = { ...request, ...init };\n        // ensure credentials are not sent\n        init = { ...init, ...{ credentials: \"omit\" } };\n        const url = request.url ?? request.toString();\n        const localfsScheme = \"filesystem:/\";\n        try {\n            // requests towards localfs\n            if (url.startsWith(localfsScheme)) {\n                return await fetchFromLocalFS(localfsScheme, url);\n            }\n            else if (origin(url) === origin(self._assetsURL)) {\n                // requests towards same origin\n                // only url under the assets folder are proxyied\n                if (parent(url).startsWith(self._assetsURL)) {\n                    const proxy = self._remoteProxy;\n                    const { body, options } = await proxy.fetch(url, init);\n                    return new Response(body, options);\n                }\n                throw new Error(\"Ressource is outside the proxy' scope\");\n            }\n            return await trueFetch(url, init);\n        }\n        catch (e) {\n            console.error(`security proxy: request to ${url} throw error: ${e.toString()}`);\n            return Response.error();\n        }\n    }\n    self.fetch = mockedFetch;\n};\nexport { NotImplementedError, mockFetch };\n","import { PromiseDelegate } from \"promise-delegate\";\nimport { VERSION } from \"./version\";\nimport { NotImplementedError } from \"./commons\";\n// const desc = Object.getOwnPropertyDescriptor(\n//   HTMLImageElement.prototype,\n//   \"src\"\n// );\n// Object.defineProperty(HTMLImageElement.prototype, \"src\", {\n//   ...desc,\n//   get: function () {\n//     return desc?.get?.call(this);\n//   },\n//   set: function (e) {\n//     const prefix = _localfsScheme;\n//     if (e.startsWith(prefix)) {\n//       const path = e.slice(prefix.length);\n//       //@ts-ignore\n//       const content = window.Basthon.getFile(path).buffer;\n//       (async () => desc?.set?.call(this, await toDataURL(content)))();\n//     } else {\n//       desc?.set?.call(this, e);\n//     }\n//   },\n// });\n/**\n * Event for Basthon's dispatch/listen.\n */\nclass BasthonEvent extends Event {\n    constructor(id, data) {\n        super(id);\n        this.detail = data;\n    }\n}\nexport { VERSION };\n/**\n * API that any Basthon kernel should fill to be supported\n * in console/notebook.\n */\nexport class KernelBase {\n    constructor(options) {\n        this._isReady = false;\n        this._ready = new PromiseDelegate();\n        this._stopped = Promise.resolve();\n        this._execution_count = 0;\n        this._pendingInput = undefined;\n        // a map to register wrapped listeners to allow later remove\n        this._listeners = new Map();\n        this._files = new Map();\n        this._modules = new Map();\n        this._options = this.clone(options);\n        // root path where kernel is installed\n        this._rootPath = options.rootPath;\n        if (!this.safeKernel())\n            console.warn(`%c⚠ DANGER ⚠: kernel ${this.language()} not safe!` +\n                \" Please consider using a safe kernel.\", \"color: red; font-size: 20px;\");\n    }\n    /**\n     * Is this kernel safe? (loaded from an isolated web worker)\n     */\n    safeKernel() {\n        return false;\n    }\n    /**\n     * Kernel version number (string).\n     */\n    version() {\n        return VERSION;\n    }\n    /**\n     * Language implemented in the kernel (string).\n     * Generally lower case.\n     */\n    language() {\n        throw new NotImplementedError(\"language\");\n    }\n    /**\n     * Language name implemented in the kernel (string).\n     * As it should be displayed in text.\n     */\n    languageName() {\n        throw new NotImplementedError(\"languageName\");\n    }\n    /**\n     * Script (module) file extensions\n     */\n    moduleExts() {\n        throw new NotImplementedError(\"moduleExts\");\n    }\n    /**\n     * Execution count getter.\n     */\n    get execution_count() {\n        return this._execution_count;\n    }\n    /**\n     * Async code evaluation that resolves with the result.\n     */\n    evalAsync(code, outCallback, errCallback, data = null) {\n        throw new NotImplementedError(\"evalAsync\");\n    }\n    async putFile(filename, content) {\n        this._files.set(filename, content);\n    }\n    async putModule(filename, content) {\n        this._modules.set(filename, content);\n    }\n    userModules() {\n        return [];\n    }\n    /**\n     * Get a file content from the VFS.\n     */\n    getFile(path) {\n        throw new NotImplementedError(\"getFile\");\n    }\n    /**\n     * Get a user module file content.\n     */\n    getUserModuleFile(filename) {\n        throw new NotImplementedError(\"getUserModuleFile\");\n    }\n    async more(source) {\n        throw new NotImplementedError(\"more\");\n    }\n    async complete(code) {\n        return [];\n    }\n    banner() {\n        return `Welcome to the ${this.languageName()} REPL!`;\n    }\n    ps1() {\n        return \">>> \";\n    }\n    ps2() {\n        return \"... \";\n    }\n    /**\n     * Launch the kernel (used to wrap a promise around init).\n     */\n    async _init() { }\n    /**\n     * Initialize the kernel and start it.\n     */\n    async init() {\n        try {\n            await this._init();\n        }\n        catch (error) {\n            this._ready.reject(error);\n            return;\n        }\n        // connecting eval to basthon.eval.request event.\n        this.addEventListener(\"eval.request\", this.evalFromEvent.bind(this));\n        await this.start();\n    }\n    /**\n     * Start the kernel (used to wrap a promise around start).\n     */\n    async _start() { }\n    /**\n     * Start the kernel.\n     */\n    async start() {\n        await this._stopped;\n        this._execution_count = 0;\n        try {\n            await this._start();\n        }\n        catch (error) {\n            this._ready.reject(error);\n            return;\n        }\n        this._files.forEach((v, k) => this.putFile(k, v));\n        this._modules.forEach((v, k) => this.putModule(k, v));\n        this._isReady = true;\n        this._ready.resolve();\n    }\n    /**\n     * Perform async part of the stoping process.\n     */\n    async _stop() { }\n    /**\n     * Stop the kernel synchronously (to ensure kernel is stopped after the call).\n     */\n    stop() {\n        this._isReady = false;\n        this._ready = new PromiseDelegate();\n        this._stopped = this._stop();\n    }\n    /**\n     * Restart the kernel (stop and start).\n     * Use await this.ready() to ensure kernel is started\n     */\n    restart() {\n        this.stop(); // sync\n        this.start(); // async\n    }\n    /**\n     * Is the kernel ready?\n     */\n    get isReady() {\n        return this._isReady;\n    }\n    /**\n     * Promise that resolves when the kernel is ready (started).\n     */\n    async ready() {\n        return this._ready.promise;\n    }\n    /**\n     * Root for kernel files. This is always the language directory\n     * inside the version number directory inside the kernel directory.\n     */\n    basthonRoot(absolute = false) {\n        let url = this._rootPath + \"/\" + this.version() + \"/\" + this.language();\n        if (absolute && !url.startsWith(\"http\")) {\n            const base = window.location.origin + window.location.pathname;\n            url = base.substring(0, base.lastIndexOf(\"/\")) + \"/\" + url;\n        }\n        return url;\n    }\n    /**\n     * Downloading data (bytes array or data URL) as filename\n     * (opening browser dialog).\n     */\n    download(data, filename) {\n        if (!(typeof data === \"string\" || data instanceof String)) {\n            const blob = new Blob([data], { type: \"application/octet-stream\" });\n            data = window.URL.createObjectURL(blob);\n        }\n        const anchor = document.createElement(\"a\");\n        anchor.download = filename;\n        anchor.href = data;\n        anchor.target = \"_blank\";\n        anchor.style.display = \"none\"; // just to be safe!\n        document.body.appendChild(anchor);\n        anchor.click();\n        document.body.removeChild(anchor);\n    }\n    /**\n     * Dynamically load a script asynchronously.\n     */\n    static loadScript(url) {\n        return new Promise(function (resolve, reject) {\n            let script = document.createElement(\"script\");\n            script.onload = resolve;\n            script.onerror = reject;\n            script.src = url;\n            document.head.appendChild(script);\n        });\n    }\n    /**\n     * Wrapper around document.dispatchEvent.\n     * It adds the 'basthon.' prefix to each event name and\n     * manage the event lookup to retreive relevent data.\n     */\n    dispatchEvent(eventName, data) {\n        document.dispatchEvent(new BasthonEvent(`basthon.${eventName}`, data));\n    }\n    /**\n     * Wrapper around document.addEventListener.\n     * It manages the 'basthon.' prefix to each event name and\n     * manage the event lookup to retreive relevent data.\n     */\n    addEventListener(eventName, callback) {\n        // wrapped callback\n        const _callback = (event) => callback(event.detail);\n        document.addEventListener(`basthon.${eventName}`, _callback);\n        // register the wrapped callback in order to remove it\n        let listeners = this._listeners.get(eventName);\n        if (listeners == null) {\n            listeners = new Map();\n            this._listeners.set(eventName, listeners);\n        }\n        listeners.set(callback, _callback);\n    }\n    /**\n     * Wrapper around document.removeEventListener.\n     * It manages the 'basthon.' prefix to each event name.\n     */\n    removeEventListener(eventName, callback) {\n        // get the wrapped callback\n        const listeners = this._listeners.get(eventName);\n        document.removeEventListener(`basthon.${eventName}`, listeners?.get(callback));\n    }\n    /**\n     * Send eval.input event then wait for the user response and return it.\n     */\n    async inputAsync(prompt, password = false, data = undefined) {\n        data = this.clone(data);\n        data.content = { prompt, password };\n        const pd = new PromiseDelegate();\n        data.resolve = pd.resolve.bind(pd);\n        data.reject = pd.reject.bind(pd);\n        this._pendingInput = pd;\n        this.dispatchEvent(\"eval.input\", data);\n        const res = await pd.promise;\n        this._pendingInput = undefined;\n        return res;\n    }\n    /**\n     * Close a pending input.\n     */\n    resolvePendingInput() {\n        this._pendingInput?.resolve(\"\");\n    }\n    /**\n     * Simple clone via JSON copy.\n     */\n    clone(obj) {\n        // simple trick that is enough for our purpose.\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /**\n     * Put a ressource (file or module).\n     * Detection is based on extension.\n     */\n    async putRessource(filename, content) {\n        const ext = filename.split(\".\").pop() ?? \"\";\n        if (this.moduleExts().includes(ext)) {\n            return await this.putModule(filename, content);\n        }\n        else {\n            return await this.putFile(filename, content);\n        }\n    }\n    /**\n     * Is an input pending?\n     */\n    pendingInput() {\n        return this._pendingInput != null;\n    }\n    /**\n     * Internal. Code evaluation after an eval.request event.\n     */\n    async evalFromEvent(data) {\n        const stdCallback = (std) => (text) => {\n            let dataEvent = this.clone(data);\n            dataEvent.stream = std;\n            dataEvent.content = text;\n            this.dispatchEvent(\"eval.output\", dataEvent);\n        };\n        const outCallback = stdCallback(\"stdout\");\n        const errCallback = stdCallback(\"stderr\");\n        let args;\n        try {\n            args = await this.evalAsync(data.code, outCallback, errCallback, data);\n        }\n        catch (error) {\n            errCallback(error.toString());\n            const dataEvent = this.clone(data);\n            dataEvent.error = error;\n            dataEvent.execution_count = this.execution_count;\n            this.dispatchEvent(\"eval.error\", dataEvent);\n            return;\n        }\n        if (args == null)\n            return; // this should not happend\n        const result = args[0];\n        const executionCount = args[1];\n        let dataEvent = this.clone(data);\n        dataEvent.execution_count = executionCount;\n        if (result != null)\n            dataEvent.result = result;\n        this.dispatchEvent(\"eval.finished\", dataEvent);\n    }\n}\n","export const VERSION = \"0.62.22\";\n"],"names":[],"sourceRoot":""}