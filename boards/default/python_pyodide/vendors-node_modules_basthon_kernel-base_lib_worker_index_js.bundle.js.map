{"version":3,"file":"vendors-node_modules_basthon_kernel-base_lib_worker_index_js.bundle.js","mappings":";;;;;;;;;;;;;;;;AAA8B;AACE;;;;;;;;;;;;;;;;;;ACDyB;AACR;AACV;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU;AACrE,yBAAyB,gDAAgD,IAAI;AAC7E,4BAA4B,IAAI;AAChC,6BAA6B;AAC7B,4CAA4C,SAAS,mBAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,+CAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wJAAqC;AACpF,kBAAkB,SAAQ;AAC1B,SAAS;AACT,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA,6BAA6B,6CAAI;AACjC;AACA;AACA;AACA;AACA;AACA,iCAAiC,mDAAc;AAC/C,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClKmD;AACS;AAC7B;AAC/B;AACA;AACA,0BAA0B,6DAAe;AACzC;AACA;AACA;AACA;AACA,QAAQ,mDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uCAAuC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B","sources":["webpack://@mixly/python-pyodide/./node_modules/@basthon/kernel-base/lib/worker/index.js","webpack://@mixly/python-pyodide/./node_modules/@basthon/kernel-base/lib/worker/kernel-main.js","webpack://@mixly/python-pyodide/./node_modules/@basthon/kernel-base/lib/worker/kernel-worker.js"],"sourcesContent":["export * from \"./kernel-main\";\nexport * from \"./kernel-worker\";\n","import { wrap, createEndpoint, transfer } from \"comlink\";\nimport { NotImplementedError } from \"../commons\";\nimport { KernelBase } from \"../kernel\";\n// mock Worker to support sandboxing and keep webpack compatibility\nif (globalThis.Worker.name !== \"SandboxedWorker\") {\n    class SandboxedWorker extends Worker {\n        constructor(url, options) {\n            if (options.sandboxed) {\n                const absURL = new URL(url).href;\n                const assetsURL = absURL.substring(0, absURL.lastIndexOf(\"/\"));\n                // worker created with a 'data' url scheme has opaque origin\n                // https://html.spec.whatwg.org/multipage/workers.html#script-settings-for-workers:concept-origin-opaque\n                const workerScript = `self._assetsURL = \"${assetsURL}\";\n           globalThis = {importScripts: self.importScripts, location: \"${url}\"};\n           importScripts(\"${url}\");\n           globalThis = self;`.replace(/\\s/g, \"\");\n                super(`data:text/javascript;base64,${btoa(workerScript)}`);\n            }\n            else {\n                super(url, options);\n            }\n        }\n    }\n    globalThis.Worker = SandboxedWorker;\n}\nexport class KernelMainBase extends KernelBase {\n    constructor(options) {\n        super(options);\n    }\n    /**\n     * Is this kernel safe? (loaded in an isolated web worker)\n     */\n    safeKernel() {\n        return true;\n    }\n    /**\n     * Get a new worker (should be overloaded).\n     */\n    newWorker() {\n        throw new NotImplementedError(\"newWorker\");\n    }\n    /**\n     * Start the worker.\n     */\n    async _start() {\n        await super._start();\n        const worker = this.newWorker();\n        // setup the proxy worker\n        const proxyWorker = new Worker(new URL(\"./comlink-proxy.js\", import.meta.url), {\n            type: \"module\",\n        });\n        const proxy = wrap(proxyWorker);\n        // setup the kernel worker\n        this._worker = worker;\n        worker.onmessage = (e) => this.processWorkerMessage(e.data);\n        const KernelWorker = wrap(worker);\n        // why typescript complains about this call? yet, this is advertised in\n        // https://github.com/GoogleChromeLabs/comlink/blob/dffe9050f63b1b39f30213adeb1dd4b9ed7d2594/docs/examples/03-classes-example/index.html#L15\n        //@ts-ignore\n        this._remote = await new KernelWorker(this._options);\n        // bind ports\n        const port = await proxy[createEndpoint]();\n        await this.remote?.setProxyPort(transfer(port, [port]));\n        // init remote\n        await this.remote?.init();\n    }\n    /**\n     * Comlink remote getter.\n     */\n    get remote() {\n        return this._remote;\n    }\n    /**\n     * Stop the worker.\n     */\n    async _stop() {\n        this._worker?.terminate();\n        this._worker = undefined;\n        this._remote = undefined;\n        await super._stop();\n    }\n    /**\n     * Process messages from worker (if any).\n     */\n    processWorkerMessage(msg) {\n        switch (msg.type) {\n            case \"stream\":\n                const { stream, text } = msg.content;\n                const dataEvent = this.clone(msg.data);\n                dataEvent.stream = stream;\n                dataEvent.content = text;\n                this.dispatchEvent(\"eval.output\", dataEvent);\n                break;\n            case \"download\":\n                const { content, filename } = msg.content;\n                this.download(content, filename);\n                break;\n            case \"display\":\n                this.dispatchEvent(\"eval.display\", msg.data);\n                break;\n            case \"input\":\n                const { prompt, password, data, sab } = msg.content;\n                (async () => {\n                    const res = (await this.inputAsync(prompt, password, data));\n                    const encodedRes = new TextEncoder().encode(res);\n                    new Uint8Array(sab).set(encodedRes.subarray(0, sab.byteLength));\n                    Atomics.notify(new Int32Array(sab), 0, 1);\n                })();\n                break;\n            default: // ignoring (probably a comlink message)\n        }\n    }\n    async evalAsync(code, outCallback, errCallback, data = null) {\n        // force interactivity in all modes\n        data.interactive = true;\n        this._execution_count++;\n        // evaluation\n        const execResult = (await this.remote?.eval(data, code));\n        // return result\n        let result;\n        switch (execResult?.status) {\n            case \"ok\":\n                result = execResult.result;\n                break;\n            case \"error\":\n                break;\n        }\n        return [result, this._execution_count];\n    }\n    /**\n     * Put a file on the local (emulated) filesystem.\n     */\n    async putFile(filename, content) {\n        await super.putFile(filename, content);\n        await this.remote?.putFile(filename, content);\n    }\n    /**\n     * Put an importable module on the local (emulated) filesystem\n     * and load dependencies.\n     */\n    async putModule(filename, content) {\n        await super.putModule(filename, content);\n        await this.remote?.putModule(filename, content);\n    }\n    /**\n     * Complete a code at the end (usefull for tab completion).\n     *\n     * Returns an array of two elements: the list of completions\n     * and the start index.\n     */\n    async complete(code) {\n        return (await this.remote?.complete(code)) ?? [];\n    }\n    /**\n     * Tell wether we should wait for more code or if it can\n     * be run as is.\n     *\n     * Useful to set ps1/ps2 in console prompt.\n     */\n    async more(code) {\n        return (await this.remote?.more(code)) ?? false;\n    }\n}\n","import { PromiseDelegate } from \"promise-delegate\";\nimport { NotImplementedError, mockFetch } from \"../commons\";\nimport { wrap } from \"comlink\";\nclass KernelWorkerBase {\n    constructor(options) {\n        this._ready = new PromiseDelegate();\n        /* we mock the fetch function to:\n         *  - redirect queries to local FS\n         *  - bypass the worker's opaque origin\n         */\n        mockFetch();\n        // useful for ffi\n        self.basthon = this;\n        // global prompt redirected to our input\n        if (self._prompt == null)\n            self._prompt = globalThis.prompt;\n        globalThis.prompt = (prompt) => this.input(prompt);\n    }\n    /*\n     * Initialize the kernel. Should be overloaded.\n     */\n    async _init() { }\n    /**\n     * Initialize the kernel. It is called by initWorker in KernelBase.\n     */\n    async init() {\n        try {\n            await this._init();\n            this._ready.resolve();\n        }\n        catch (e) {\n            this._ready.reject(e);\n        }\n    }\n    /**\n     * Wait for the kernel to be ready.\n     */\n    ready() {\n        return this._ready.promise;\n    }\n    /**\n     * Set the comlink communication port to proxy fetch.\n     */\n    setProxyPort(port) {\n        self._remoteProxy = wrap(port);\n    }\n    /**\n     * Send stream to stdout/stderr.\n     */\n    sendStream(data, stream, text) {\n        globalThis.postMessage({\n            data,\n            type: \"stream\",\n            content: { stream, text },\n        });\n    }\n    /**\n     * Send stream to stdout.\n     */\n    sendStdoutStream(data, text) {\n        this.sendStream(data, \"stdout\", text);\n    }\n    /**\n     * Send stream to stderr.\n     */\n    sendStderrStream(data, text) {\n        this.sendStream(data, \"stderr\", text);\n    }\n    async blobToDataURL(blob) {\n        return await new Promise((resolve) => {\n            const reader = new FileReader();\n            reader.onloadend = () => resolve(reader.result);\n            reader.readAsDataURL(blob);\n        });\n    }\n    /**\n     * Display a blob (only png images are supported).\n     */\n    async displayBlob(blob, data) {\n        if (data == null)\n            data = this.clone(this.__eval_data__);\n        const dataURL = await this.blobToDataURL(blob);\n        const pngPrefix = \"data:image/png;base64,\";\n        if (dataURL.startsWith(pngPrefix)) {\n            const png = dataURL.slice(pngPrefix.length);\n            data[\"display_type\"] = \"multiple\";\n            data[\"content\"] = { \"image/png\": png };\n        }\n        else {\n            return;\n        }\n        globalThis.postMessage({ data, type: \"display\" });\n    }\n    /**\n     * Display an element like a canvas, ... in the frontend.\n     */\n    display(element) {\n        const data = this.clone(this.__eval_data__);\n        if (globalThis.OffscreenCanvas != null &&\n            element instanceof OffscreenCanvas) {\n            element\n                .convertToBlob()\n                .then((blob) => this.displayBlob(blob, data));\n        }\n        else {\n            data[\"display_type\"] = \"multiple\";\n            data[\"content\"] = element;\n            globalThis.postMessage({ data, type: \"display\" });\n        }\n    }\n    /**\n     * Evaluate code and return an object with mime type keys and string value.\n     * To be overloaded.\n     */\n    async _eval(data, code) {\n        throw new NotImplementedError(\"_eval\");\n    }\n    /**\n     * Evaluate a string of code. To be called by main thread (through comlink).\n     */\n    async eval(data, code) {\n        this.__eval_data__ = data;\n        try {\n            const result = await this._eval(data, code);\n            return { data, status: \"ok\", result };\n        }\n        catch (e) {\n            const { name, stack, message } = e;\n            this.sendStderrStream(data, e.toString());\n            return {\n                data,\n                status: \"error\",\n                error: {\n                    name: name,\n                    value: message,\n                    traceback: stack?.toString(),\n                },\n            };\n        }\n    }\n    /**\n     * Put a file on the local (emulated) filesystem.\n     */\n    putFile(filename, content) {\n        throw new NotImplementedError(\"putFile\");\n    }\n    /**\n     * Put an importable module on the local (emulated) filesystem\n     * and load dependencies.\n     */\n    putModule(filename, content) {\n        throw new NotImplementedError(\"putModule\");\n    }\n    /**\n     * Complete the submited code.\n     */\n    async complete(code) {\n        return [];\n    }\n    /**\n     * Tell wether we should wait for more code or if it can\n     * be run as is.\n     *\n     * Useful to set ps1/ps2 in console prompt.\n     */\n    async more(code) {\n        throw new NotImplementedError(\"more\");\n    }\n    /**\n     * Send a message to the main thread to download a file.\n     */\n    download(content, filename) {\n        globalThis.postMessage({\n            type: \"download\",\n            content: { content, filename },\n        });\n    }\n    /**\n     * Use JSON stringify/parse to copy an object.\n     */\n    clone(data) {\n        return JSON.parse(JSON.stringify(data));\n    }\n    /**\n     * Sync sleep for a certain duration in seconds.\n     */\n    sleep(duration) {\n        duration = duration * 1000; // to milliseconds\n        if (globalThis.crossOriginIsolated) {\n            const sab = new Int32Array(new SharedArrayBuffer(4));\n            Atomics.wait(sab, 0, 0, duration);\n            return;\n        }\n        else {\n            const t0 = Date.now();\n            // active sleep\n            while (Date.now() - t0 < duration)\n                ;\n        }\n    }\n    /**\n     * Decode the string contained in a SharedArrayBuffer to\n     * bypas this issue:\n     * https://github.com/whatwg/encoding/issues/172\n     */\n    decodeSharedArrayBuffer(sab) {\n        const array = new Uint8Array(sab);\n        let length = array.length;\n        for (; length > 0 && array[length - 1] === 0; length--)\n            ;\n        if (length === 0)\n            return \"\";\n        const cropped = new Uint8Array(length);\n        cropped.set(array.subarray(0, length));\n        try {\n            return new TextDecoder().decode(cropped);\n        }\n        catch (e) {\n            if (array.length === length)\n                throw new Error(\"String too long, can't decode\");\n            throw e;\n        }\n    }\n    /**\n     * Sync input that does not use the ugly prompt but send\n     * an eval.input event tho the main thread and wait for the response.\n     */\n    input(prompt, password = false) {\n        if (globalThis.crossOriginIsolated) {\n            const data = this.clone(this.__eval_data__);\n            const sab = new SharedArrayBuffer(1024);\n            globalThis.postMessage({\n                type: \"input\",\n                content: { data, prompt, password, sab },\n            });\n            Atomics.wait(new Int32Array(sab), 0, 0);\n            return this.decodeSharedArrayBuffer(sab);\n        }\n        else {\n            return self._prompt(prompt ?? \"\") ?? \"\";\n        }\n    }\n}\nexport { KernelWorkerBase };\n"],"names":[],"sourceRoot":""}