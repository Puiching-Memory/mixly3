"use strict";
(self["webpackChunk_mixly_python_pyodide"] = self["webpackChunk_mixly_python_pyodide"] || []).push([["vendors-node_modules_basthon_kernel-base_lib_worker_index_js"],{

/***/ "./node_modules/@basthon/kernel-base/lib/worker/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@basthon/kernel-base/lib/worker/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KernelMainBase: () => (/* reexport safe */ _kernel_main__WEBPACK_IMPORTED_MODULE_0__.KernelMainBase),
/* harmony export */   KernelWorkerBase: () => (/* reexport safe */ _kernel_worker__WEBPACK_IMPORTED_MODULE_1__.KernelWorkerBase)
/* harmony export */ });
/* harmony import */ var _kernel_main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./kernel-main */ "./node_modules/@basthon/kernel-base/lib/worker/kernel-main.js");
/* harmony import */ var _kernel_worker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./kernel-worker */ "./node_modules/@basthon/kernel-base/lib/worker/kernel-worker.js");




/***/ }),

/***/ "./node_modules/@basthon/kernel-base/lib/worker/kernel-main.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basthon/kernel-base/lib/worker/kernel-main.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KernelMainBase: () => (/* binding */ KernelMainBase)
/* harmony export */ });
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! comlink */ "./node_modules/comlink/dist/esm/comlink.mjs");
/* harmony import */ var _commons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../commons */ "./node_modules/@basthon/kernel-base/lib/commons.js");
/* harmony import */ var _kernel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../kernel */ "./node_modules/@basthon/kernel-base/lib/kernel.js");



// mock Worker to support sandboxing and keep webpack compatibility
if (globalThis.Worker.name !== "SandboxedWorker") {
    class SandboxedWorker extends Worker {
        constructor(url, options) {
            if (options.sandboxed) {
                const absURL = new URL(url).href;
                const assetsURL = absURL.substring(0, absURL.lastIndexOf("/"));
                // worker created with a 'data' url scheme has opaque origin
                // https://html.spec.whatwg.org/multipage/workers.html#script-settings-for-workers:concept-origin-opaque
                const workerScript = `self._assetsURL = "${assetsURL}";
           globalThis = {importScripts: self.importScripts, location: "${url}"};
           importScripts("${url}");
           globalThis = self;`.replace(/\s/g, "");
                super(`data:text/javascript;base64,${btoa(workerScript)}`);
            }
            else {
                super(url, options);
            }
        }
    }
    globalThis.Worker = SandboxedWorker;
}
class KernelMainBase extends _kernel__WEBPACK_IMPORTED_MODULE_1__.KernelBase {
    constructor(options) {
        super(options);
    }
    /**
     * Is this kernel safe? (loaded in an isolated web worker)
     */
    safeKernel() {
        return true;
    }
    /**
     * Get a new worker (should be overloaded).
     */
    newWorker() {
        throw new _commons__WEBPACK_IMPORTED_MODULE_0__.NotImplementedError("newWorker");
    }
    /**
     * Start the worker.
     */
    async _start() {
        await super._start();
        const worker = this.newWorker();
        // setup the proxy worker
        const proxyWorker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("node_modules_basthon_kernel-base_lib_worker_comlink-proxy_js"), __webpack_require__.b), {
            type: undefined,
        });
        const proxy = (0,comlink__WEBPACK_IMPORTED_MODULE_2__.wrap)(proxyWorker);
        // setup the kernel worker
        this._worker = worker;
        worker.onmessage = (e) => this.processWorkerMessage(e.data);
        const KernelWorker = (0,comlink__WEBPACK_IMPORTED_MODULE_2__.wrap)(worker);
        // why typescript complains about this call? yet, this is advertised in
        // https://github.com/GoogleChromeLabs/comlink/blob/dffe9050f63b1b39f30213adeb1dd4b9ed7d2594/docs/examples/03-classes-example/index.html#L15
        //@ts-ignore
        this._remote = await new KernelWorker(this._options);
        // bind ports
        const port = await proxy[comlink__WEBPACK_IMPORTED_MODULE_2__.createEndpoint]();
        await this.remote?.setProxyPort((0,comlink__WEBPACK_IMPORTED_MODULE_2__.transfer)(port, [port]));
        // init remote
        await this.remote?.init();
    }
    /**
     * Comlink remote getter.
     */
    get remote() {
        return this._remote;
    }
    /**
     * Stop the worker.
     */
    async _stop() {
        this._worker?.terminate();
        this._worker = undefined;
        this._remote = undefined;
        await super._stop();
    }
    /**
     * Process messages from worker (if any).
     */
    processWorkerMessage(msg) {
        switch (msg.type) {
            case "stream":
                const { stream, text } = msg.content;
                const dataEvent = this.clone(msg.data);
                dataEvent.stream = stream;
                dataEvent.content = text;
                this.dispatchEvent("eval.output", dataEvent);
                break;
            case "download":
                const { content, filename } = msg.content;
                this.download(content, filename);
                break;
            case "display":
                this.dispatchEvent("eval.display", msg.data);
                break;
            case "input":
                const { prompt, password, data, sab } = msg.content;
                (async () => {
                    const res = (await this.inputAsync(prompt, password, data));
                    const encodedRes = new TextEncoder().encode(res);
                    new Uint8Array(sab).set(encodedRes.subarray(0, sab.byteLength));
                    Atomics.notify(new Int32Array(sab), 0, 1);
                })();
                break;
            default: // ignoring (probably a comlink message)
        }
    }
    async evalAsync(code, outCallback, errCallback, data = null) {
        // force interactivity in all modes
        data.interactive = true;
        this._execution_count++;
        // evaluation
        const execResult = (await this.remote?.eval(data, code));
        // return result
        let result;
        switch (execResult?.status) {
            case "ok":
                result = execResult.result;
                break;
            case "error":
                break;
        }
        return [result, this._execution_count];
    }
    /**
     * Put a file on the local (emulated) filesystem.
     */
    async putFile(filename, content) {
        await super.putFile(filename, content);
        await this.remote?.putFile(filename, content);
    }
    /**
     * Put an importable module on the local (emulated) filesystem
     * and load dependencies.
     */
    async putModule(filename, content) {
        await super.putModule(filename, content);
        await this.remote?.putModule(filename, content);
    }
    /**
     * Complete a code at the end (usefull for tab completion).
     *
     * Returns an array of two elements: the list of completions
     * and the start index.
     */
    async complete(code) {
        return (await this.remote?.complete(code)) ?? [];
    }
    /**
     * Tell wether we should wait for more code or if it can
     * be run as is.
     *
     * Useful to set ps1/ps2 in console prompt.
     */
    async more(code) {
        return (await this.remote?.more(code)) ?? false;
    }
}


/***/ }),

/***/ "./node_modules/@basthon/kernel-base/lib/worker/kernel-worker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@basthon/kernel-base/lib/worker/kernel-worker.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KernelWorkerBase: () => (/* binding */ KernelWorkerBase)
/* harmony export */ });
/* harmony import */ var promise_delegate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! promise-delegate */ "./node_modules/promise-delegate/dist/es/PromiseDelegate.js");
/* harmony import */ var _commons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../commons */ "./node_modules/@basthon/kernel-base/lib/commons.js");
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! comlink */ "./node_modules/comlink/dist/esm/comlink.mjs");



class KernelWorkerBase {
    constructor(options) {
        this._ready = new promise_delegate__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();
        /* we mock the fetch function to:
         *  - redirect queries to local FS
         *  - bypass the worker's opaque origin
         */
        (0,_commons__WEBPACK_IMPORTED_MODULE_1__.mockFetch)();
        // useful for ffi
        self.basthon = this;
        // global prompt redirected to our input
        if (self._prompt == null)
            self._prompt = globalThis.prompt;
        globalThis.prompt = (prompt) => this.input(prompt);
    }
    /*
     * Initialize the kernel. Should be overloaded.
     */
    async _init() { }
    /**
     * Initialize the kernel. It is called by initWorker in KernelBase.
     */
    async init() {
        try {
            await this._init();
            this._ready.resolve();
        }
        catch (e) {
            this._ready.reject(e);
        }
    }
    /**
     * Wait for the kernel to be ready.
     */
    ready() {
        return this._ready.promise;
    }
    /**
     * Set the comlink communication port to proxy fetch.
     */
    setProxyPort(port) {
        self._remoteProxy = (0,comlink__WEBPACK_IMPORTED_MODULE_2__.wrap)(port);
    }
    /**
     * Send stream to stdout/stderr.
     */
    sendStream(data, stream, text) {
        globalThis.postMessage({
            data,
            type: "stream",
            content: { stream, text },
        });
    }
    /**
     * Send stream to stdout.
     */
    sendStdoutStream(data, text) {
        this.sendStream(data, "stdout", text);
    }
    /**
     * Send stream to stderr.
     */
    sendStderrStream(data, text) {
        this.sendStream(data, "stderr", text);
    }
    async blobToDataURL(blob) {
        return await new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });
    }
    /**
     * Display a blob (only png images are supported).
     */
    async displayBlob(blob, data) {
        if (data == null)
            data = this.clone(this.__eval_data__);
        const dataURL = await this.blobToDataURL(blob);
        const pngPrefix = "data:image/png;base64,";
        if (dataURL.startsWith(pngPrefix)) {
            const png = dataURL.slice(pngPrefix.length);
            data["display_type"] = "multiple";
            data["content"] = { "image/png": png };
        }
        else {
            return;
        }
        globalThis.postMessage({ data, type: "display" });
    }
    /**
     * Display an element like a canvas, ... in the frontend.
     */
    display(element) {
        const data = this.clone(this.__eval_data__);
        if (globalThis.OffscreenCanvas != null &&
            element instanceof OffscreenCanvas) {
            element
                .convertToBlob()
                .then((blob) => this.displayBlob(blob, data));
        }
        else {
            data["display_type"] = "multiple";
            data["content"] = element;
            globalThis.postMessage({ data, type: "display" });
        }
    }
    /**
     * Evaluate code and return an object with mime type keys and string value.
     * To be overloaded.
     */
    async _eval(data, code) {
        throw new _commons__WEBPACK_IMPORTED_MODULE_1__.NotImplementedError("_eval");
    }
    /**
     * Evaluate a string of code. To be called by main thread (through comlink).
     */
    async eval(data, code) {
        this.__eval_data__ = data;
        try {
            const result = await this._eval(data, code);
            return { data, status: "ok", result };
        }
        catch (e) {
            const { name, stack, message } = e;
            this.sendStderrStream(data, e.toString());
            return {
                data,
                status: "error",
                error: {
                    name: name,
                    value: message,
                    traceback: stack?.toString(),
                },
            };
        }
    }
    /**
     * Put a file on the local (emulated) filesystem.
     */
    putFile(filename, content) {
        throw new _commons__WEBPACK_IMPORTED_MODULE_1__.NotImplementedError("putFile");
    }
    /**
     * Put an importable module on the local (emulated) filesystem
     * and load dependencies.
     */
    putModule(filename, content) {
        throw new _commons__WEBPACK_IMPORTED_MODULE_1__.NotImplementedError("putModule");
    }
    /**
     * Complete the submited code.
     */
    async complete(code) {
        return [];
    }
    /**
     * Tell wether we should wait for more code or if it can
     * be run as is.
     *
     * Useful to set ps1/ps2 in console prompt.
     */
    async more(code) {
        throw new _commons__WEBPACK_IMPORTED_MODULE_1__.NotImplementedError("more");
    }
    /**
     * Send a message to the main thread to download a file.
     */
    download(content, filename) {
        globalThis.postMessage({
            type: "download",
            content: { content, filename },
        });
    }
    /**
     * Use JSON stringify/parse to copy an object.
     */
    clone(data) {
        return JSON.parse(JSON.stringify(data));
    }
    /**
     * Sync sleep for a certain duration in seconds.
     */
    sleep(duration) {
        duration = duration * 1000; // to milliseconds
        if (globalThis.crossOriginIsolated) {
            const sab = new Int32Array(new SharedArrayBuffer(4));
            Atomics.wait(sab, 0, 0, duration);
            return;
        }
        else {
            const t0 = Date.now();
            // active sleep
            while (Date.now() - t0 < duration)
                ;
        }
    }
    /**
     * Decode the string contained in a SharedArrayBuffer to
     * bypas this issue:
     * https://github.com/whatwg/encoding/issues/172
     */
    decodeSharedArrayBuffer(sab) {
        const array = new Uint8Array(sab);
        let length = array.length;
        for (; length > 0 && array[length - 1] === 0; length--)
            ;
        if (length === 0)
            return "";
        const cropped = new Uint8Array(length);
        cropped.set(array.subarray(0, length));
        try {
            return new TextDecoder().decode(cropped);
        }
        catch (e) {
            if (array.length === length)
                throw new Error("String too long, can't decode");
            throw e;
        }
    }
    /**
     * Sync input that does not use the ugly prompt but send
     * an eval.input event tho the main thread and wait for the response.
     */
    input(prompt, password = false) {
        if (globalThis.crossOriginIsolated) {
            const data = this.clone(this.__eval_data__);
            const sab = new SharedArrayBuffer(1024);
            globalThis.postMessage({
                type: "input",
                content: { data, prompt, password, sab },
            });
            Atomics.wait(new Int32Array(sab), 0, 0);
            return this.decodeSharedArrayBuffer(sab);
        }
        else {
            return self._prompt(prompt ?? "") ?? "";
        }
    }
}



/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_basthon_kernel-base_lib_worker_index_js.bundle.js.map